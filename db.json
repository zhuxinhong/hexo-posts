{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/exturl.js","path":"js/src/exturl.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/js.cookie.js","path":"js/src/js.cookie.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scroll-cookie.js","path":"js/src/scroll-cookie.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","path":"lib/algolia-instant-search/instantsearch.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","path":"lib/canvas-nest/canvas-nest.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","path":"lib/canvas-ribbon/canvas-ribbon.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/LICENSE","path":"lib/fastclick/LICENSE","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/bower.json","path":"lib/fastclick/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","path":"lib/jquery_lazyload/CONTRIBUTING.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","path":"lib/jquery_lazyload/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","path":"lib/jquery_lazyload/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","path":"lib/jquery_lazyload/jquery.lazyload.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","path":"lib/jquery_lazyload/jquery.scrollstop.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","path":"lib/needsharebutton/font-embedded.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","path":"lib/needsharebutton/needsharebutton.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","path":"lib/needsharebutton/needsharebutton.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","path":"lib/pace/pace-theme-barber-shop.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","path":"lib/pace/pace-theme-big-counter.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","path":"lib/pace/pace-theme-bounce.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","path":"lib/pace/pace-theme-center-atom.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","path":"lib/pace/pace-theme-center-circle.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","path":"lib/pace/pace-theme-center-simple.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","path":"lib/pace/pace-theme-center-radar.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","path":"lib/pace/pace-theme-corner-indicator.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","path":"lib/pace/pace-theme-fill-left.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","path":"lib/pace/pace-theme-flash.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","path":"lib/pace/pace-theme-loading-bar.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","path":"lib/pace/pace-theme-mac-osx.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","path":"lib/pace/pace-theme-minimal.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace.min.js","path":"lib/pace/pace.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","path":"lib/three/canvas_lines.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","path":"lib/three/canvas_sphere.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/bower.json","path":"lib/velocity/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/three-waves.min.js","path":"lib/three/three-waves.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/README.md","path":"lib/fastclick/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.css","path":"lib/Han/dist/han.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.js","path":"lib/Han/dist/han.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.css","path":"lib/Han/dist/han.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","path":"lib/fancybox/source/blank.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","path":"lib/fancybox/source/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","path":"lib/fancybox/source/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","path":"lib/fancybox/source/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","path":"lib/fancybox/source/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","path":"lib/fancybox/source/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","path":"lib/fancybox/source/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","path":"lib/fancybox/source/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","path":"lib/fancybox/source/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","path":"lib/fastclick/lib/fastclick.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","path":"lib/fastclick/lib/fastclick.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.js","path":"lib/Han/dist/han.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","path":"lib/Han/dist/font/han-space.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","path":"lib/Han/dist/font/han-space.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","path":"lib/Han/dist/font/han.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","path":"lib/Han/dist/font/han.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","path":"lib/Han/dist/font/han.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","path":"lib/fancybox/source/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","path":"lib/fancybox/source/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","path":"lib/algolia-instant-search/instantsearch.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/three.min.js","path":"lib/three/three.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":0,"renderable":1},{"_id":"source/images/Wechat.jpeg","path":"images/Wechat.jpeg","modified":0,"renderable":0}],"Cache":[{"_id":"source/.DS_Store","hash":"bbdefc83128e4234a01216f67e7ad5fe713fa796","modified":1570624363191},{"_id":"source/_drafts/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1553761840063},{"_id":"source/_drafts/ElasticsearchJavaAPI.md","hash":"2b3476f824f9b0e57376f8df413bde7e2e29a1f9","modified":1558072678546},{"_id":"source/_drafts/Servlet工作原理分析.md","hash":"c42828fccb8c1e7e58b0860fc9c2e4cf7685f0d6","modified":1558072678547},{"_id":"source/_drafts/预防线程死锁.md","hash":"2dd1abd7848be2f15c8f8860bc0a623f394f7a0c","modified":1558072678549},{"_id":"source/_posts/.DS_Store","hash":"98a8dc87d9747eb7e00788394a55d7cf0b7343ab","modified":1570614325157},{"_id":"source/categories/index.md","hash":"a41bc681415bccb0adc8c01f45ab30c5690f9723","modified":1558072678589},{"_id":"source/categories/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1553761860230},{"_id":"source/images/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1473041012000},{"_id":"source/tags/index.md","hash":"18e54dda6dc94890ea605e79fd135963fbbf35a9","modified":1473047063000},{"_id":"source/_posts/HBase/初识HBase.md","hash":"4823723aee79b6711c49c4862da0cdeb4e613053","modified":1558072678550},{"_id":"source/_posts/Java Web/DNS域名解析过程.md","hash":"f8e03830ed8a372fcd6e440e234fd8815c74f0ea","modified":1558072678551},{"_id":"source/_posts/Java Web/Java8新特性 -- 初识lambda.md","hash":"6b95e1fc0f9a2ee7b27618dabdf73791e7196953","modified":1558072678554},{"_id":"source/_posts/Java Web/Java8新特性 -- StreamAPI.md","hash":"0d9f4420a6bd0cb401d367f60927f2d903f2e018","modified":1558072678552},{"_id":"source/_posts/Java Web/NIO的工作机制.md","hash":"8ca7fc8f26942fa8cb738c373f65d34abe0a4ab6","modified":1558072678555},{"_id":"source/_posts/Java Web/Tomcat的系统架构.md","hash":"77e684f8a8e396aa7c98d3a9a6d6820771f4f2cb","modified":1558072678556},{"_id":"source/_posts/Java Web/可能错过的Java7特性.md","hash":"75af664a91e9daf1da102c25d6aec39a58ada270","modified":1558072678557},{"_id":"source/_posts/Java Web/深入分析ClassLoader.md","hash":"c4e49541646a0382ca9bb36e2e05ee239e45d97d","modified":1558072678557},{"_id":"source/_posts/Java Web/深入分析IO工作机制.md","hash":"4f24f23acf111930d4bbb91d01486b196ee70e87","modified":1558072678558},{"_id":"source/_posts/Scala/Scala基础.md","hash":"703bc10e821d7208a0fc72c9ef46fbf261a07de2","modified":1558072678559},{"_id":"source/_posts/SpringCloud/Hystrix.md","hash":"01e3856fee599278b7110072a7554a2e9cb1533d","modified":1500455571000},{"_id":"source/_posts/redis设计与实现/RedisRDB文件结构.md","hash":"e58d5bf092c75fc35bcf87e9666892831b4a67b8","modified":1558072678560},{"_id":"source/_posts/redis设计与实现/Redis中的数据库.md","hash":"a10c9da8e01cf86d49b0632e35638fe35785be64","modified":1558072678560},{"_id":"source/_posts/redis设计与实现/Redis压缩列表.md","hash":"b79206236dda0a17700f0562f92a4efb53b4e56d","modified":1558072678562},{"_id":"source/_posts/redis设计与实现/Redis哈希对象.md","hash":"33d98a82d4f855f65e52d5c10287b186bf685c4b","modified":1558072678562},{"_id":"source/_posts/redis设计与实现/Redis字典的实现.md","hash":"b5eef15c61d510fb95cb3939f5c2d3c6904142ca","modified":1558072678563},{"_id":"source/_posts/redis设计与实现/Redis客户端.md","hash":"a0013e18af91acdeadadece613ff8ac9e4066779","modified":1558072678565},{"_id":"source/_posts/redis设计与实现/Redis对象.md","hash":"d5a949692035800333f67ba46993f64cde1f7314","modified":1558072678567},{"_id":"source/_posts/redis设计与实现/Redis持久化-RDB.md","hash":"e95cbd67b13cc124e2a21294b2c398a2364c351b","modified":1558072678571},{"_id":"source/_posts/redis设计与实现/Redis持久化-AOF.md","hash":"c62bb32788b86fc921144bfe7c9bc43541576259","modified":1558072678568},{"_id":"source/_posts/redis设计与实现/Redis文件事件.md","hash":"0d2aaa39b452411ecedf9909666fff43837efb11","modified":1558072678572},{"_id":"source/_posts/redis设计与实现/Redis时间事件.md","hash":"66ee4c1b05656367f47ffc1ff642917d835a762e","modified":1558072678573},{"_id":"source/_posts/redis设计与实现/Redis服务器单机数据库的实现.md","hash":"933ad2fe56ca09f591492ccada24d4e85bcee689","modified":1558072678575},{"_id":"source/_posts/redis设计与实现/Redis简单动态字符串.md","hash":"d8ccc256d2377121d64fc6f5f1272e4e41f98ff7","modified":1558072678576},{"_id":"source/_posts/redis设计与实现/Redis类型检查和命令多态.md","hash":"ea37510a3b6d34744fcd407694f6ae29a3d93ea8","modified":1558072678577},{"_id":"source/_posts/redis设计与实现/Redis链表数据结构.md","hash":"989a33816736d623fa716dfe69212afd101e2a9e","modified":1558072678578},{"_id":"source/_posts/深入理解Java虚拟机/垃圾收集器算法.md","hash":"8a22ce826dcbd67bbc06da83bd8116e8a8cc6046","modified":1558072678580},{"_id":"source/_posts/深入理解Java虚拟机/运行时数据区域.md","hash":"7ac9f5ecf6b343abf08cf3b2602143e6d91af13c","modified":1558072678583},{"_id":"source/_posts/redis设计与实现/Redis跳跃表.md","hash":"5ff45bd313b2a083435fa08af86c8b224c6e407a","modified":1558072678577},{"_id":"source/_posts/编写高质量代码/基本类型.md","hash":"2854c4c3ca174ff4963b55e5471e19dadc464446","modified":1558072678585},{"_id":"source/_posts/编写高质量代码/字符串.md","hash":"36e180ce016f8a0b843c7947760f4f9ad968e7aa","modified":1558072678585},{"_id":"source/_posts/编写高质量代码/工程质量.md","hash":"8cefa88e196b293ba758b68594fe3d3ca25b75ff","modified":1558072678586},{"_id":"source/_posts/编写高质量代码/数组和集合.md","hash":"d674e6c66c0f6c5397e2e8e9d11667f2c6857f54","modified":1558072678586},{"_id":"source/_posts/编写高质量代码/类、对象及方法.md","hash":"6f3bca632132721fc69845d50ed9e4c4eb0a88be","modified":1558072678588},{"_id":"public/categories/index.html","hash":"1eedc1b99c2917db69333cbb1a2dc2c3cdbb961e","modified":1570624384110},{"_id":"public/2017/06/12/编写高质量代码/工程质量/index.html","hash":"27af6d8b31014e415477229552000880647b616f","modified":1570624384120},{"_id":"public/tags/index.html","hash":"3e8dfca9a126f5fa9ae07ba1b3fe3247268fb29b","modified":1570624384110},{"_id":"public/2017/07/16/SpringCloud/Hystrix/index.html","hash":"894b60ce7661cef80b0d0189bc70a37ae2663b85","modified":1570624384120},{"_id":"public/2017/06/11/编写高质量代码/数组和集合/index.html","hash":"47f0d6989badfab5983929c366fdfe89cb85892e","modified":1570624384120},{"_id":"public/2017/06/03/编写高质量代码/字符串/index.html","hash":"b37ac23a542712baffea412c3579bea92b8f07f6","modified":1570624384120},{"_id":"public/2017/01/23/编写高质量代码/类、对象及方法/index.html","hash":"fd31541f8f3399098c11e159d0a46c4ac10d0093","modified":1570624384120},{"_id":"public/2016/07/05/HBase/初识HBase/index.html","hash":"bc5b4b7ecd3bb19ff3269456d8c724492b265207","modified":1570624384121},{"_id":"public/2016/08/09/编写高质量代码/基本类型/index.html","hash":"af8aad231fed0d16f6f15b1efd771a64cfef240c","modified":1570624384121},{"_id":"public/2016/06/07/Scala/Scala基础/index.html","hash":"d2a85cee3ae0fcf8aefb0604c44a9e31a016baa2","modified":1570624384121},{"_id":"public/2016/05/15/深入理解Java虚拟机/垃圾收集器算法/index.html","hash":"22a64b3baa57c255c779640b89830922c6a514d8","modified":1570624384121},{"_id":"public/2016/05/07/深入理解Java虚拟机/运行时数据区域/index.html","hash":"219ae08e2563fd5cd2f75ed404eed54f212c8e67","modified":1570624384121},{"_id":"public/2015/07/11/redis设计与实现/Redis持久化-AOF/index.html","hash":"53cf9a37d7a709f59ce98798ad911f4f13000c68","modified":1570624384122},{"_id":"public/2015/07/11/redis设计与实现/Redis文件事件/index.html","hash":"dd9c94ee4792fea98e9e47fbea778e6346efc683","modified":1570624384122},{"_id":"public/2015/07/22/redis设计与实现/Redis客户端/index.html","hash":"8cc1561994f029a847c96e5da48721277363da05","modified":1570624384110},{"_id":"public/2015/07/12/redis设计与实现/Redis时间事件/index.html","hash":"5a331e60aa1fbdfdd58b0f5fa20c96b8f5b2b555","modified":1570624384122},{"_id":"public/2015/07/01/redis设计与实现/Redis中的数据库/index.html","hash":"3ea6eeaa4f4be8f30d88b8c88b583afee37d80a3","modified":1570624384123},{"_id":"public/2015/07/01/redis设计与实现/Redis持久化-RDB/index.html","hash":"5c3f84e89aeae3e704a3a70c0337a5ee00828dbf","modified":1570624384111},{"_id":"public/2015/07/01/redis设计与实现/Redis类型检查和命令多态/index.html","hash":"b9eb4250a7287e331cdf9efd4dde5b312a7cde18","modified":1570624384111},{"_id":"public/2015/07/04/redis设计与实现/RedisRDB文件结构/index.html","hash":"30cec71efd7ab1cddcd9e80f1010ccb59eeb0354","modified":1570624384122},{"_id":"public/2015/07/22/redis设计与实现/Redis服务器单机数据库的实现/index.html","hash":"f9a1d27e142c16a2498e5e3d496f76f1bf07c628","modified":1570624384110},{"_id":"public/2015/06/28/redis设计与实现/Redis哈希对象/index.html","hash":"aa7bd981fd945ab37b41b2a29522998f0b171061","modified":1570624384111},{"_id":"public/2015/06/28/redis设计与实现/Redis对象/index.html","hash":"e4cd02778781e44a0261f55f381b7635110c9cf3","modified":1570624384111},{"_id":"public/2015/06/24/redis设计与实现/Redis链表数据结构/index.html","hash":"a390b234fd9767d86357f19a88a4ca9eff6f4820","modified":1570624384111},{"_id":"public/2015/06/23/redis设计与实现/Redis简单动态字符串/index.html","hash":"5dc2b63862a8a0e0dde11bc18948eaef53addaec","modified":1570624384112},{"_id":"public/2015/06/25/redis设计与实现/Redis字典的实现/index.html","hash":"279b94838e9624d2f0732e156a5397b4c32a95c4","modified":1570624384123},{"_id":"public/2015/06/27/redis设计与实现/Redis跳跃表/index.html","hash":"3b82cd21f93341875cf14c722c51f0800b72dfa1","modified":1570624384123},{"_id":"public/2015/06/27/redis设计与实现/Redis压缩列表/index.html","hash":"d4cfc2446349d5433843bcb53514f7e5220c5567","modified":1570624384111},{"_id":"public/archives/index.html","hash":"8e7c0b5efbd568345b1896d65d7ffee0b4b4dbda","modified":1570624384113},{"_id":"public/archives/page/3/index.html","hash":"d21564033cbb98be722c5a64d7cdaf9e89e4f13b","modified":1570624384113},{"_id":"public/archives/page/6/index.html","hash":"116069c7e5cadf45684a99ec49364c35303dd5aa","modified":1570624384114},{"_id":"public/archives/page/4/index.html","hash":"5cccbf38de9e06becbc24b8fcc07e705f37efaff","modified":1570624384113},{"_id":"public/archives/page/2/index.html","hash":"4cb0d4395136aec51ad6147a00b61bb5536ee01f","modified":1570624384113},{"_id":"public/archives/page/7/index.html","hash":"494ddfecc4d725811949be3242691d08ea3b2a52","modified":1570624384114},{"_id":"public/archives/2015/index.html","hash":"3a72e80e5165d4df329a68aa7a566b9ac82c1f61","modified":1570624384114},{"_id":"public/archives/2015/page/4/index.html","hash":"f95b5bf919f52c5f8c0d86304de49dcd802b29f6","modified":1570624384114},{"_id":"public/archives/2015/page/3/index.html","hash":"f2595bde9d3c0f94c2c1226c4384d97b540c3da4","modified":1570624384114},{"_id":"public/archives/2015/06/index.html","hash":"5073ea544e73c603c9c5b2b5480232744aee37f4","modified":1570624384114},{"_id":"public/archives/2015/07/index.html","hash":"a89ec84ebfdcdd6071e9230b97a9cb0f58c9c084","modified":1570624384115},{"_id":"public/archives/page/5/index.html","hash":"f3111728eb172b584c65bc13d94c5fede822f45f","modified":1570624384114},{"_id":"public/archives/2015/page/2/index.html","hash":"87101dcd93fc2d79704592fee6721eed3fb7910d","modified":1570624384114},{"_id":"public/archives/2015/07/page/2/index.html","hash":"ea38e99fc7d8ca21181a60c924846b7b28697fda","modified":1570624384115},{"_id":"public/archives/2015/06/page/2/index.html","hash":"ce70e91136c4b712227f12739fc01398296423d8","modified":1570624384114},{"_id":"public/archives/2016/05/index.html","hash":"14c8c836bd10cf3e5250cd286e3fa446bcf29ca1","modified":1570624384116},{"_id":"public/archives/2016/index.html","hash":"bdbbf13da8ad666e1b98d29a6d337fc598201b21","modified":1570624384115},{"_id":"public/archives/2016/page/2/index.html","hash":"c5d8e353e606c921956fb4e375ad080a8f9073ee","modified":1570624384115},{"_id":"public/archives/2016/06/index.html","hash":"361189bb1da2ed820a52d3487b25960ad508934a","modified":1570624384116},{"_id":"public/archives/2016/page/3/index.html","hash":"f606cdfd8da15270995fcf4e45ef14bed184d207","modified":1570624384115},{"_id":"public/archives/2016/05/page/2/index.html","hash":"f11fa55c2cd352fa331fe09195518345e973dabd","modified":1570624384116},{"_id":"public/archives/2016/12/index.html","hash":"4ba8a1bb39c87080a27dd2f5cdf2e16b5085e7cc","modified":1570624384117},{"_id":"public/archives/2016/07/index.html","hash":"c9ed5a2f1048a2717fa499e3d8ad4dc8f790df8f","modified":1570624384116},{"_id":"public/archives/2017/index.html","hash":"9c07cb45cb0a9b503c293cb9c5091217fdedd913","modified":1570624384117},{"_id":"public/archives/2017/03/index.html","hash":"1d3e8f79bbf35f486c2d674d513ecd6de72c06f5","modified":1570624384117},{"_id":"public/archives/2017/page/2/index.html","hash":"365edf290d32ad6442025069a6e19a7726791589","modified":1570624384117},{"_id":"public/archives/2016/08/index.html","hash":"5848c90d462dc242ceaa5b0c3040d34e09a47cb8","modified":1570624384116},{"_id":"public/archives/2017/06/index.html","hash":"3492128f84cf01ef5830a72f78f95898cb06f2e3","modified":1570624384117},{"_id":"public/archives/2017/07/index.html","hash":"b0acd29aef39bc1371b7e518b8cb9b8d7fd7bb9b","modified":1570624384118},{"_id":"public/archives/2017/01/index.html","hash":"b66e6b85430c92babb92886aa879d6ce2664711f","modified":1570624384117},{"_id":"public/categories/HBase/index.html","hash":"5eb1c101dd8d41b50518fd08b6757e6b20bb823e","modified":1570624384112},{"_id":"public/categories/编写高质量代码/index.html","hash":"2cde545ad6a1541c4f617898141bcc94b3b6dc68","modified":1570624384112},{"_id":"public/categories/Java-Web/index.html","hash":"f9dff919c1ad3f5df4ebf168020a94b6691586c3","modified":1570624384112},{"_id":"public/categories/Redis设计与实现/index.html","hash":"a3186d8afb9045b76fe8591d9f92e9dccf6770c7","modified":1570624384112},{"_id":"public/categories/Java-Web/page/2/index.html","hash":"4ef965e10a8ab7787a50dc5ca72e98210b0ce758","modified":1570624384112},{"_id":"public/categories/Scala/index.html","hash":"b5f6ec8524dfdc101e06df75d547aea2c45f72b6","modified":1570624384112},{"_id":"public/categories/Redis设计与实现/page/2/index.html","hash":"12ec05983693b5a99614e3130f4455275bc275d1","modified":1570624384112},{"_id":"public/categories/Redis设计与实现/page/3/index.html","hash":"0d37761b8b09d8a4bb1f88664026b153f1ae4e76","modified":1570624384113},{"_id":"public/categories/Redis设计与实现/page/4/index.html","hash":"d70f55f0be901c1477a7445874926093a07092fe","modified":1570624384113},{"_id":"public/categories/深入理解Java虚拟机/index.html","hash":"a66a9a8985a60e7e6ef8f50d5fd87a92a552079a","modified":1570624384113},{"_id":"public/categories/SpringCloud/index.html","hash":"6cf029e9366ae0c540817925d246fde9f875ef9f","modified":1570624384113},{"_id":"public/index.html","hash":"33c9a654915d173350d2458288eb4438859d4fea","modified":1570624384123},{"_id":"public/page/2/index.html","hash":"999a090ee13d4b2007c7465e7fa0d9ff4f68b856","modified":1570624384123},{"_id":"public/page/4/index.html","hash":"b490296c18252183ee91805aaa88a25717d8d3ca","modified":1570624384123},{"_id":"public/page/6/index.html","hash":"2dda1432b5d26cc7c80ee3e8e88504e86c28fbf5","modified":1570624384124},{"_id":"public/page/7/index.html","hash":"55475f6a74a88e05a67e287a763a5bb332299efc","modified":1570624384124},{"_id":"public/page/5/index.html","hash":"8fd06dc4cc78b440e9eeb1479737d51a91002471","modified":1570624384124},{"_id":"public/page/3/index.html","hash":"deffbb2b64bcd6d6f027cc4905202d13cac7970a","modified":1570624384123},{"_id":"public/tags/DNS/index.html","hash":"d700bef4699c947913655e19d75d37bfcbcb86a8","modified":1570624384118},{"_id":"public/tags/Java/page/2/index.html","hash":"5c7cfa831f3ce50b2506bfa12f54ad803b2e4d91","modified":1570624384118},{"_id":"public/tags/Java8/index.html","hash":"caf644549337ec5ee440c088d3ac4948e9e3a3ce","modified":1570624384118},{"_id":"public/tags/HBase/index.html","hash":"0fd2b990254a441c650c82d4bd22c2f803318c6d","modified":1570624384118},{"_id":"public/tags/NIO/index.html","hash":"17ad95567b8bfeed2b295c794da8842a37b20bc7","modified":1570624384118},{"_id":"public/tags/Java/index.html","hash":"829932794d2496fe22d97e87520dcfbc963dffe8","modified":1570624384118},{"_id":"public/tags/JVM/index.html","hash":"f7288fa6b6c6d06f8dd0cf6d72a421a0b6489fdf","modified":1570624384119},{"_id":"public/tags/Scala/index.html","hash":"b17816ab5550dc4b4f776177362dfc73624d0a1a","modified":1570624384119},{"_id":"public/tags/Redis/index.html","hash":"7a0878d7d44e16873c725f58b2dfefcc80336318","modified":1570624384119},{"_id":"public/tags/Redis/page/2/index.html","hash":"de1caffd199708f3147adaf72e7d4df60f21a668","modified":1570624384119},{"_id":"public/tags/Redis/page/3/index.html","hash":"c211ae669943d065e96e6436b7ff51c96570ebaa","modified":1570624384119},{"_id":"public/tags/Redis/page/4/index.html","hash":"b118555b955e2c4e5c7d16bca4bf8dfd78c310a4","modified":1570624384119},{"_id":"public/tags/Java7/index.html","hash":"1e16e56de78ce5038650e3afc7fc5c36135ae5e1","modified":1570624384119},{"_id":"public/tags/Tomcat/index.html","hash":"59af741ceb7d9e51b331de6b1f7d14877be0fc90","modified":1570624384119},{"_id":"public/tags/IO/index.html","hash":"6da1bb160cfecd64e51f25ebf3d74f109e159054","modified":1570624384119},{"_id":"public/tags/Hystrix/index.html","hash":"fc375939d5b2e45882a4858275e53f293591a2f8","modified":1570624384120},{"_id":"public/tags/SpringCloud/index.html","hash":"a4c7f7f5117e4a480c2b4da576f635bac8f1f053","modified":1570624384120},{"_id":"public/2017/03/23/Java Web/可能错过的Java7特性/index.html","hash":"7f2ac02687a10868b830ce0aece7b2961aa49e86","modified":1570624384120},{"_id":"public/2016/12/19/Java Web/Java8新特性 -- StreamAPI/index.html","hash":"b319f17bedcd92bfca54806fb1a13713b6a00bbb","modified":1570624384120},{"_id":"public/2016/05/22/Java Web/Tomcat的系统架构/index.html","hash":"3ff71dce55ea18ecf457bd705a27e0e1a5c0d43a","modified":1570624384121},{"_id":"public/2016/12/13/Java Web/Java8新特性 -- 初识lambda/index.html","hash":"918ca060a3473971d08f4b62af5ac661e0fde615","modified":1570624384120},{"_id":"public/2016/05/28/Java Web/深入分析ClassLoader/index.html","hash":"d97f4ebc1b1b999c2e5c830bec1c9802867164e7","modified":1570624384121},{"_id":"public/2016/05/17/Java Web/深入分析IO工作机制/index.html","hash":"ee394bd643bc092e644faa26219fdeb79a08889c","modified":1570624384121},{"_id":"public/2016/05/18/Java Web/NIO的工作机制/index.html","hash":"730ca92c4ef2613d65869869b388f5e8749c649c","modified":1570624384121},{"_id":"public/2016/05/11/Java Web/DNS域名解析过程/index.html","hash":"cd99dd9d9f14df5f59cfb5301301badd923c98c1","modified":1570624384121},{"_id":"themes/next/.DS_Store","hash":"536b9be24701060abee0b38ae2882efe827e2f98","modified":1570623411963},{"_id":"themes/next/.bowerrc","hash":"3228a58ed0ece9f85e1e3136352094080b8dece1","modified":1553761277165},{"_id":"themes/next/.editorconfig","hash":"792fd2bd8174ece1a75d5fd24ab16594886f3a7f","modified":1473043093000},{"_id":"themes/next/.gitignore","hash":"0b5c2ffd41f66eb1849d6426ba8cf9649eeed329","modified":1553761277168},{"_id":"themes/next/.gitattributes","hash":"44bd4729c74ccb88110804f41746fec07bf487d4","modified":1553761277166},{"_id":"themes/next/.hound.yml","hash":"b76daa84c9ca3ad292c78412603370a367cc2bc3","modified":1473043093000},{"_id":"themes/next/.jshintrc","hash":"9928f81bd822f6a8d67fdbc909b517178533bca9","modified":1473043093000},{"_id":"themes/next/.stylintrc","hash":"b28e24704a5d8de08346c45286574c8e76cc109f","modified":1553761277169},{"_id":"themes/next/.travis.yml","hash":"d60d4a5375fea23d53b2156b764a99b2e56fa660","modified":1553761277169},{"_id":"themes/next/LICENSE","hash":"f293bcfcdc06c0b77ba13570bb8af55eb5c059fd","modified":1553761277170},{"_id":"themes/next/README.cn.md","hash":"263b74f1ac7c0f6f9424b8cced4b0b320ae61efc","modified":1553761277170},{"_id":"themes/next/README.md","hash":"287c7e6b7a6ddf75d815dda0df8bd228e3f285c5","modified":1553761277171},{"_id":"themes/next/bower.json","hash":"0674f11d3d514e087a176da0e1d85c2286aa5fba","modified":1553761277172},{"_id":"themes/next/gulpfile.coffee","hash":"031bffc483e417b20e90eceb6cf358e7596d2e69","modified":1553761277173},{"_id":"themes/next/_config.yml","hash":"5ff37e90e4d6812c8fc40c03fa6e1d903d743470","modified":1553761277171},{"_id":"themes/next/.javascript_ignore","hash":"8a224b381155f10e6eb132a4d815c5b52962a9d1","modified":1553761277168},{"_id":"themes/next/package.json","hash":"036d3a1346203d2f1a3958024df7f74e7ac07bfe","modified":1553761277206},{"_id":"themes/next/.git/FETCH_HEAD","hash":"96aadaf18803341ff9ed2cc25fc53d5456c0d61a","modified":1553763358751},{"_id":"themes/next/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1473043093000},{"_id":"themes/next/.git/ORIG_HEAD","hash":"3c959678e3fe6e51e935526c19927d21443a3be3","modified":1553763353517},{"_id":"themes/next/.git/config","hash":"a33539305f85ea695520b496f67659d5751acff8","modified":1473043093000},{"_id":"themes/next/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1473043067000},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"3b5eafd32abb718e56ccf8d1cee0607ad8ce611d","modified":1553761277166},{"_id":"themes/next/.git/packed-refs","hash":"fcadd7e7b2b757607f188af04f73ae344060087e","modified":1553763358718},{"_id":"themes/next/.git/index","hash":"97faa25a4a3df32381641242035cc5d75dc18c8e","modified":1553761280728},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"902f627155a65099e0a37842ff396a58d0dc306f","modified":1553761277167},{"_id":"themes/next/.github/browserstack_logo.png","hash":"a6c43887f64a7f48a2814e3714eaa1215e542037","modified":1553761277167},{"_id":"themes/next/.github/ISSUE_TEMPLATE.md","hash":"50d48c47162817a3810a9d9ad51104e83947419a","modified":1553761277166},{"_id":"themes/next/languages/de.yml","hash":"057e7df11ddeb1c8c15a5d7c5ff29430d725ec6b","modified":1553761277173},{"_id":"themes/next/languages/en.yml","hash":"7e680d9bb8f3a3a9d1ba1c9d312b3d257183dded","modified":1553761277175},{"_id":"themes/next/languages/fr-FR.yml","hash":"7e4eb7011b8feee641cfb11c6e73180b0ded1c0f","modified":1553761277175},{"_id":"themes/next/languages/id.yml","hash":"b5de1ea66dd9ef54cac9a1440eaa4e3f5fc011f5","modified":1553761277175},{"_id":"themes/next/languages/it.yml","hash":"aa595f2bda029f73ef7bfa104b4c55c3f4e9fb4c","modified":1553761277176},{"_id":"themes/next/languages/default.yml","hash":"44ef3f26917f467459326c2c8be2f73e4d947f35","modified":1553761277174},{"_id":"themes/next/languages/ja.yml","hash":"3c76e16fd19b262864475faa6854b718bc08c4d8","modified":1553761277176},{"_id":"themes/next/languages/ko.yml","hash":"ea5b46056e73ebcee121d5551627af35cbffc900","modified":1553761277176},{"_id":"themes/next/languages/nl-NL.yml","hash":"edca4f3598857dbc3cbf19ed412213329b6edd47","modified":1553761277176},{"_id":"themes/next/languages/pt-BR.yml","hash":"b1694ae766ed90277bcc4daca4b1cfa19cdcb72b","modified":1553761277177},{"_id":"themes/next/languages/pt.yml","hash":"44b61f2d085b827b507909a0b8f8ce31c6ef5d04","modified":1553761277178},{"_id":"themes/next/languages/ru.yml","hash":"98ec6f0b7183282e11cffc7ff586ceb82400dd75","modified":1553761277178},{"_id":"themes/next/languages/vi.yml","hash":"fd08d3c8d2c62965a98ac420fdaf95e54c25d97c","modified":1553761277178},{"_id":"themes/next/languages/zh-Hans.yml","hash":"16ef56d0dea94638de7d200984c90ae56f26b4fe","modified":1553761277179},{"_id":"themes/next/languages/zh-hk.yml","hash":"9396f41ae76e4fef99b257c93c7354e661f6e0fa","modified":1553761277179},{"_id":"themes/next/languages/zh-tw.yml","hash":"50b71abb3ecc0686f9739e179e2f829cd074ecd9","modified":1553761277179},{"_id":"themes/next/layout/archive.swig","hash":"f0a8225feafd971419837cdb4bcfec98a4a59b2f","modified":1553761277202},{"_id":"themes/next/layout/_layout.swig","hash":"da0929166674ea637e0ad454f85ad0d7bac4aff2","modified":1553761277180},{"_id":"themes/next/layout/category.swig","hash":"4472255f4a3e3dd6d79201523a9526dcabdfbf18","modified":1553761277203},{"_id":"themes/next/layout/index.swig","hash":"783611349c941848a0e26ee2f1dc44dd14879bd1","modified":1553761277203},{"_id":"themes/next/layout/page.swig","hash":"969caaee05bdea725e99016eb63d810893a73e99","modified":1553761277204},{"_id":"themes/next/layout/post.swig","hash":"b3589a8e46288a10d20e41c7a5985d2493725aec","modified":1553761277205},{"_id":"themes/next/layout/schedule.swig","hash":"d86f8de4e118f8c4d778b285c140474084a271db","modified":1553761277205},{"_id":"themes/next/layout/tag.swig","hash":"7e0a7d7d832883eddb1297483ad22c184e4368de","modified":1553761277206},{"_id":"themes/next/scripts/merge-configs.js","hash":"81e86717ecfb775986b945d17f0a4ba27532ef07","modified":1553761277207},{"_id":"themes/next/scripts/merge.js","hash":"9130dabe6a674c54b535f322b17d75fe6081472f","modified":1553761277207},{"_id":"themes/next/test/.jshintrc","hash":"19f93d13d1689fe033c82eb2d5f3ce30b6543cc0","modified":1473043093000},{"_id":"themes/next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1473043093000},{"_id":"themes/next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1473043093000},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1473043093000},{"_id":"themes/next/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1473043067000},{"_id":"themes/next/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1473043067000},{"_id":"themes/next/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1473043067000},{"_id":"themes/next/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1473043067000},{"_id":"themes/next/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1473043067000},{"_id":"themes/next/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1473043067000},{"_id":"themes/next/.git/hooks/pre-rebase.sample","hash":"5885a56ab4fca8075a05a562d005e922cde9853b","modified":1473043067000},{"_id":"themes/next/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1473043067000},{"_id":"themes/next/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1473043067000},{"_id":"themes/next/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1473043067000},{"_id":"themes/next/.git/logs/HEAD","hash":"4e7554688dd96eb9a81e3b6401eda34c8df22c29","modified":1553761277324},{"_id":"themes/next/layout/_custom/header.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1553761277180},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1553761277180},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"31322a7f57936cf2dc62e824af5490da5354cf02","modified":1553761277181},{"_id":"themes/next/layout/_macro/post-copyright.swig","hash":"665a928604f99d2ba7dc4a4a9150178229568cc6","modified":1553761277181},{"_id":"themes/next/layout/_macro/post.swig","hash":"446a35a2cd389f8cfc3aa38973a9b44ad0740134","modified":1553761277182},{"_id":"themes/next/layout/_macro/reward.swig","hash":"56e8d8556cf474c56ae1bef9cb7bbd26554adb07","modified":1553761277182},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"6a54c3c85ff6b19d275827a327abbf4bd99b2ebf","modified":1553761277183},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"39852700e4084ecccffa6d4669168e5cc0514c9e","modified":1553761277183},{"_id":"themes/next/layout/_partials/comments.swig","hash":"4a6f5b1792b2e5262b7fdab9a716b3108e2f09c7","modified":1553761277184},{"_id":"themes/next/layout/_partials/footer.swig","hash":"c4d6181f5d3db5365e622f78714af8cc58d7a45e","modified":1553761277185},{"_id":"themes/next/layout/_partials/head.swig","hash":"6b94fe8f3279daea5623c49ef4bb35917ba57510","modified":1553761277186},{"_id":"themes/next/layout/_partials/header.swig","hash":"ed042be6252848058c90109236ec988e392d91d4","modified":1553761277187},{"_id":"themes/next/layout/_partials/page-header.swig","hash":"1efd925d34a5d4ba2dc0838d9c86ba911e705fc9","modified":1553761277187},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"9e8e21d194ef44d271b1cca0bc1448c14d7edf4f","modified":1473043093000},{"_id":"themes/next/layout/_partials/search.swig","hash":"9dbd378e94abfcb3f864a5b8dbbf18d212ca2ee0","modified":1553761277188},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"03aaebe9d50f6acb007ec38cc04acd1cfceb404d","modified":1473043093000},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"766b2bdda29523ed6cd8d7aa197f996022f8fd94","modified":1473043093000},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"a266f96ad06ee87bdeae6e105a4b53cd587bbd04","modified":1553761277191},{"_id":"themes/next/layout/_third-party/exturl.swig","hash":"7c04a42319d728be356746363aff8ea247791d24","modified":1553761277198},{"_id":"themes/next/layout/_third-party/mathjax.swig","hash":"6d25596d6a7c57700d37b607f8d9a62d89708683","modified":1553761277198},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"fc93b1a7e6aed0dddb1f3910142b48d8ab61174e","modified":1553761277199},{"_id":"themes/next/layout/_third-party/schedule.swig","hash":"22369026c87fc23893c35a7f250b42f3bb1b60f1","modified":1553761277199},{"_id":"themes/next/layout/_third-party/duoshuo-hot-articles.swig","hash":"5d4638c46aef65bf32a01681495b62416ccc98db","modified":1553761277198},{"_id":"themes/next/layout/_third-party/needsharebutton.swig","hash":"5fe0447cc88a5a63b530cf0426f93c4634811876","modified":1553761277199},{"_id":"themes/next/layout/_third-party/scroll-cookie.swig","hash":"1ddb2336a1a19b47af3017047012c01ec5f54529","modified":1553761277199},{"_id":"themes/next/source/css/main.styl","hash":"20702c48d6053c92c5bcdbc68e8d0ef1369848a0","modified":1473043093000},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1473043093000},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1473043093000},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1473043093000},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1473043093000},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1473043093000},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1473043093000},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1473043093000},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1553761277243},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1553761277243},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1473043093000},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1553761277244},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1553761277244},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1473043093000},{"_id":"themes/next/source/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1553761277244},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1473043093000},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1473043093000},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1473043093000},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1473043093000},{"_id":"themes/next/scripts/tags/button.js","hash":"d023f10a00077f47082b0517e2ad666e6e994f60","modified":1553761277208},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"535fc542781021c4326dec24d8495cbb1387634a","modified":1473043093000},{"_id":"themes/next/scripts/tags/exturl.js","hash":"8d7e60f60779bde050d20fd76f6fdc36fc85e06d","modified":1553761277210},{"_id":"themes/next/scripts/tags/full-image.js","hash":"8eeb3fb89540299bdbb799edfdfdac3743b50596","modified":1553761277210},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"49252824cd53184dc9b97b2f2d87ff28e1b3ef27","modified":1473043093000},{"_id":"themes/next/scripts/tags/label.js","hash":"2f8f41a7316372f0d1ed6b51190dc4acd3e16fff","modified":1553761277211},{"_id":"themes/next/scripts/tags/lazy-image.js","hash":"eeeabede68cf263de9e6593ecf682f620da16f0a","modified":1553761277211},{"_id":"themes/next/scripts/tags/note.js","hash":"64de4e9d01cf3b491ffc7d53afdf148ee5ad9779","modified":1553761277211},{"_id":"themes/next/scripts/tags/tabs.js","hash":"5786545d51c38e8ca38d1bfc7dd9e946fc70a316","modified":1553761277212},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1473043093000},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1473043093000},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1473043093000},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1473043093000},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1473043093000},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1473043093000},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1473043093000},{"_id":"themes/next/.git/refs/tags/v5.1.0","hash":"7ec0539e56966d1eaf8b88c1d27165c1f7dfacf5","modified":1497460562000},{"_id":"themes/next/.git/refs/heads/master","hash":"3c959678e3fe6e51e935526c19927d21443a3be3","modified":1553761277323},{"_id":"themes/next/.git/refs/tags/v5.1.1","hash":"3caf2cc30e2bc17ce7c8decb48064104d4845453","modified":1497460562000},{"_id":"themes/next/.git/refs/tags/v5.1.2","hash":"75173e2dd18a6221ff84742ff53d01ac5c6e04b0","modified":1553760711700},{"_id":"themes/next/.git/refs/tags/v5.1.3","hash":"5eec1427a836e6e34c81dc784bafb33c2ccf48f9","modified":1553760711701},{"_id":"themes/next/.git/refs/tags/v5.1.4","hash":"66e8b5048a20ce41a8a240072e535d725d62aef4","modified":1553760711701},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"7ce76358411184482bb0934e70037949dd0da8ca","modified":1553761272095},{"_id":"themes/next/layout/_partials/head/custom-head.swig","hash":"9e1b9666efa77f4cf8d8261bcfa445a9ac608e53","modified":1553761277187},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"957701729b85fb0c5bfcf2fb99c19d54582f91ed","modified":1553761277189},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1473043093000},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1473043093000},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"23e23dc0f76ef3c631f24c65277adf7ea517b383","modified":1553761277189},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"1f1107468aaf03f7d0dcd7eb2b653e2813a675b4","modified":1553761277190},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1473043093000},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"069d1357c717572256e5cdee09574ebce529cbae","modified":1473043093000},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"048fd5e98149469f8c28c21ba3561a7a67952c9b","modified":1553761277190},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1553761277190},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1473043093000},{"_id":"themes/next/layout/_third-party/analytics/analytics-with-widget.swig","hash":"98df9d72e37dd071e882f2d5623c9d817815b139","modified":1553761277191},{"_id":"themes/next/layout/_third-party/analytics/application-insights.swig","hash":"60426bf73f8a89ba61fb1be2df3ad5398e32c4ef","modified":1553761277191},{"_id":"themes/next/layout/_third-party/analytics/cnzz-analytics.swig","hash":"8160b27bee0aa372c7dc7c8476c05bae57f58d0f","modified":1553761277192},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"deda6a814ed48debc694c4e0c466f06c127163d0","modified":1553761277192},{"_id":"themes/next/layout/_third-party/analytics/busuanzi-counter.swig","hash":"18e7bef8923d83ea42df6c97405e515a876cede4","modified":1553761277192},{"_id":"themes/next/layout/_third-party/analytics/facebook-sdk.swig","hash":"a234c5cd1f75ca5731e814d0dbb92fdcf9240d1b","modified":1553761277193},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"5d9943d74cc2e0a91badcf4f755c6de77eab193a","modified":1553761277193},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"5e9bb24c750b49513d9a65799e832f07410002ac","modified":1553761277194},{"_id":"themes/next/layout/_third-party/analytics/firestore.swig","hash":"1cd01c6e92ab1913d48e556a92bb4f28b6dc4996","modified":1553761277193},{"_id":"themes/next/layout/_third-party/analytics/lean-analytics.swig","hash":"fc65b9c98a0a8ab43a5e7aabff6c5f03838e09c8","modified":1553761277194},{"_id":"themes/next/layout/_third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1553761277194},{"_id":"themes/next/layout/_third-party/analytics/vkontakte-api.swig","hash":"c3971fd154d781088e1cc665035f8561a4098f4c","modified":1553761277195},{"_id":"themes/next/layout/_third-party/analytics/tencent-mta.swig","hash":"0ddc94ed4ba0c19627765fdf1abc4d8efbe53d5a","modified":1553761277194},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"0e3378f7c39b2b0f69638290873ede6b6b6825c0","modified":1553761277195},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"c316758546dc9ba6c60cb4d852c17ca6bb6d6724","modified":1553761277195},{"_id":"themes/next/layout/_third-party/comments/duoshuo.swig","hash":"a356b2185d40914447fde817eb3d358ab6b3e4c3","modified":1553761277196},{"_id":"themes/next/layout/_third-party/comments/hypercomments.swig","hash":"3e8dc5c6c912628a37e3b5f886bec7b2e5ed14ea","modified":1553761277196},{"_id":"themes/next/layout/_third-party/comments/gitment.swig","hash":"10160daceaa6f1ecf632323d422ebe2caae49ddf","modified":1553761277196},{"_id":"themes/next/layout/_third-party/comments/index.swig","hash":"aa0629277d751c55c6d973e7691bf84af9b17a60","modified":1553761277197},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"8a2e393d2e49f7bf560766d8a07cd461bf3fce4f","modified":1553761277197},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"fcabbb241f894c9a6309c44e126cf3e8fea81fd4","modified":1553761277197},{"_id":"themes/next/layout/_third-party/comments/youyan.swig","hash":"8b6650f77fe0a824c8075b2659e0403e0c78a705","modified":1553761277197},{"_id":"themes/next/layout/_third-party/search/index.swig","hash":"c747fb5c6b1f500e8f0c583e44195878b66e4e29","modified":1553761277200},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"385c066af96bee30be2459dbec8aae1f15d382f5","modified":1553761277201},{"_id":"themes/next/layout/_third-party/search/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1553761277201},{"_id":"themes/next/layout/_third-party/seo/baidu-push.swig","hash":"c057b17f79e8261680fbae8dc4e81317a127c799","modified":1553761277201},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"328d9a9696cc2ccf59c67d3c26000d569f46344c","modified":1473043093000},{"_id":"themes/next/source/css/_mixins/Gemini.styl","hash":"2aa5b7166a85a8aa34b17792ae4f58a5a96df6cc","modified":1553761277234},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"9ab65361ba0a12a986edd103e56492644c2db0b8","modified":1553761277234},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"82f9055955920ed88a2ab6a20ab02169abb2c634","modified":1553761277235},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"99fbb4686ea9a3e03a4726ed7cf4d8f529034452","modified":1553761277241},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"be087dcc060e8179f7e7f60ab4feb65817bd3d9f","modified":1553761277242},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"f29165e36489a87ba32d17dddfd2720d84e3f3ec","modified":1553761277242},{"_id":"themes/next/source/css/_variables/base.styl","hash":"29c261fa6b4046322559074d75239c6b272fb8a3","modified":1553761277243},{"_id":"themes/next/source/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1473043093000},{"_id":"themes/next/source/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1553761277245},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"034bc8113e0966fe2096ba5b56061bbf10ef0512","modified":1553761277245},{"_id":"themes/next/source/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1553761277246},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1473043093000},{"_id":"themes/next/source/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1553761277246},{"_id":"themes/next/source/js/src/post-details.js","hash":"a13f45f7aa8291cf7244ec5ba93907d119c5dbdd","modified":1553761277247},{"_id":"themes/next/source/js/src/motion.js","hash":"754b294394f102c8fd9423a1789ddb1201677898","modified":1553761277246},{"_id":"themes/next/source/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1553761277248},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1473043093000},{"_id":"themes/next/source/js/src/utils.js","hash":"9b1325801d27213083d1487a12b1a62b539ab6f8","modified":1553761277248},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1553761277255},{"_id":"themes/next/source/lib/fancybox/.bower.json","hash":"cc40a9b11e52348e554c84e4a5c058056f6b7aeb","modified":1553761277260},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1553761277260},{"_id":"themes/next/source/lib/fancybox/.gitattributes","hash":"2db21acfbd457452462f71cc4048a943ee61b8e0","modified":1553761277261},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","hash":"ff5915eb2596e890a2fc6697c864f861a1995ec0","modified":1553761277260},{"_id":"themes/next/source/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1553761277267},{"_id":"themes/next/source/lib/fastclick/.bower.json","hash":"93ebd5b35e632f714dcf1753e1f6db77ec74449b","modified":1553761277267},{"_id":"themes/next/source/lib/fastclick/bower.json","hash":"13379463c7463b4b96d13556b46faa4cc38d81e6","modified":1553761277268},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"a2aaaf12378db56bd10596ba3daae30950eac051","modified":1553761277270},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1553761277270},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1553761277270},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1553761277271},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1553761277271},{"_id":"themes/next/source/lib/jquery_lazyload/.bower.json","hash":"b7638afc93e9cd350d0783565ee9a7da6805ad8e","modified":1553761277298},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","hash":"4891864c24c28efecd81a6a8d3f261145190f901","modified":1553761277298},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","hash":"895d50fa29759af7835256522e9dd7dac597765c","modified":1553761277298},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","hash":"65bc85d12197e71c40a55c0cd7f6823995a05222","modified":1553761277299},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1553761277299},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1553761277299},{"_id":"themes/next/source/lib/jquery/.bower.json","hash":"91745c2cc6c946c7275f952b2b0760b880cea69e","modified":1553761277296},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","hash":"c39d37278c1e178838732af21bd26cd0baeddfe0","modified":1553761277301},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","hash":"9885fd9bea5e7ebafc5b1de9d17be5e106248d96","modified":1553761277301},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","hash":"3ef0020a1815ca6151ea4886cd0d37421ae3695c","modified":1553761277301},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1553761277302},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1553761277302},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1553761277303},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1553761277303},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1553761277303},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1553761277304},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1553761277304},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1553761277304},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1553761277304},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1553761277305},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1553761277305},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1553761277306},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1553761277306},{"_id":"themes/next/source/lib/pace/pace.min.js","hash":"9944dfb7814b911090e96446cea4d36e2b487234","modified":1553761277306},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","hash":"dce4a3b65f8bf958f973690caa7ec4952f353b0c","modified":1553761277307},{"_id":"themes/next/source/lib/velocity/.bower.json","hash":"05f960846f1c7a93dab1d3f9a1121e86812e8c88","modified":1553761277315},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","hash":"d8ea241a53c135a650f7335d2b6982b899fd58a9","modified":1553761277308},{"_id":"themes/next/source/lib/velocity/bower.json","hash":"2ec99573e84c7117368beccb9e94b6bf35d2db03","modified":1553761277316},{"_id":"themes/next/source/lib/three/three-waves.min.js","hash":"d968cba6b3a50b3626a02d67b544f349d83b147c","modified":1553761277308},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1553761277319},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1553761277320},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1553761277320},{"_id":"themes/next/.git/objects/pack/pack-488bb87d2cdc3e43b744bb772c7a3406ba58deb8.idx","hash":"494c2fbbf525796c46245d124bc8d31270583abe","modified":1497460561000},{"_id":"themes/next/.git/objects/pack/pack-0f6fca9f0497046afb6882e4deb14c70fef669de.idx","hash":"d8806b2e99be89f30e30ac70727cd90f91b8f7f8","modified":1553760711304},{"_id":"themes/next/source/lib/fastclick/README.md","hash":"1decd8e1adad2cd6db0ab50cf56de6035156f4ea","modified":1553761277268},{"_id":"themes/next/source/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1553761277297},{"_id":"themes/next/.git/objects/pack/pack-86fef626de1eb962abc5ba6bb6a3172ba82e6ec3.idx","hash":"df3e80c427ffb662152d057bc39d5e53ad3f3ffe","modified":1473043091000},{"_id":"themes/next/.git/logs/refs/heads/master","hash":"a31c9b35a7420c1ab3296277fe38190b99372d3a","modified":1553761277326},{"_id":"themes/next/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1473043093000},{"_id":"themes/next/.git/refs/remotes/origin/dev","hash":"c9abcffd1f03a6a76afa09334100c5003cf895a0","modified":1553760711673},{"_id":"themes/next/.git/refs/remotes/origin/master","hash":"3c959678e3fe6e51e935526c19927d21443a3be3","modified":1553760711671},{"_id":"themes/next/.git/refs/remotes/origin/servant","hash":"ee903ee2112907f4498fdb13674a640c685e95fb","modified":1497460562000},{"_id":"themes/next/.git/refs/remotes/origin/testing","hash":"15660a56eaab85fc3fd3324de8d61dbc2b09b42a","modified":1497460562000},{"_id":"themes/next/layout/_third-party/search/algolia-search/assets.swig","hash":"28ff4ed6714c59124569ffcbd10f1173d53ca923","modified":1553761277200},{"_id":"themes/next/layout/_third-party/search/algolia-search/dom.swig","hash":"ba698f49dd3a868c95b240d802f5b1b24ff287e4","modified":1553761277200},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"4719ce717962663c5c33ef97b1119a0b3a4ecdc3","modified":1553761277212},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"31050fc7a25784805b4843550151c93bfa55c9c8","modified":1553761277212},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"a6bb5256be6195e76addbda12f4ed7c662d65e7a","modified":1553761277213},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"7e509c7c28c59f905b847304dd3d14d94b6f3b8e","modified":1553761277213},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1473043093000},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1473043093000},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"c5d48863f332ff8ce7c88dec2c893f709d7331d3","modified":1553761277218},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"2186be20e317505cd31886f1291429cc21f76703","modified":1473043093000},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"f7c44b0ee46cf2cf82a4c9455ba8d8b55299976f","modified":1553761277232},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"9c25c75311e1bd4d68df031d3f2ae6d141a90766","modified":1553761277232},{"_id":"themes/next/source/css/_common/scaffolding/mobile.styl","hash":"47a46583a1f3731157a3f53f80ed1ed5e2753e8e","modified":1553761277232},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1473043093000},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"a280a583b7615e939aaddbf778f5c108ef8a2a6c","modified":1553761277233},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"64f5d56c08d74a338813df1265580ca0cbf0190b","modified":1473043093000},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"18c3336ee3d09bd2da6a876e1336539f03d5a973","modified":1553761277236},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"c2d079788d6fc2e9a191ccdae94e50d55bf849dc","modified":1473043093000},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"5ae7906dc7c1d9468c7f4b4a6feddddc555797a1","modified":1473043093000},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1473043093000},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"b0dcca862cd0cc6e732e33d975b476d744911742","modified":1473043093000},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"3b25edfa187d1bbbd0d38b50dd013cef54758abf","modified":1553761277236},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1473043093000},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"9a5581a770af8964064fef7afd3e16963e45547f","modified":1473043093000},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"0efa036a15c18f5abb058b7c0fad1dd9ac5eed4c","modified":1553761277237},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"4aac01962520d60b03b23022ab601ad4bd19c08c","modified":1553761277238},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1473043093000},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1473043093000},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"a0e2030a606c934fb2c5c7373aaae04a1caac4c5","modified":1473043093000},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"c4ed249798296f60bda02351fe6404fb3ef2126f","modified":1553761277239},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"5b93958239d3d2bf9aeaede44eced2434d784462","modified":1553761277239},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"215de948be49bcf14f06d500cef9f7035e406a43","modified":1553761277240},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1473043093000},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"9d16fa3c14ed76b71229f022b63a02fd0f580958","modified":1553761277240},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"69ecd6c97e7cdfd822ac8102b45ad0ede85050db","modified":1553761277241},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"8050a5b2683d1d77238c5762b6bd89c543daed6e","modified":1553761277247},{"_id":"themes/next/source/lib/Han/dist/han.css","hash":"bd40da3fba8735df5850956814e312bd7b3193d7","modified":1553761277252},{"_id":"themes/next/source/lib/Han/dist/han.min.js","hash":"f559c68a25065a14f47da954a7617d87263e409d","modified":1553761277254},{"_id":"themes/next/source/lib/Han/dist/han.min.css","hash":"a0c9e32549a8b8cf327ab9227b037f323cdb60ee","modified":1553761277253},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1553761277261},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1553761277261},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1553761277262},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1553761277262},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1553761277262},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1553761277263},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1553761277265},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1553761277266},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1553761277267},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1553761277270},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1553761277269},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1553761277272},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1553761277274},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1553761277278},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1553761277315},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1553761277315},{"_id":"themes/next/source/lib/Han/dist/han.js","hash":"e345397e0585c9fed1449e614ec13e0224acf2ab","modified":1553761277253},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1553761277295},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1553761277294},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1553761277318},{"_id":"themes/next/.git/logs/refs/remotes/origin/HEAD","hash":"0d569db4f79bdd5c38e6f0b7015b051072401dad","modified":1473043093000},{"_id":"themes/next/.git/logs/refs/remotes/origin/master","hash":"b9aedd7e3bcc2afe6547fe4e3e709e35eacf21da","modified":1553760711672},{"_id":"themes/next/.git/logs/refs/remotes/origin/testing","hash":"35dd8921a8745c4f2cd4e931ddc0998ac240a3ae","modified":1497460562000},{"_id":"themes/next/.git/logs/refs/remotes/origin/servant","hash":"1d7fad266115aaf441f0f4962fb698287b4a7137","modified":1497460562000},{"_id":"themes/next/.git/logs/refs/remotes/origin/dev","hash":"e65891191d6ef3ed581f3ce72e94bc43a7a21584","modified":1553760711674},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"7905a7f625702b45645d8be1268cb8af3f698c70","modified":1553761277214},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"96f32ea6c3265a3889e6abe57587f6e2a2a40dfb","modified":1553761277215},{"_id":"themes/next/source/css/_common/components/post/post-button.styl","hash":"e72a89e0f421444453e149ba32c77a64bd8e44e8","modified":1553761277219},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"b76387934fb6bb75212b23c1a194486892cc495e","modified":1553761277216},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"25dc25f61a232f03ca72472b7852f882448ec185","modified":1553761277215},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"0f7f522cc6bfb3401d5afd62b0fcdf48bb2d604b","modified":1553761277219},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"f54367c0feda6986c030cc4d15a0ca6ceea14bcb","modified":1553761277219},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"535b3b4f8cb1eec2558e094320e7dfb01f94c0e7","modified":1553761277220},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1473043093000},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1473043093000},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"aea21141015ca8c409d8b33e3e34ec505f464e93","modified":1553761277220},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"36332c8a91f089f545f3c3e8ea90d08aa4d6e60c","modified":1553761277222},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"a5d8617a24d7cb6c5ad91ea621183ca2c0917331","modified":1553761277221},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1473043093000},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"017074ef58166e2d69c53bb7590a0e7a8947a1ed","modified":1553761277222},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1473043093000},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"d5a4e4fc17f1f7e7c3a61b52d8e2e9677e139de7","modified":1553761277222},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"e4055a0d2cd2b0ad9dc55928e2f3e7bd4e499da3","modified":1553761277222},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"262debfd4442fa03d9919ceb88b948339df03fb0","modified":1553761277223},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"ae1ca14e51de67b07dba8f61ec79ee0e2e344574","modified":1473043093000},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1473043093000},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"8a2421cb9005352905fae9d41a847ae56957247e","modified":1553761277214},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"6c00f6e0978f4d8f9a846a15579963728aaa6a17","modified":1473043093000},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1473043093000},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"f5aa2ba3bfffc15475e7e72a55b5c9d18609fdf5","modified":1553761277216},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1473043093000},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"2039590632bba3943c39319d80ef630af7928185","modified":1553761277217},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1473043093000},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"a82afbb72d83ee394aedc7b37ac0008a9823b4f4","modified":1553761277218},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"0a6c0efffdf18bddbc1d1238feaed282b09cd0fe","modified":1553761277223},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"920343e41c124221a17f050bbb989494d44f7a24","modified":1473043093000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"89dd4f8b1f1cce3ad46cf2256038472712387d02","modified":1553761277224},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-dimmer.styl","hash":"efa5e5022e205b52786ce495d4879f5e7b8f84b2","modified":1553761277224},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1473043093000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1473043093000},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"3623e7fa4324ec1307370f33d8f287a9e20a5578","modified":1473043093000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"12937cae17c96c74d5c58db6cb29de3b2dfa14a2","modified":1553761277225},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"50305b6ad7d09d2ffa4854e39f41ec1f4fe984fd","modified":1553761277226},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"f7784aba0c1cd20d824c918c120012d57a5eaa2a","modified":1553761277225},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1473043093000},{"_id":"themes/next/source/css/_common/components/tags/exturl.styl","hash":"1b3cc9f4e5a7f6e05b4100e9990b37b20d4a2005","modified":1553761277226},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"37e951e734a252fe8a81f452b963df2ba90bfe90","modified":1553761277227},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1473043093000},{"_id":"themes/next/source/css/_common/components/tags/note-modern.styl","hash":"ee7528900578ef4753effe05b346381c40de5499","modified":1553761277227},{"_id":"themes/next/source/css/_common/components/tags/label.styl","hash":"4a457d265d62f287c63d48764ce45d9bcfc9ec5a","modified":1553761277227},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"32c9156bea5bac9e9ad0b4c08ffbca8b3d9aac4b","modified":1553761277228},{"_id":"themes/next/source/css/_common/components/tags/tabs.styl","hash":"4ab5deed8c3b0c338212380f678f8382672e1bcb","modified":1553761277228},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"fd42777b9125fd8969dc39d4f15473e2b91b4142","modified":1553761277229},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"93b08815c4d17e2b96fef8530ec1f1064dede6ef","modified":1473043093000},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"ead0d0f2321dc71505788c7f689f92257cf14947","modified":1553761277228},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"d4e6d8d7b34dc69994593c208f875ae8f7e8a3ae","modified":1553761277229},{"_id":"themes/next/source/css/_common/components/third-party/gitment.styl","hash":"34935b40237c074be5f5e8818c14ccfd802b7439","modified":1553761277229},{"_id":"themes/next/source/css/_common/components/third-party/han.styl","hash":"cce6772e2cdb4db85d35486ae4c6c59367fbdd40","modified":1553761277229},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"2340dd9b3202c61d73cc708b790fac5adddbfc7f","modified":1473043093000},{"_id":"themes/next/source/css/_common/components/third-party/needsharebutton.styl","hash":"a5e3e6b4b4b814a9fe40b34d784fed67d6d977fa","modified":1553761277230},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"327b5f63d55ec26f7663185c1a778440588d9803","modified":1473043093000},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"d89c4b562b528e4746696b2ad8935764d133bdae","modified":1553761277230},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"1ccfbd4d0f5754b2dc2719a91245c95f547a7652","modified":1553761277231},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1473043093000},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1553761277237},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1553761277238},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1553761277250},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1553761277250},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1553761277251},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","hash":"623af3ed5423371ac136a4fe0e8cc7bb7396037a","modified":1553761277251},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1553761277251},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1553761277263},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1553761277263},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1553761277264},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1553761277264},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1553761277264},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1553761277265},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1553761277282},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1553761277293},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1553761277286},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1553761277259},{"_id":"themes/next/source/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1553761277314},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1553761277291},{"_id":"themes/next/.git/objects/pack/pack-0f6fca9f0497046afb6882e4deb14c70fef669de.pack","hash":"5c3d03035a3acc200ffd2aeb3fec9015977ee943","modified":1553760711301},{"_id":"themes/next/.git/objects/pack/pack-488bb87d2cdc3e43b744bb772c7a3406ba58deb8.pack","hash":"0f07c8a9a886cbd92edcd5707ac20540d2080434","modified":1497460561000},{"_id":"themes/next/.git/objects/pack/pack-86fef626de1eb962abc5ba6bb6a3172ba82e6ec3.pack","hash":"8b28a22776ffc0e6313769e8f2cc855633f4de03","modified":1473043091000},{"_id":"public/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1570623478033},{"_id":"public/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1570623478033},{"_id":"public/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1570623478033},{"_id":"public/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1570623478034},{"_id":"public/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1570623478034},{"_id":"public/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1570623478034},{"_id":"public/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1570623478034},{"_id":"public/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1570623478034},{"_id":"public/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1570623478034},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1570623478034},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1570623478034},{"_id":"public/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1570623478034},{"_id":"public/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1570623478035},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1570623478035},{"_id":"public/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1570623478035},{"_id":"public/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1570623478035},{"_id":"public/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1570623478036},{"_id":"public/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1570623478036},{"_id":"public/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1570623478036},{"_id":"public/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1570623478036},{"_id":"public/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1570623478036},{"_id":"public/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1570623478036},{"_id":"public/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1570623478036},{"_id":"public/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1570623478036},{"_id":"public/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1570623478036},{"_id":"public/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1570623478037},{"_id":"public/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1570623478037},{"_id":"public/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1570623478037},{"_id":"public/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1570623478037},{"_id":"public/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1570623478037},{"_id":"public/lib/Han/dist/font/han.woff2","hash":"623af3ed5423371ac136a4fe0e8cc7bb7396037a","modified":1570623478037},{"_id":"public/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1570623478037},{"_id":"public/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1570623478037},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1570623478674},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1570623478674},{"_id":"public/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1570623478678},{"_id":"public/js/src/bootstrap.js","hash":"034bc8113e0966fe2096ba5b56061bbf10ef0512","modified":1570623478678},{"_id":"public/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1570623478678},{"_id":"public/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1570623478678},{"_id":"public/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1570623478679},{"_id":"public/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1570623478679},{"_id":"public/js/src/post-details.js","hash":"a13f45f7aa8291cf7244ec5ba93907d119c5dbdd","modified":1570623478679},{"_id":"public/js/src/motion.js","hash":"754b294394f102c8fd9423a1789ddb1201677898","modified":1570623478679},{"_id":"public/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1570623478679},{"_id":"public/js/src/utils.js","hash":"9b1325801d27213083d1487a12b1a62b539ab6f8","modified":1570623478679},{"_id":"public/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1570623478680},{"_id":"public/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1570623478680},{"_id":"public/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1570623478680},{"_id":"public/lib/canvas-ribbon/canvas-ribbon.js","hash":"ff5915eb2596e890a2fc6697c864f861a1995ec0","modified":1570623478680},{"_id":"public/lib/fastclick/bower.json","hash":"4dcecf83afddba148464d5339c93f6d0aa9f42e9","modified":1570623478680},{"_id":"public/lib/font-awesome/bower.json","hash":"64394a2a9aa00f8e321d8daa5e51a420f0e96dad","modified":1570623478680},{"_id":"public/lib/jquery_lazyload/bower.json","hash":"ae3c3b61e6e7f9e1d7e3585ad854380ecc04cf53","modified":1570623478681},{"_id":"public/lib/jquery_lazyload/README.html","hash":"bde24335f6bc09d8801c0dcd7274f71b466552bd","modified":1570623478681},{"_id":"public/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1570623478681},{"_id":"public/lib/jquery_lazyload/CONTRIBUTING.html","hash":"a6358170d346af13b1452ac157b60505bec7015c","modified":1570623478681},{"_id":"public/lib/needsharebutton/needsharebutton.css","hash":"3ef0020a1815ca6151ea4886cd0d37421ae3695c","modified":1570623478681},{"_id":"public/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1570623478681},{"_id":"public/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1570623478682},{"_id":"public/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1570623478682},{"_id":"public/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1570623478682},{"_id":"public/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1570623478682},{"_id":"public/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1570623478682},{"_id":"public/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1570623478682},{"_id":"public/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1570623478683},{"_id":"public/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1570623478683},{"_id":"public/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1570623478683},{"_id":"public/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1570623478683},{"_id":"public/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1570623478683},{"_id":"public/lib/pace/pace.min.js","hash":"9944dfb7814b911090e96446cea4d36e2b487234","modified":1570623478683},{"_id":"public/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1570623478683},{"_id":"public/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1570623478683},{"_id":"public/lib/velocity/bower.json","hash":"0ef14e7ccdfba5db6eb3f8fc6aa3b47282c36409","modified":1570623478683},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1570623478683},{"_id":"public/lib/fastclick/README.html","hash":"da3c74d484c73cc7df565e8abbfa4d6a5a18d4da","modified":1570623478684},{"_id":"public/js/src/schemes/pisces.js","hash":"8050a5b2683d1d77238c5762b6bd89c543daed6e","modified":1570623478684},{"_id":"public/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1570623478684},{"_id":"public/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1570623478684},{"_id":"public/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1570623478684},{"_id":"public/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1570623478684},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1570623478684},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1570623478684},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1570623478685},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1570623478685},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1570623478685},{"_id":"public/css/main.css","hash":"1c677c90b70b9533a1cce330792cc9ed6242223f","modified":1570623478685},{"_id":"public/lib/needsharebutton/needsharebutton.js","hash":"9885fd9bea5e7ebafc5b1de9d17be5e106248d96","modified":1570623478685},{"_id":"public/lib/needsharebutton/font-embedded.css","hash":"c39d37278c1e178838732af21bd26cd0baeddfe0","modified":1570623478685},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1570623478685},{"_id":"public/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1570623478685},{"_id":"public/lib/three/canvas_lines.min.js","hash":"dce4a3b65f8bf958f973690caa7ec4952f353b0c","modified":1570623478685},{"_id":"public/lib/three/canvas_sphere.min.js","hash":"d8ea241a53c135a650f7335d2b6982b899fd58a9","modified":1570623478686},{"_id":"public/lib/three/three-waves.min.js","hash":"d968cba6b3a50b3626a02d67b544f349d83b147c","modified":1570623478686},{"_id":"public/lib/Han/dist/han.css","hash":"bd40da3fba8735df5850956814e312bd7b3193d7","modified":1570623478686},{"_id":"public/lib/Han/dist/han.min.css","hash":"a0c9e32549a8b8cf327ab9227b037f323cdb60ee","modified":1570623478686},{"_id":"public/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1570623478686},{"_id":"public/lib/Han/dist/han.min.js","hash":"f559c68a25065a14f47da954a7617d87263e409d","modified":1570623478686},{"_id":"public/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1570623478687},{"_id":"public/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1570623478687},{"_id":"public/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1570623478687},{"_id":"public/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1570623478688},{"_id":"public/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1570623478688},{"_id":"public/lib/Han/dist/han.js","hash":"e345397e0585c9fed1449e614ec13e0224acf2ab","modified":1570623478688},{"_id":"public/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1570623478689},{"_id":"public/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1570623478689},{"_id":"public/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1570623478689},{"_id":"public/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1570623478690},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1570623478691},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1570623478691},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1570623478776},{"_id":"source/images/Wechat.jpeg","hash":"9a6c6b1fc84c095fd4c209fc5676df4e5b796f00","modified":1538200889000},{"_id":"public/images/Wechat.jpeg","hash":"9a6c6b1fc84c095fd4c209fc5676df4e5b796f00","modified":1570624384126}],"Category":[{"name":"Java","_id":"ck1j8f2g700057h9meigri77v"},{"name":"Java Web","_id":"ck1j8f2ga00077h9mfyeacnmm"},{"name":"编写高质量代码","_id":"ck1j8f2gb00097h9mlasjz8dt"},{"name":"HBase","_id":"ck1j8f2io001d7h9mjvt8860y"},{"name":"Scala","_id":"ck1j8f2iq001n7h9m24wdhi3p"},{"name":"Redis设计与实现","_id":"ck1j8f2it001u7h9mqpt2wc9a"},{"name":"深入理解Java虚拟机","_id":"ck1j8f2jb002s7h9mwk3dant9"},{"name":"SpringCloud","_id":"ck1j8f2jr00337h9m19frd0ya"}],"Data":[],"Page":[{"title":"categories","date":"2016-09-05T03:43:00.000Z","type":"categories","comments":0,"_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2016-09-05 11:43:00\ntype: \"categories\"\ncomments: false\n---\n","updated":"2019-05-17T05:57:58.589Z","path":"categories/index.html","layout":"page","_id":"ck1j8f2fj00007h9mvpzpj3n9","content":"","excerpt":"","more":""},{"title":"tags","date":"2016-09-05T03:42:28.000Z","type":"tags","comments":0,"_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2016-09-05 11:42:28\ntype: \"tags\"\ncomments: false\n---\n","updated":"2016-09-05T03:44:23.000Z","path":"tags/index.html","layout":"page","_id":"ck1j8f2g400047h9mda84qvc5","content":"","excerpt":"","more":""}],"Post":[{"title":"Elasticsearch基础","date":"2016-07-14T16:00:00.000Z","_content":"\n##\tElasticsearch 功能特性\n\n\n\n","source":"_drafts/ElasticsearchJavaAPI.md","raw":"---\ntitle: Elasticsearch基础\ndate: 2016-07-15\ncategories: Java \ntags: \n- Java\n- Elasticsearch\n---\n\n##\tElasticsearch 功能特性\n\n\n\n","slug":"ElasticsearchJavaAPI","published":0,"updated":"2019-05-17T05:57:58.546Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1j8f2fq00017h9m3z6m1x2m","content":"<h2 id=\"Elasticsearch-功能特性\"><a href=\"#Elasticsearch-功能特性\" class=\"headerlink\" title=\"Elasticsearch 功能特性\"></a>Elasticsearch 功能特性</h2>","excerpt":"","more":"<h2 id=\"Elasticsearch-功能特性\"><a href=\"#Elasticsearch-功能特性\" class=\"headerlink\" title=\"Elasticsearch 功能特性\"></a>Elasticsearch 功能特性</h2>"},{"title":"Servlet工作原理分析","date":"2016-05-21T16:00:00.000Z","_content":"\n#\tTomcat中的Servlet容器\n在Tomcat容器等级中，Context容器直接管理Servlet容器中的包装类Wrapper，所以Context容器如何运行将直接影响Servlet的工作方式。\nTomcat容器模型：  \n1.\tContainer容器  \n2. \tEngine  \n3. \tHost  \n4. \tServlet容器\t\n5. Context\t\n\nTomcat容器分为4个等级，管理Servlet的容器是Context容器，一个Context对应一个Web工程。\n\n#\tServlet容器启动\nTomcat7开始支持嵌入式功能，增加了一个启动类org.apache.catalina.startup.Tomcat。创建一个实例对象并调用start方法就可以很容易地启动Tomcat。\n\n```\n public Context addWebapp(Host host, String url, String name, String path) {\n        silence(host, url);\n\n        Context ctx = new StandardContext();\n        ctx.setName(name);\n        ctx.setPath(url);\n        ctx.setDocBase(path);\n\n        ctx.addLifecycleListener(new DefaultWebXmlListener());\n        \n        ContextConfig ctxCfg = new ContextConfig();\n        ctx.addLifecycleListener(ctxCfg);\n        \n        // prevent it from looking ( if it finds one - it'll have dup error )\n        ctxCfg.setDefaultWebXml(noDefaultWebXmlPath());\n\n        if (host == null) {\n            getHost().addChild(ctx);\n        } else {\n            host.addChild(ctx);\n        }\n\n        return ctx;\n    }\n```\n\n一个Web应用对应一个Context容器，也就是Servlet运行时的Servlet容器。添加一个Web应用时将会创建一个StandardContext容器，并给这个容器设置必要的参数，url和path分别代表这个应用在Tomcat中的访问路径和这个应用实际的物理路径。\n\n```\npublic void start() throws LifecycleException {\n    getServer();\n    getConnector();\n    server.start();\n}\n```\n\n调用Tomcat的start方法启动Tomcat。Tomcat启动逻辑基于观察者模式设计，所有容器都会继承LifeCycle接口，它管理着容器的整个生命周期，所有容器的修改和状态的改变都会由它去通知已经注册的观察者（Listener）。\n\n\n","source":"_drafts/Servlet工作原理分析.md","raw":"---\ntitle: Servlet工作原理分析\ndate: 2016-05-22\ncategories: Java Web\ntags: \n- Java\n- Servlet\n---\n\n#\tTomcat中的Servlet容器\n在Tomcat容器等级中，Context容器直接管理Servlet容器中的包装类Wrapper，所以Context容器如何运行将直接影响Servlet的工作方式。\nTomcat容器模型：  \n1.\tContainer容器  \n2. \tEngine  \n3. \tHost  \n4. \tServlet容器\t\n5. Context\t\n\nTomcat容器分为4个等级，管理Servlet的容器是Context容器，一个Context对应一个Web工程。\n\n#\tServlet容器启动\nTomcat7开始支持嵌入式功能，增加了一个启动类org.apache.catalina.startup.Tomcat。创建一个实例对象并调用start方法就可以很容易地启动Tomcat。\n\n```\n public Context addWebapp(Host host, String url, String name, String path) {\n        silence(host, url);\n\n        Context ctx = new StandardContext();\n        ctx.setName(name);\n        ctx.setPath(url);\n        ctx.setDocBase(path);\n\n        ctx.addLifecycleListener(new DefaultWebXmlListener());\n        \n        ContextConfig ctxCfg = new ContextConfig();\n        ctx.addLifecycleListener(ctxCfg);\n        \n        // prevent it from looking ( if it finds one - it'll have dup error )\n        ctxCfg.setDefaultWebXml(noDefaultWebXmlPath());\n\n        if (host == null) {\n            getHost().addChild(ctx);\n        } else {\n            host.addChild(ctx);\n        }\n\n        return ctx;\n    }\n```\n\n一个Web应用对应一个Context容器，也就是Servlet运行时的Servlet容器。添加一个Web应用时将会创建一个StandardContext容器，并给这个容器设置必要的参数，url和path分别代表这个应用在Tomcat中的访问路径和这个应用实际的物理路径。\n\n```\npublic void start() throws LifecycleException {\n    getServer();\n    getConnector();\n    server.start();\n}\n```\n\n调用Tomcat的start方法启动Tomcat。Tomcat启动逻辑基于观察者模式设计，所有容器都会继承LifeCycle接口，它管理着容器的整个生命周期，所有容器的修改和状态的改变都会由它去通知已经注册的观察者（Listener）。\n\n\n","slug":"Servlet工作原理分析","published":0,"updated":"2019-05-17T05:57:58.547Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1j8f2fw00027h9mmmd67ynb","content":"<h1 id=\"Tomcat中的Servlet容器\"><a href=\"#Tomcat中的Servlet容器\" class=\"headerlink\" title=\"Tomcat中的Servlet容器\"></a>Tomcat中的Servlet容器</h1><p>在Tomcat容器等级中，Context容器直接管理Servlet容器中的包装类Wrapper，所以Context容器如何运行将直接影响Servlet的工作方式。<br>Tomcat容器模型：  </p>\n<ol>\n<li>Container容器  </li>\n<li>Engine  </li>\n<li>Host  </li>\n<li>Servlet容器    </li>\n<li>Context    </li>\n</ol>\n<p>Tomcat容器分为4个等级，管理Servlet的容器是Context容器，一个Context对应一个Web工程。</p>\n<h1 id=\"Servlet容器启动\"><a href=\"#Servlet容器启动\" class=\"headerlink\" title=\"Servlet容器启动\"></a>Servlet容器启动</h1><p>Tomcat7开始支持嵌入式功能，增加了一个启动类org.apache.catalina.startup.Tomcat。创建一个实例对象并调用start方法就可以很容易地启动Tomcat。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public Context addWebapp(Host host, String url, String name, String path) &#123;</span><br><span class=\"line\">       silence(host, url);</span><br><span class=\"line\"></span><br><span class=\"line\">       Context ctx = new StandardContext();</span><br><span class=\"line\">       ctx.setName(name);</span><br><span class=\"line\">       ctx.setPath(url);</span><br><span class=\"line\">       ctx.setDocBase(path);</span><br><span class=\"line\"></span><br><span class=\"line\">       ctx.addLifecycleListener(new DefaultWebXmlListener());</span><br><span class=\"line\">       </span><br><span class=\"line\">       ContextConfig ctxCfg = new ContextConfig();</span><br><span class=\"line\">       ctx.addLifecycleListener(ctxCfg);</span><br><span class=\"line\">       </span><br><span class=\"line\">       // prevent it from looking ( if it finds one - it&apos;ll have dup error )</span><br><span class=\"line\">       ctxCfg.setDefaultWebXml(noDefaultWebXmlPath());</span><br><span class=\"line\"></span><br><span class=\"line\">       if (host == null) &#123;</span><br><span class=\"line\">           getHost().addChild(ctx);</span><br><span class=\"line\">       &#125; else &#123;</span><br><span class=\"line\">           host.addChild(ctx);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">       return ctx;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<p>一个Web应用对应一个Context容器，也就是Servlet运行时的Servlet容器。添加一个Web应用时将会创建一个StandardContext容器，并给这个容器设置必要的参数，url和path分别代表这个应用在Tomcat中的访问路径和这个应用实际的物理路径。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void start() throws LifecycleException &#123;</span><br><span class=\"line\">    getServer();</span><br><span class=\"line\">    getConnector();</span><br><span class=\"line\">    server.start();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>调用Tomcat的start方法启动Tomcat。Tomcat启动逻辑基于观察者模式设计，所有容器都会继承LifeCycle接口，它管理着容器的整个生命周期，所有容器的修改和状态的改变都会由它去通知已经注册的观察者（Listener）。</p>\n","excerpt":"","more":"<h1 id=\"Tomcat中的Servlet容器\"><a href=\"#Tomcat中的Servlet容器\" class=\"headerlink\" title=\"Tomcat中的Servlet容器\"></a>Tomcat中的Servlet容器</h1><p>在Tomcat容器等级中，Context容器直接管理Servlet容器中的包装类Wrapper，所以Context容器如何运行将直接影响Servlet的工作方式。<br>Tomcat容器模型：  </p>\n<ol>\n<li>Container容器  </li>\n<li>Engine  </li>\n<li>Host  </li>\n<li>Servlet容器    </li>\n<li>Context    </li>\n</ol>\n<p>Tomcat容器分为4个等级，管理Servlet的容器是Context容器，一个Context对应一个Web工程。</p>\n<h1 id=\"Servlet容器启动\"><a href=\"#Servlet容器启动\" class=\"headerlink\" title=\"Servlet容器启动\"></a>Servlet容器启动</h1><p>Tomcat7开始支持嵌入式功能，增加了一个启动类org.apache.catalina.startup.Tomcat。创建一个实例对象并调用start方法就可以很容易地启动Tomcat。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public Context addWebapp(Host host, String url, String name, String path) &#123;</span><br><span class=\"line\">       silence(host, url);</span><br><span class=\"line\"></span><br><span class=\"line\">       Context ctx = new StandardContext();</span><br><span class=\"line\">       ctx.setName(name);</span><br><span class=\"line\">       ctx.setPath(url);</span><br><span class=\"line\">       ctx.setDocBase(path);</span><br><span class=\"line\"></span><br><span class=\"line\">       ctx.addLifecycleListener(new DefaultWebXmlListener());</span><br><span class=\"line\">       </span><br><span class=\"line\">       ContextConfig ctxCfg = new ContextConfig();</span><br><span class=\"line\">       ctx.addLifecycleListener(ctxCfg);</span><br><span class=\"line\">       </span><br><span class=\"line\">       // prevent it from looking ( if it finds one - it&apos;ll have dup error )</span><br><span class=\"line\">       ctxCfg.setDefaultWebXml(noDefaultWebXmlPath());</span><br><span class=\"line\"></span><br><span class=\"line\">       if (host == null) &#123;</span><br><span class=\"line\">           getHost().addChild(ctx);</span><br><span class=\"line\">       &#125; else &#123;</span><br><span class=\"line\">           host.addChild(ctx);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">       return ctx;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<p>一个Web应用对应一个Context容器，也就是Servlet运行时的Servlet容器。添加一个Web应用时将会创建一个StandardContext容器，并给这个容器设置必要的参数，url和path分别代表这个应用在Tomcat中的访问路径和这个应用实际的物理路径。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void start() throws LifecycleException &#123;</span><br><span class=\"line\">    getServer();</span><br><span class=\"line\">    getConnector();</span><br><span class=\"line\">    server.start();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>调用Tomcat的start方法启动Tomcat。Tomcat启动逻辑基于观察者模式设计，所有容器都会继承LifeCycle接口，它管理着容器的整个生命周期，所有容器的修改和状态的改变都会由它去通知已经注册的观察者（Listener）。</p>\n"},{"title":"多线程和并发","date":"2017-06-10T16:00:00.000Z","_content":"\n*\t[预防线程死锁](#预防线程死锁)\n\n##\t预防线程死锁\t","source":"_drafts/预防线程死锁.md","raw":"---\ntitle: 多线程和并发\ndate: 2017-06-11\ncategories: 编写高质量代码\ntags:\n- Java\n---\n\n*\t[预防线程死锁](#预防线程死锁)\n\n##\t预防线程死锁\t","slug":"预防线程死锁","published":0,"updated":"2019-05-17T05:57:58.549Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1j8f2fy00037h9m502g6aea","content":"<ul>\n<li><a href=\"#预防线程死锁\">预防线程死锁</a></li>\n</ul>\n<h2 id=\"预防线程死锁\"><a href=\"#预防线程死锁\" class=\"headerlink\" title=\"预防线程死锁\"></a>预防线程死锁</h2>","excerpt":"","more":"<ul>\n<li><a href=\"#预防线程死锁\">预防线程死锁</a></li>\n</ul>\n<h2 id=\"预防线程死锁\"><a href=\"#预防线程死锁\" class=\"headerlink\" title=\"预防线程死锁\"></a>预防线程死锁</h2>"},{"title":"初识HBase","date":"2016-07-04T16:00:00.000Z","_content":"\n##\t简介\nHBase是一个构建在HDFS之上、分布式、面向列的开源数据库，由Google BigTable的开源实现，它主要用于存储海量数据，是Hadoop生态系统中的重要一员。\n\n##\tHBase优势\n\n###\t1.成熟\n*\t社区成熟\t\n* \t理论充分经过实践\n*  \t丰富的工具支持, hbck、phoenix、solr\n\n###\t2.高效\n*\t将随机嘟列转化为顺序读写，适应高并发写入\n* \t均衡效果好读写性能和机器数保持线性关系\n*  \t行中没有保存数据的列不占存储空间\n\n###\t3.分布式特性\n*\t基于HDFS、Zookeeper\n* \t一致性、可用性、分区容忍性\n*  \t大数据存储\n*\t易扩展\n\n##\tHBase表特点\n*\t大：一个表可以有数十亿行，上百万列\n* \t面向列：面向列（族）的存储和权限访问，列（族）独立索引\n*  稀疏：对于为空（null）的列，并不占用存储空间，因此，表可以设计的非常稀疏\n*\t数据类型单一：HBase中的数据类型都是字符串(string)\n* \t无模式：每行都有一个可排序的主键和任意多的列，列可以根据需要动态增加，同一张表中不同的行可以有截然不同的列\n\n##\tHBase VS RDBMS\n*\t数据类型\t\nHBase中的数据都是字符串类型\n*\t数据操作\t\nHBase只有普通的增删改查等操作，没有表之间的关联查询\n*\t存储模式\t\nHBase是基于列式存储的，而RDBMS是基于行式存储的\n*\t应用场景\t\nHBase适合存储大量数据，查询效率极高\n\n***\n\n##\tHBase概念\n\n###\t1.主键\n*\t用来检索记录的主键\n* \t访问HBase表中的行，只有三种方式：\n\t1.\t通过单个Row Key访问\n\t2. \t通过Row Key的range\n\t3. \t全表扫描\n*\t主键为任意字符串，最大长度为64kb，按字典顺序存储，在HBase内部保存为字节数组\n\n###\t2.列族\n*\t列族在创建表的时候声明，一个列族可以包含多个列，列中的数据都是以二进制形式存在，没有数据类型\n* \t列族是一些列的集合\n*  \t一个列族所有列成员是有着相同的前缀。比如，列courses:histor和courses:math都是列族courses的成员，冒号是列族的分隔符，用来区分前缀和列名\n\n###\t3.时间戳与存储单元\n*\tHBase中通过row和columns确定的为一个存贮单元称为cell。每个cell都保存着同一份数据的多个版本。\n* \t在写入数据时，时间戳可以由HBase自动赋值（当前系统时间精确到毫秒），也可以显示赋值。\n*  \t每个cell中，不用版本的数据按照时间的倒序排序。\n\n##\tHBase数据模型\n\n###\tHBase存储细节\n*\t每个列族存储在HDFS上的一个单独文件夹中\n* \tKey和Version number会在每个列族中存储一份\n*  \t空值不会被保存","source":"_posts/HBase/初识HBase.md","raw":"---\ntitle: 初识HBase\ndate: 2016-07-05\ncategories: HBase\ntags: HBase\n---\n\n##\t简介\nHBase是一个构建在HDFS之上、分布式、面向列的开源数据库，由Google BigTable的开源实现，它主要用于存储海量数据，是Hadoop生态系统中的重要一员。\n\n##\tHBase优势\n\n###\t1.成熟\n*\t社区成熟\t\n* \t理论充分经过实践\n*  \t丰富的工具支持, hbck、phoenix、solr\n\n###\t2.高效\n*\t将随机嘟列转化为顺序读写，适应高并发写入\n* \t均衡效果好读写性能和机器数保持线性关系\n*  \t行中没有保存数据的列不占存储空间\n\n###\t3.分布式特性\n*\t基于HDFS、Zookeeper\n* \t一致性、可用性、分区容忍性\n*  \t大数据存储\n*\t易扩展\n\n##\tHBase表特点\n*\t大：一个表可以有数十亿行，上百万列\n* \t面向列：面向列（族）的存储和权限访问，列（族）独立索引\n*  稀疏：对于为空（null）的列，并不占用存储空间，因此，表可以设计的非常稀疏\n*\t数据类型单一：HBase中的数据类型都是字符串(string)\n* \t无模式：每行都有一个可排序的主键和任意多的列，列可以根据需要动态增加，同一张表中不同的行可以有截然不同的列\n\n##\tHBase VS RDBMS\n*\t数据类型\t\nHBase中的数据都是字符串类型\n*\t数据操作\t\nHBase只有普通的增删改查等操作，没有表之间的关联查询\n*\t存储模式\t\nHBase是基于列式存储的，而RDBMS是基于行式存储的\n*\t应用场景\t\nHBase适合存储大量数据，查询效率极高\n\n***\n\n##\tHBase概念\n\n###\t1.主键\n*\t用来检索记录的主键\n* \t访问HBase表中的行，只有三种方式：\n\t1.\t通过单个Row Key访问\n\t2. \t通过Row Key的range\n\t3. \t全表扫描\n*\t主键为任意字符串，最大长度为64kb，按字典顺序存储，在HBase内部保存为字节数组\n\n###\t2.列族\n*\t列族在创建表的时候声明，一个列族可以包含多个列，列中的数据都是以二进制形式存在，没有数据类型\n* \t列族是一些列的集合\n*  \t一个列族所有列成员是有着相同的前缀。比如，列courses:histor和courses:math都是列族courses的成员，冒号是列族的分隔符，用来区分前缀和列名\n\n###\t3.时间戳与存储单元\n*\tHBase中通过row和columns确定的为一个存贮单元称为cell。每个cell都保存着同一份数据的多个版本。\n* \t在写入数据时，时间戳可以由HBase自动赋值（当前系统时间精确到毫秒），也可以显示赋值。\n*  \t每个cell中，不用版本的数据按照时间的倒序排序。\n\n##\tHBase数据模型\n\n###\tHBase存储细节\n*\t每个列族存储在HDFS上的一个单独文件夹中\n* \tKey和Version number会在每个列族中存储一份\n*  \t空值不会被保存","slug":"HBase/初识HBase","published":1,"updated":"2019-05-17T05:57:58.550Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1j8f2gz000f7h9miype1jx3","content":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>HBase是一个构建在HDFS之上、分布式、面向列的开源数据库，由Google BigTable的开源实现，它主要用于存储海量数据，是Hadoop生态系统中的重要一员。</p>\n<h2 id=\"HBase优势\"><a href=\"#HBase优势\" class=\"headerlink\" title=\"HBase优势\"></a>HBase优势</h2><h3 id=\"1-成熟\"><a href=\"#1-成熟\" class=\"headerlink\" title=\"1.成熟\"></a>1.成熟</h3><ul>\n<li>社区成熟    </li>\n<li>理论充分经过实践</li>\n<li>丰富的工具支持, hbck、phoenix、solr</li>\n</ul>\n<h3 id=\"2-高效\"><a href=\"#2-高效\" class=\"headerlink\" title=\"2.高效\"></a>2.高效</h3><ul>\n<li>将随机嘟列转化为顺序读写，适应高并发写入</li>\n<li>均衡效果好读写性能和机器数保持线性关系</li>\n<li>行中没有保存数据的列不占存储空间</li>\n</ul>\n<h3 id=\"3-分布式特性\"><a href=\"#3-分布式特性\" class=\"headerlink\" title=\"3.分布式特性\"></a>3.分布式特性</h3><ul>\n<li>基于HDFS、Zookeeper</li>\n<li>一致性、可用性、分区容忍性</li>\n<li>大数据存储</li>\n<li>易扩展</li>\n</ul>\n<h2 id=\"HBase表特点\"><a href=\"#HBase表特点\" class=\"headerlink\" title=\"HBase表特点\"></a>HBase表特点</h2><ul>\n<li>大：一个表可以有数十亿行，上百万列</li>\n<li>面向列：面向列（族）的存储和权限访问，列（族）独立索引</li>\n<li>稀疏：对于为空（null）的列，并不占用存储空间，因此，表可以设计的非常稀疏</li>\n<li>数据类型单一：HBase中的数据类型都是字符串(string)</li>\n<li>无模式：每行都有一个可排序的主键和任意多的列，列可以根据需要动态增加，同一张表中不同的行可以有截然不同的列</li>\n</ul>\n<h2 id=\"HBase-VS-RDBMS\"><a href=\"#HBase-VS-RDBMS\" class=\"headerlink\" title=\"HBase VS RDBMS\"></a>HBase VS RDBMS</h2><ul>\n<li>数据类型<br>HBase中的数据都是字符串类型</li>\n<li>数据操作<br>HBase只有普通的增删改查等操作，没有表之间的关联查询</li>\n<li>存储模式<br>HBase是基于列式存储的，而RDBMS是基于行式存储的</li>\n<li>应用场景<br>HBase适合存储大量数据，查询效率极高</li>\n</ul>\n<hr>\n<h2 id=\"HBase概念\"><a href=\"#HBase概念\" class=\"headerlink\" title=\"HBase概念\"></a>HBase概念</h2><h3 id=\"1-主键\"><a href=\"#1-主键\" class=\"headerlink\" title=\"1.主键\"></a>1.主键</h3><ul>\n<li>用来检索记录的主键</li>\n<li>访问HBase表中的行，只有三种方式：<ol>\n<li>通过单个Row Key访问</li>\n<li>通过Row Key的range</li>\n<li>全表扫描</li>\n</ol>\n</li>\n<li>主键为任意字符串，最大长度为64kb，按字典顺序存储，在HBase内部保存为字节数组</li>\n</ul>\n<h3 id=\"2-列族\"><a href=\"#2-列族\" class=\"headerlink\" title=\"2.列族\"></a>2.列族</h3><ul>\n<li>列族在创建表的时候声明，一个列族可以包含多个列，列中的数据都是以二进制形式存在，没有数据类型</li>\n<li>列族是一些列的集合</li>\n<li>一个列族所有列成员是有着相同的前缀。比如，列courses:histor和courses:math都是列族courses的成员，冒号是列族的分隔符，用来区分前缀和列名</li>\n</ul>\n<h3 id=\"3-时间戳与存储单元\"><a href=\"#3-时间戳与存储单元\" class=\"headerlink\" title=\"3.时间戳与存储单元\"></a>3.时间戳与存储单元</h3><ul>\n<li>HBase中通过row和columns确定的为一个存贮单元称为cell。每个cell都保存着同一份数据的多个版本。</li>\n<li>在写入数据时，时间戳可以由HBase自动赋值（当前系统时间精确到毫秒），也可以显示赋值。</li>\n<li>每个cell中，不用版本的数据按照时间的倒序排序。</li>\n</ul>\n<h2 id=\"HBase数据模型\"><a href=\"#HBase数据模型\" class=\"headerlink\" title=\"HBase数据模型\"></a>HBase数据模型</h2><h3 id=\"HBase存储细节\"><a href=\"#HBase存储细节\" class=\"headerlink\" title=\"HBase存储细节\"></a>HBase存储细节</h3><ul>\n<li>每个列族存储在HDFS上的一个单独文件夹中</li>\n<li>Key和Version number会在每个列族中存储一份</li>\n<li>空值不会被保存</li>\n</ul>\n","excerpt":"","more":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>HBase是一个构建在HDFS之上、分布式、面向列的开源数据库，由Google BigTable的开源实现，它主要用于存储海量数据，是Hadoop生态系统中的重要一员。</p>\n<h2 id=\"HBase优势\"><a href=\"#HBase优势\" class=\"headerlink\" title=\"HBase优势\"></a>HBase优势</h2><h3 id=\"1-成熟\"><a href=\"#1-成熟\" class=\"headerlink\" title=\"1.成熟\"></a>1.成熟</h3><ul>\n<li>社区成熟    </li>\n<li>理论充分经过实践</li>\n<li>丰富的工具支持, hbck、phoenix、solr</li>\n</ul>\n<h3 id=\"2-高效\"><a href=\"#2-高效\" class=\"headerlink\" title=\"2.高效\"></a>2.高效</h3><ul>\n<li>将随机嘟列转化为顺序读写，适应高并发写入</li>\n<li>均衡效果好读写性能和机器数保持线性关系</li>\n<li>行中没有保存数据的列不占存储空间</li>\n</ul>\n<h3 id=\"3-分布式特性\"><a href=\"#3-分布式特性\" class=\"headerlink\" title=\"3.分布式特性\"></a>3.分布式特性</h3><ul>\n<li>基于HDFS、Zookeeper</li>\n<li>一致性、可用性、分区容忍性</li>\n<li>大数据存储</li>\n<li>易扩展</li>\n</ul>\n<h2 id=\"HBase表特点\"><a href=\"#HBase表特点\" class=\"headerlink\" title=\"HBase表特点\"></a>HBase表特点</h2><ul>\n<li>大：一个表可以有数十亿行，上百万列</li>\n<li>面向列：面向列（族）的存储和权限访问，列（族）独立索引</li>\n<li>稀疏：对于为空（null）的列，并不占用存储空间，因此，表可以设计的非常稀疏</li>\n<li>数据类型单一：HBase中的数据类型都是字符串(string)</li>\n<li>无模式：每行都有一个可排序的主键和任意多的列，列可以根据需要动态增加，同一张表中不同的行可以有截然不同的列</li>\n</ul>\n<h2 id=\"HBase-VS-RDBMS\"><a href=\"#HBase-VS-RDBMS\" class=\"headerlink\" title=\"HBase VS RDBMS\"></a>HBase VS RDBMS</h2><ul>\n<li>数据类型<br>HBase中的数据都是字符串类型</li>\n<li>数据操作<br>HBase只有普通的增删改查等操作，没有表之间的关联查询</li>\n<li>存储模式<br>HBase是基于列式存储的，而RDBMS是基于行式存储的</li>\n<li>应用场景<br>HBase适合存储大量数据，查询效率极高</li>\n</ul>\n<hr>\n<h2 id=\"HBase概念\"><a href=\"#HBase概念\" class=\"headerlink\" title=\"HBase概念\"></a>HBase概念</h2><h3 id=\"1-主键\"><a href=\"#1-主键\" class=\"headerlink\" title=\"1.主键\"></a>1.主键</h3><ul>\n<li>用来检索记录的主键</li>\n<li>访问HBase表中的行，只有三种方式：<ol>\n<li>通过单个Row Key访问</li>\n<li>通过Row Key的range</li>\n<li>全表扫描</li>\n</ol>\n</li>\n<li>主键为任意字符串，最大长度为64kb，按字典顺序存储，在HBase内部保存为字节数组</li>\n</ul>\n<h3 id=\"2-列族\"><a href=\"#2-列族\" class=\"headerlink\" title=\"2.列族\"></a>2.列族</h3><ul>\n<li>列族在创建表的时候声明，一个列族可以包含多个列，列中的数据都是以二进制形式存在，没有数据类型</li>\n<li>列族是一些列的集合</li>\n<li>一个列族所有列成员是有着相同的前缀。比如，列courses:histor和courses:math都是列族courses的成员，冒号是列族的分隔符，用来区分前缀和列名</li>\n</ul>\n<h3 id=\"3-时间戳与存储单元\"><a href=\"#3-时间戳与存储单元\" class=\"headerlink\" title=\"3.时间戳与存储单元\"></a>3.时间戳与存储单元</h3><ul>\n<li>HBase中通过row和columns确定的为一个存贮单元称为cell。每个cell都保存着同一份数据的多个版本。</li>\n<li>在写入数据时，时间戳可以由HBase自动赋值（当前系统时间精确到毫秒），也可以显示赋值。</li>\n<li>每个cell中，不用版本的数据按照时间的倒序排序。</li>\n</ul>\n<h2 id=\"HBase数据模型\"><a href=\"#HBase数据模型\" class=\"headerlink\" title=\"HBase数据模型\"></a>HBase数据模型</h2><h3 id=\"HBase存储细节\"><a href=\"#HBase存储细节\" class=\"headerlink\" title=\"HBase存储细节\"></a>HBase存储细节</h3><ul>\n<li>每个列族存储在HDFS上的一个单独文件夹中</li>\n<li>Key和Version number会在每个列族中存储一份</li>\n<li>空值不会被保存</li>\n</ul>\n"},{"title":"DNS域名解析过程","date":"2016-05-10T16:00:00.000Z","_content":"\n当用户在浏览器输入www.abc.com，DNS解析将会有将近10个步骤。\n\n1.\t浏览器检查缓存有没有该域名对应的IP。如果有，这个解析过程就结束。浏览器缓存域名是有限制的，不仅大小有限制，时间也有限制，通过TTL属性设置域名缓存时间。\n2. 浏览器缓存中没有，检查操作系统缓存中是否有解析结果。如果有，解析结束。没有的话，请求域名服务器解析该域名。\n3. 网络配置有配置DNS服务器地址，操作系统把域名发送给这里的LDNS。Linux下通过以下命令查看。  \n```\ncat /etc/resolv.conf\n```\n4.\tLDNS未命中，直接到Root Server域名服务器请求解析。\n5. 根域名服务器返回本地域名服务器一个服务器地址(gTLD Server)。gTLD是国际顶级域名服务器，如.com、.cn、.org等，全球只有13台左右。\n6. 本地域名服务器再向上一步返回的gTLD服务器发送请求。\n7. gTLD服务器查找并返回此域名对应的Name Server域名服务器地址，这个Name Server通常就是你注册的域名服务器。\n8. Name Server域名服务器查询存储的域名和IP映射关系，正常情况下查询到目标IP记录，连同一个TTL值返回给DNS Server域名服务器。\n9. 返回该域名对应的IP和TTL值，Local DNS Server会缓存该记录。\n10. 解析结果返回给用户，用户根据TTL值缓存这个记录。\n\n实际过程中，可能不止这个10个步骤，如Name Server有多级或者有个GTM负载均衡控制，这都会影响域名解析的过程。\n\n#\t跟踪域名解析过程\n\n##\tdig\n```\n--- ~ » dig www.google.com\n\n; <<>> DiG 9.8.3-P1 <<>> www.google.com\n;; global options: +cmd\n;; Got answer:\n;; ->>HEADER<<- opcode: QUERY, status: NOERROR, id: 50606\n;; flags: qr rd ra; QUERY: 1, ANSWER: 16, AUTHORITY: 0, ADDITIONAL: 0\n\n;; QUESTION SECTION:\n;www.google.com.\t\t\tIN\tA\n\n;; ANSWER SECTION:\nwww.google.com.\t\t299\tIN\tA\t61.238.239.35\nwww.google.com.\t\t299\tIN\tA\t61.238.239.20\nwww.google.com.\t\t299\tIN\tA\t61.238.239.24\nwww.google.com.\t\t299\tIN\tA\t61.238.239.59\nwww.google.com.\t\t299\tIN\tA\t61.238.239.29\nwww.google.com.\t\t299\tIN\tA\t61.238.239.30\nwww.google.com.\t\t299\tIN\tA\t61.238.239.45\nwww.google.com.\t\t299\tIN\tA\t61.238.239.40\nwww.google.com.\t\t299\tIN\tA\t61.238.239.55\nwww.google.com.\t\t299\tIN\tA\t61.238.239.34\nwww.google.com.\t\t299\tIN\tA\t61.238.239.44\nwww.google.com.\t\t299\tIN\tA\t61.238.239.49\nwww.google.com.\t\t299\tIN\tA\t61.238.239.54\nwww.google.com.\t\t299\tIN\tA\t61.238.239.25\nwww.google.com.\t\t299\tIN\tA\t61.238.239.39\nwww.google.com.\t\t299\tIN\tA\t61.238.239.50\n\n;; Query time: 61 msec\n;; SERVER: 8.8.8.8#53(8.8.8.8)\n;; WHEN: Wed May 11 21:04:56 2016\n;; MSG SIZE  rcvd: 288\n\n--- ~ » \n```\n\n## dig +cmd\n```\n--- ~ » dig +printcmd www.taobao.com\nInvalid option: +printcmd\nUsage:  dig [@global-server] [domain] [q-type] [q-class] {q-opt}\n            {global-d-opt} host [@local-server] {local-d-opt}\n            [ host [@local-server] {local-d-opt} [...]]\n\nUse \"dig -h\" (or \"dig -h | more\") for complete list of options\n--- ~ » dig +cmd www.taobao.com                                                                                                                                        1 ↵\n\n; <<>> DiG 9.8.3-P1 <<>> +cmd www.taobao.com\n;; global options: +cmd\n;; Got answer:\n;; ->>HEADER<<- opcode: QUERY, status: NOERROR, id: 62882\n;; flags: qr rd ra; QUERY: 1, ANSWER: 2, AUTHORITY: 0, ADDITIONAL: 0\n\n;; QUESTION SECTION:\n;www.taobao.com.\t\t\tIN\tA\n\n;; ANSWER SECTION:\nwww.taobao.com.\t\t71\tIN\tCNAME\twww.taobao.com.danuoyi.tbcache.com.\nwww.taobao.com.danuoyi.tbcache.com. 599\tIN A\t205.204.104.227\n\n;; Query time: 73 msec\n;; SERVER: 8.8.8.8#53(8.8.8.8)\n;; WHEN: Wed May 11 21:07:41 2016\n;; MSG SIZE  rcvd: 93\n\n--- ~ » \n```\n\n##\tdig +trace\n```\n--- ~ » dig www.google.com +trace                                                                                                                                      9 ↵\n\n; <<>> DiG 9.8.3-P1 <<>> www.google.com +trace\n;; global options: +cmd\n.\t\t\t5236\tIN\tNS\ta.root-servers.net.\n.\t\t\t5236\tIN\tNS\tb.root-servers.net.\n.\t\t\t5236\tIN\tNS\tc.root-servers.net.\n.\t\t\t5236\tIN\tNS\td.root-servers.net.\n.\t\t\t5236\tIN\tNS\te.root-servers.net.\n.\t\t\t5236\tIN\tNS\tf.root-servers.net.\n.\t\t\t5236\tIN\tNS\tg.root-servers.net.\n.\t\t\t5236\tIN\tNS\th.root-servers.net.\n.\t\t\t5236\tIN\tNS\ti.root-servers.net.\n.\t\t\t5236\tIN\tNS\tj.root-servers.net.\n.\t\t\t5236\tIN\tNS\tk.root-servers.net.\n.\t\t\t5236\tIN\tNS\tl.root-servers.net.\n.\t\t\t5236\tIN\tNS\tm.root-servers.net.\n;; Received 228 bytes from 8.8.8.8#53(8.8.8.8) in 63 ms\n\ncom.\t\t\t172800\tIN\tNS\tm.gtld-servers.net.\ncom.\t\t\t172800\tIN\tNS\te.gtld-servers.net.\ncom.\t\t\t172800\tIN\tNS\td.gtld-servers.net.\ncom.\t\t\t172800\tIN\tNS\tb.gtld-servers.net.\ncom.\t\t\t172800\tIN\tNS\tj.gtld-servers.net.\ncom.\t\t\t172800\tIN\tNS\tf.gtld-servers.net.\ncom.\t\t\t172800\tIN\tNS\tg.gtld-servers.net.\ncom.\t\t\t172800\tIN\tNS\tl.gtld-servers.net.\ncom.\t\t\t172800\tIN\tNS\tk.gtld-servers.net.\ncom.\t\t\t172800\tIN\tNS\th.gtld-servers.net.\ncom.\t\t\t172800\tIN\tNS\ti.gtld-servers.net.\ncom.\t\t\t172800\tIN\tNS\ta.gtld-servers.net.\ncom.\t\t\t172800\tIN\tNS\tc.gtld-servers.net.\n;; Received 504 bytes from 192.5.5.241#53(192.5.5.241) in 38 ms\n\n;; connection timed out; no servers could be reached\n--- ~ »   \n```\n\n\n#\t几种域名解析方式\n*\tA记录，指定域名对应IP。\n* \tMX记录，表示Mail Exchange，将某个域名下邮件服务器指向自己Mail Server。正常通过Web请求仍然解析A记录IP。\n*  CNAME记录，Canonical Name(别名解析)。\n*  NS记录，为某个域名指定DNS解析服务器。\n*  TXT记录，为某个主机名或域名设置说明。","source":"_posts/Java Web/DNS域名解析过程.md","raw":"---\ntitle: DNS域名解析过程\ndate: 2016-05-11\ncategories: Java Web\ntags: DNS \n---\n\n当用户在浏览器输入www.abc.com，DNS解析将会有将近10个步骤。\n\n1.\t浏览器检查缓存有没有该域名对应的IP。如果有，这个解析过程就结束。浏览器缓存域名是有限制的，不仅大小有限制，时间也有限制，通过TTL属性设置域名缓存时间。\n2. 浏览器缓存中没有，检查操作系统缓存中是否有解析结果。如果有，解析结束。没有的话，请求域名服务器解析该域名。\n3. 网络配置有配置DNS服务器地址，操作系统把域名发送给这里的LDNS。Linux下通过以下命令查看。  \n```\ncat /etc/resolv.conf\n```\n4.\tLDNS未命中，直接到Root Server域名服务器请求解析。\n5. 根域名服务器返回本地域名服务器一个服务器地址(gTLD Server)。gTLD是国际顶级域名服务器，如.com、.cn、.org等，全球只有13台左右。\n6. 本地域名服务器再向上一步返回的gTLD服务器发送请求。\n7. gTLD服务器查找并返回此域名对应的Name Server域名服务器地址，这个Name Server通常就是你注册的域名服务器。\n8. Name Server域名服务器查询存储的域名和IP映射关系，正常情况下查询到目标IP记录，连同一个TTL值返回给DNS Server域名服务器。\n9. 返回该域名对应的IP和TTL值，Local DNS Server会缓存该记录。\n10. 解析结果返回给用户，用户根据TTL值缓存这个记录。\n\n实际过程中，可能不止这个10个步骤，如Name Server有多级或者有个GTM负载均衡控制，这都会影响域名解析的过程。\n\n#\t跟踪域名解析过程\n\n##\tdig\n```\n--- ~ » dig www.google.com\n\n; <<>> DiG 9.8.3-P1 <<>> www.google.com\n;; global options: +cmd\n;; Got answer:\n;; ->>HEADER<<- opcode: QUERY, status: NOERROR, id: 50606\n;; flags: qr rd ra; QUERY: 1, ANSWER: 16, AUTHORITY: 0, ADDITIONAL: 0\n\n;; QUESTION SECTION:\n;www.google.com.\t\t\tIN\tA\n\n;; ANSWER SECTION:\nwww.google.com.\t\t299\tIN\tA\t61.238.239.35\nwww.google.com.\t\t299\tIN\tA\t61.238.239.20\nwww.google.com.\t\t299\tIN\tA\t61.238.239.24\nwww.google.com.\t\t299\tIN\tA\t61.238.239.59\nwww.google.com.\t\t299\tIN\tA\t61.238.239.29\nwww.google.com.\t\t299\tIN\tA\t61.238.239.30\nwww.google.com.\t\t299\tIN\tA\t61.238.239.45\nwww.google.com.\t\t299\tIN\tA\t61.238.239.40\nwww.google.com.\t\t299\tIN\tA\t61.238.239.55\nwww.google.com.\t\t299\tIN\tA\t61.238.239.34\nwww.google.com.\t\t299\tIN\tA\t61.238.239.44\nwww.google.com.\t\t299\tIN\tA\t61.238.239.49\nwww.google.com.\t\t299\tIN\tA\t61.238.239.54\nwww.google.com.\t\t299\tIN\tA\t61.238.239.25\nwww.google.com.\t\t299\tIN\tA\t61.238.239.39\nwww.google.com.\t\t299\tIN\tA\t61.238.239.50\n\n;; Query time: 61 msec\n;; SERVER: 8.8.8.8#53(8.8.8.8)\n;; WHEN: Wed May 11 21:04:56 2016\n;; MSG SIZE  rcvd: 288\n\n--- ~ » \n```\n\n## dig +cmd\n```\n--- ~ » dig +printcmd www.taobao.com\nInvalid option: +printcmd\nUsage:  dig [@global-server] [domain] [q-type] [q-class] {q-opt}\n            {global-d-opt} host [@local-server] {local-d-opt}\n            [ host [@local-server] {local-d-opt} [...]]\n\nUse \"dig -h\" (or \"dig -h | more\") for complete list of options\n--- ~ » dig +cmd www.taobao.com                                                                                                                                        1 ↵\n\n; <<>> DiG 9.8.3-P1 <<>> +cmd www.taobao.com\n;; global options: +cmd\n;; Got answer:\n;; ->>HEADER<<- opcode: QUERY, status: NOERROR, id: 62882\n;; flags: qr rd ra; QUERY: 1, ANSWER: 2, AUTHORITY: 0, ADDITIONAL: 0\n\n;; QUESTION SECTION:\n;www.taobao.com.\t\t\tIN\tA\n\n;; ANSWER SECTION:\nwww.taobao.com.\t\t71\tIN\tCNAME\twww.taobao.com.danuoyi.tbcache.com.\nwww.taobao.com.danuoyi.tbcache.com. 599\tIN A\t205.204.104.227\n\n;; Query time: 73 msec\n;; SERVER: 8.8.8.8#53(8.8.8.8)\n;; WHEN: Wed May 11 21:07:41 2016\n;; MSG SIZE  rcvd: 93\n\n--- ~ » \n```\n\n##\tdig +trace\n```\n--- ~ » dig www.google.com +trace                                                                                                                                      9 ↵\n\n; <<>> DiG 9.8.3-P1 <<>> www.google.com +trace\n;; global options: +cmd\n.\t\t\t5236\tIN\tNS\ta.root-servers.net.\n.\t\t\t5236\tIN\tNS\tb.root-servers.net.\n.\t\t\t5236\tIN\tNS\tc.root-servers.net.\n.\t\t\t5236\tIN\tNS\td.root-servers.net.\n.\t\t\t5236\tIN\tNS\te.root-servers.net.\n.\t\t\t5236\tIN\tNS\tf.root-servers.net.\n.\t\t\t5236\tIN\tNS\tg.root-servers.net.\n.\t\t\t5236\tIN\tNS\th.root-servers.net.\n.\t\t\t5236\tIN\tNS\ti.root-servers.net.\n.\t\t\t5236\tIN\tNS\tj.root-servers.net.\n.\t\t\t5236\tIN\tNS\tk.root-servers.net.\n.\t\t\t5236\tIN\tNS\tl.root-servers.net.\n.\t\t\t5236\tIN\tNS\tm.root-servers.net.\n;; Received 228 bytes from 8.8.8.8#53(8.8.8.8) in 63 ms\n\ncom.\t\t\t172800\tIN\tNS\tm.gtld-servers.net.\ncom.\t\t\t172800\tIN\tNS\te.gtld-servers.net.\ncom.\t\t\t172800\tIN\tNS\td.gtld-servers.net.\ncom.\t\t\t172800\tIN\tNS\tb.gtld-servers.net.\ncom.\t\t\t172800\tIN\tNS\tj.gtld-servers.net.\ncom.\t\t\t172800\tIN\tNS\tf.gtld-servers.net.\ncom.\t\t\t172800\tIN\tNS\tg.gtld-servers.net.\ncom.\t\t\t172800\tIN\tNS\tl.gtld-servers.net.\ncom.\t\t\t172800\tIN\tNS\tk.gtld-servers.net.\ncom.\t\t\t172800\tIN\tNS\th.gtld-servers.net.\ncom.\t\t\t172800\tIN\tNS\ti.gtld-servers.net.\ncom.\t\t\t172800\tIN\tNS\ta.gtld-servers.net.\ncom.\t\t\t172800\tIN\tNS\tc.gtld-servers.net.\n;; Received 504 bytes from 192.5.5.241#53(192.5.5.241) in 38 ms\n\n;; connection timed out; no servers could be reached\n--- ~ »   \n```\n\n\n#\t几种域名解析方式\n*\tA记录，指定域名对应IP。\n* \tMX记录，表示Mail Exchange，将某个域名下邮件服务器指向自己Mail Server。正常通过Web请求仍然解析A记录IP。\n*  CNAME记录，Canonical Name(别名解析)。\n*  NS记录，为某个域名指定DNS解析服务器。\n*  TXT记录，为某个主机名或域名设置说明。","slug":"Java Web/DNS域名解析过程","published":1,"updated":"2019-05-17T05:57:58.551Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1j8f2h3000i7h9mdzndq87f","content":"<p>当用户在浏览器输入www.abc.com，DNS解析将会有将近10个步骤。</p>\n<ol>\n<li>浏览器检查缓存有没有该域名对应的IP。如果有，这个解析过程就结束。浏览器缓存域名是有限制的，不仅大小有限制，时间也有限制，通过TTL属性设置域名缓存时间。</li>\n<li>浏览器缓存中没有，检查操作系统缓存中是否有解析结果。如果有，解析结束。没有的话，请求域名服务器解析该域名。</li>\n<li><p>网络配置有配置DNS服务器地址，操作系统把域名发送给这里的LDNS。Linux下通过以下命令查看。  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cat /etc/resolv.conf</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>LDNS未命中，直接到Root Server域名服务器请求解析。</p>\n</li>\n<li>根域名服务器返回本地域名服务器一个服务器地址(gTLD Server)。gTLD是国际顶级域名服务器，如.com、.cn、.org等，全球只有13台左右。</li>\n<li>本地域名服务器再向上一步返回的gTLD服务器发送请求。</li>\n<li>gTLD服务器查找并返回此域名对应的Name Server域名服务器地址，这个Name Server通常就是你注册的域名服务器。</li>\n<li>Name Server域名服务器查询存储的域名和IP映射关系，正常情况下查询到目标IP记录，连同一个TTL值返回给DNS Server域名服务器。</li>\n<li>返回该域名对应的IP和TTL值，Local DNS Server会缓存该记录。</li>\n<li>解析结果返回给用户，用户根据TTL值缓存这个记录。</li>\n</ol>\n<p>实际过程中，可能不止这个10个步骤，如Name Server有多级或者有个GTM负载均衡控制，这都会影响域名解析的过程。</p>\n<h1 id=\"跟踪域名解析过程\"><a href=\"#跟踪域名解析过程\" class=\"headerlink\" title=\"跟踪域名解析过程\"></a>跟踪域名解析过程</h1><h2 id=\"dig\"><a href=\"#dig\" class=\"headerlink\" title=\"dig\"></a>dig</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">--- ~ » dig www.google.com</span><br><span class=\"line\"></span><br><span class=\"line\">; &lt;&lt;&gt;&gt; DiG 9.8.3-P1 &lt;&lt;&gt;&gt; www.google.com</span><br><span class=\"line\">;; global options: +cmd</span><br><span class=\"line\">;; Got answer:</span><br><span class=\"line\">;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 50606</span><br><span class=\"line\">;; flags: qr rd ra; QUERY: 1, ANSWER: 16, AUTHORITY: 0, ADDITIONAL: 0</span><br><span class=\"line\"></span><br><span class=\"line\">;; QUESTION SECTION:</span><br><span class=\"line\">;www.google.com.\t\t\tIN\tA</span><br><span class=\"line\"></span><br><span class=\"line\">;; ANSWER SECTION:</span><br><span class=\"line\">www.google.com.\t\t299\tIN\tA\t61.238.239.35</span><br><span class=\"line\">www.google.com.\t\t299\tIN\tA\t61.238.239.20</span><br><span class=\"line\">www.google.com.\t\t299\tIN\tA\t61.238.239.24</span><br><span class=\"line\">www.google.com.\t\t299\tIN\tA\t61.238.239.59</span><br><span class=\"line\">www.google.com.\t\t299\tIN\tA\t61.238.239.29</span><br><span class=\"line\">www.google.com.\t\t299\tIN\tA\t61.238.239.30</span><br><span class=\"line\">www.google.com.\t\t299\tIN\tA\t61.238.239.45</span><br><span class=\"line\">www.google.com.\t\t299\tIN\tA\t61.238.239.40</span><br><span class=\"line\">www.google.com.\t\t299\tIN\tA\t61.238.239.55</span><br><span class=\"line\">www.google.com.\t\t299\tIN\tA\t61.238.239.34</span><br><span class=\"line\">www.google.com.\t\t299\tIN\tA\t61.238.239.44</span><br><span class=\"line\">www.google.com.\t\t299\tIN\tA\t61.238.239.49</span><br><span class=\"line\">www.google.com.\t\t299\tIN\tA\t61.238.239.54</span><br><span class=\"line\">www.google.com.\t\t299\tIN\tA\t61.238.239.25</span><br><span class=\"line\">www.google.com.\t\t299\tIN\tA\t61.238.239.39</span><br><span class=\"line\">www.google.com.\t\t299\tIN\tA\t61.238.239.50</span><br><span class=\"line\"></span><br><span class=\"line\">;; Query time: 61 msec</span><br><span class=\"line\">;; SERVER: 8.8.8.8#53(8.8.8.8)</span><br><span class=\"line\">;; WHEN: Wed May 11 21:04:56 2016</span><br><span class=\"line\">;; MSG SIZE  rcvd: 288</span><br><span class=\"line\"></span><br><span class=\"line\">--- ~ »</span><br></pre></td></tr></table></figure>\n<h2 id=\"dig-cmd\"><a href=\"#dig-cmd\" class=\"headerlink\" title=\"dig +cmd\"></a>dig +cmd</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">--- ~ » dig +printcmd www.taobao.com</span><br><span class=\"line\">Invalid option: +printcmd</span><br><span class=\"line\">Usage:  dig [@global-server] [domain] [q-type] [q-class] &#123;q-opt&#125;</span><br><span class=\"line\">            &#123;global-d-opt&#125; host [@local-server] &#123;local-d-opt&#125;</span><br><span class=\"line\">            [ host [@local-server] &#123;local-d-opt&#125; [...]]</span><br><span class=\"line\"></span><br><span class=\"line\">Use &quot;dig -h&quot; (or &quot;dig -h | more&quot;) for complete list of options</span><br><span class=\"line\">--- ~ » dig +cmd www.taobao.com                                                                                                                                        1 ↵</span><br><span class=\"line\"></span><br><span class=\"line\">; &lt;&lt;&gt;&gt; DiG 9.8.3-P1 &lt;&lt;&gt;&gt; +cmd www.taobao.com</span><br><span class=\"line\">;; global options: +cmd</span><br><span class=\"line\">;; Got answer:</span><br><span class=\"line\">;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 62882</span><br><span class=\"line\">;; flags: qr rd ra; QUERY: 1, ANSWER: 2, AUTHORITY: 0, ADDITIONAL: 0</span><br><span class=\"line\"></span><br><span class=\"line\">;; QUESTION SECTION:</span><br><span class=\"line\">;www.taobao.com.\t\t\tIN\tA</span><br><span class=\"line\"></span><br><span class=\"line\">;; ANSWER SECTION:</span><br><span class=\"line\">www.taobao.com.\t\t71\tIN\tCNAME\twww.taobao.com.danuoyi.tbcache.com.</span><br><span class=\"line\">www.taobao.com.danuoyi.tbcache.com. 599\tIN A\t205.204.104.227</span><br><span class=\"line\"></span><br><span class=\"line\">;; Query time: 73 msec</span><br><span class=\"line\">;; SERVER: 8.8.8.8#53(8.8.8.8)</span><br><span class=\"line\">;; WHEN: Wed May 11 21:07:41 2016</span><br><span class=\"line\">;; MSG SIZE  rcvd: 93</span><br><span class=\"line\"></span><br><span class=\"line\">--- ~ »</span><br></pre></td></tr></table></figure>\n<h2 id=\"dig-trace\"><a href=\"#dig-trace\" class=\"headerlink\" title=\"dig +trace\"></a>dig +trace</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">--- ~ » dig www.google.com +trace                                                                                                                                      9 ↵</span><br><span class=\"line\"></span><br><span class=\"line\">; &lt;&lt;&gt;&gt; DiG 9.8.3-P1 &lt;&lt;&gt;&gt; www.google.com +trace</span><br><span class=\"line\">;; global options: +cmd</span><br><span class=\"line\">.\t\t\t5236\tIN\tNS\ta.root-servers.net.</span><br><span class=\"line\">.\t\t\t5236\tIN\tNS\tb.root-servers.net.</span><br><span class=\"line\">.\t\t\t5236\tIN\tNS\tc.root-servers.net.</span><br><span class=\"line\">.\t\t\t5236\tIN\tNS\td.root-servers.net.</span><br><span class=\"line\">.\t\t\t5236\tIN\tNS\te.root-servers.net.</span><br><span class=\"line\">.\t\t\t5236\tIN\tNS\tf.root-servers.net.</span><br><span class=\"line\">.\t\t\t5236\tIN\tNS\tg.root-servers.net.</span><br><span class=\"line\">.\t\t\t5236\tIN\tNS\th.root-servers.net.</span><br><span class=\"line\">.\t\t\t5236\tIN\tNS\ti.root-servers.net.</span><br><span class=\"line\">.\t\t\t5236\tIN\tNS\tj.root-servers.net.</span><br><span class=\"line\">.\t\t\t5236\tIN\tNS\tk.root-servers.net.</span><br><span class=\"line\">.\t\t\t5236\tIN\tNS\tl.root-servers.net.</span><br><span class=\"line\">.\t\t\t5236\tIN\tNS\tm.root-servers.net.</span><br><span class=\"line\">;; Received 228 bytes from 8.8.8.8#53(8.8.8.8) in 63 ms</span><br><span class=\"line\"></span><br><span class=\"line\">com.\t\t\t172800\tIN\tNS\tm.gtld-servers.net.</span><br><span class=\"line\">com.\t\t\t172800\tIN\tNS\te.gtld-servers.net.</span><br><span class=\"line\">com.\t\t\t172800\tIN\tNS\td.gtld-servers.net.</span><br><span class=\"line\">com.\t\t\t172800\tIN\tNS\tb.gtld-servers.net.</span><br><span class=\"line\">com.\t\t\t172800\tIN\tNS\tj.gtld-servers.net.</span><br><span class=\"line\">com.\t\t\t172800\tIN\tNS\tf.gtld-servers.net.</span><br><span class=\"line\">com.\t\t\t172800\tIN\tNS\tg.gtld-servers.net.</span><br><span class=\"line\">com.\t\t\t172800\tIN\tNS\tl.gtld-servers.net.</span><br><span class=\"line\">com.\t\t\t172800\tIN\tNS\tk.gtld-servers.net.</span><br><span class=\"line\">com.\t\t\t172800\tIN\tNS\th.gtld-servers.net.</span><br><span class=\"line\">com.\t\t\t172800\tIN\tNS\ti.gtld-servers.net.</span><br><span class=\"line\">com.\t\t\t172800\tIN\tNS\ta.gtld-servers.net.</span><br><span class=\"line\">com.\t\t\t172800\tIN\tNS\tc.gtld-servers.net.</span><br><span class=\"line\">;; Received 504 bytes from 192.5.5.241#53(192.5.5.241) in 38 ms</span><br><span class=\"line\"></span><br><span class=\"line\">;; connection timed out; no servers could be reached</span><br><span class=\"line\">--- ~ »</span><br></pre></td></tr></table></figure>\n<h1 id=\"几种域名解析方式\"><a href=\"#几种域名解析方式\" class=\"headerlink\" title=\"几种域名解析方式\"></a>几种域名解析方式</h1><ul>\n<li>A记录，指定域名对应IP。</li>\n<li>MX记录，表示Mail Exchange，将某个域名下邮件服务器指向自己Mail Server。正常通过Web请求仍然解析A记录IP。</li>\n<li>CNAME记录，Canonical Name(别名解析)。</li>\n<li>NS记录，为某个域名指定DNS解析服务器。</li>\n<li>TXT记录，为某个主机名或域名设置说明。</li>\n</ul>\n","excerpt":"","more":"<p>当用户在浏览器输入www.abc.com，DNS解析将会有将近10个步骤。</p>\n<ol>\n<li>浏览器检查缓存有没有该域名对应的IP。如果有，这个解析过程就结束。浏览器缓存域名是有限制的，不仅大小有限制，时间也有限制，通过TTL属性设置域名缓存时间。</li>\n<li>浏览器缓存中没有，检查操作系统缓存中是否有解析结果。如果有，解析结束。没有的话，请求域名服务器解析该域名。</li>\n<li><p>网络配置有配置DNS服务器地址，操作系统把域名发送给这里的LDNS。Linux下通过以下命令查看。  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cat /etc/resolv.conf</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>LDNS未命中，直接到Root Server域名服务器请求解析。</p>\n</li>\n<li>根域名服务器返回本地域名服务器一个服务器地址(gTLD Server)。gTLD是国际顶级域名服务器，如.com、.cn、.org等，全球只有13台左右。</li>\n<li>本地域名服务器再向上一步返回的gTLD服务器发送请求。</li>\n<li>gTLD服务器查找并返回此域名对应的Name Server域名服务器地址，这个Name Server通常就是你注册的域名服务器。</li>\n<li>Name Server域名服务器查询存储的域名和IP映射关系，正常情况下查询到目标IP记录，连同一个TTL值返回给DNS Server域名服务器。</li>\n<li>返回该域名对应的IP和TTL值，Local DNS Server会缓存该记录。</li>\n<li>解析结果返回给用户，用户根据TTL值缓存这个记录。</li>\n</ol>\n<p>实际过程中，可能不止这个10个步骤，如Name Server有多级或者有个GTM负载均衡控制，这都会影响域名解析的过程。</p>\n<h1 id=\"跟踪域名解析过程\"><a href=\"#跟踪域名解析过程\" class=\"headerlink\" title=\"跟踪域名解析过程\"></a>跟踪域名解析过程</h1><h2 id=\"dig\"><a href=\"#dig\" class=\"headerlink\" title=\"dig\"></a>dig</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">--- ~ » dig www.google.com</span><br><span class=\"line\"></span><br><span class=\"line\">; &lt;&lt;&gt;&gt; DiG 9.8.3-P1 &lt;&lt;&gt;&gt; www.google.com</span><br><span class=\"line\">;; global options: +cmd</span><br><span class=\"line\">;; Got answer:</span><br><span class=\"line\">;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 50606</span><br><span class=\"line\">;; flags: qr rd ra; QUERY: 1, ANSWER: 16, AUTHORITY: 0, ADDITIONAL: 0</span><br><span class=\"line\"></span><br><span class=\"line\">;; QUESTION SECTION:</span><br><span class=\"line\">;www.google.com.\t\t\tIN\tA</span><br><span class=\"line\"></span><br><span class=\"line\">;; ANSWER SECTION:</span><br><span class=\"line\">www.google.com.\t\t299\tIN\tA\t61.238.239.35</span><br><span class=\"line\">www.google.com.\t\t299\tIN\tA\t61.238.239.20</span><br><span class=\"line\">www.google.com.\t\t299\tIN\tA\t61.238.239.24</span><br><span class=\"line\">www.google.com.\t\t299\tIN\tA\t61.238.239.59</span><br><span class=\"line\">www.google.com.\t\t299\tIN\tA\t61.238.239.29</span><br><span class=\"line\">www.google.com.\t\t299\tIN\tA\t61.238.239.30</span><br><span class=\"line\">www.google.com.\t\t299\tIN\tA\t61.238.239.45</span><br><span class=\"line\">www.google.com.\t\t299\tIN\tA\t61.238.239.40</span><br><span class=\"line\">www.google.com.\t\t299\tIN\tA\t61.238.239.55</span><br><span class=\"line\">www.google.com.\t\t299\tIN\tA\t61.238.239.34</span><br><span class=\"line\">www.google.com.\t\t299\tIN\tA\t61.238.239.44</span><br><span class=\"line\">www.google.com.\t\t299\tIN\tA\t61.238.239.49</span><br><span class=\"line\">www.google.com.\t\t299\tIN\tA\t61.238.239.54</span><br><span class=\"line\">www.google.com.\t\t299\tIN\tA\t61.238.239.25</span><br><span class=\"line\">www.google.com.\t\t299\tIN\tA\t61.238.239.39</span><br><span class=\"line\">www.google.com.\t\t299\tIN\tA\t61.238.239.50</span><br><span class=\"line\"></span><br><span class=\"line\">;; Query time: 61 msec</span><br><span class=\"line\">;; SERVER: 8.8.8.8#53(8.8.8.8)</span><br><span class=\"line\">;; WHEN: Wed May 11 21:04:56 2016</span><br><span class=\"line\">;; MSG SIZE  rcvd: 288</span><br><span class=\"line\"></span><br><span class=\"line\">--- ~ »</span><br></pre></td></tr></table></figure>\n<h2 id=\"dig-cmd\"><a href=\"#dig-cmd\" class=\"headerlink\" title=\"dig +cmd\"></a>dig +cmd</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">--- ~ » dig +printcmd www.taobao.com</span><br><span class=\"line\">Invalid option: +printcmd</span><br><span class=\"line\">Usage:  dig [@global-server] [domain] [q-type] [q-class] &#123;q-opt&#125;</span><br><span class=\"line\">            &#123;global-d-opt&#125; host [@local-server] &#123;local-d-opt&#125;</span><br><span class=\"line\">            [ host [@local-server] &#123;local-d-opt&#125; [...]]</span><br><span class=\"line\"></span><br><span class=\"line\">Use &quot;dig -h&quot; (or &quot;dig -h | more&quot;) for complete list of options</span><br><span class=\"line\">--- ~ » dig +cmd www.taobao.com                                                                                                                                        1 ↵</span><br><span class=\"line\"></span><br><span class=\"line\">; &lt;&lt;&gt;&gt; DiG 9.8.3-P1 &lt;&lt;&gt;&gt; +cmd www.taobao.com</span><br><span class=\"line\">;; global options: +cmd</span><br><span class=\"line\">;; Got answer:</span><br><span class=\"line\">;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 62882</span><br><span class=\"line\">;; flags: qr rd ra; QUERY: 1, ANSWER: 2, AUTHORITY: 0, ADDITIONAL: 0</span><br><span class=\"line\"></span><br><span class=\"line\">;; QUESTION SECTION:</span><br><span class=\"line\">;www.taobao.com.\t\t\tIN\tA</span><br><span class=\"line\"></span><br><span class=\"line\">;; ANSWER SECTION:</span><br><span class=\"line\">www.taobao.com.\t\t71\tIN\tCNAME\twww.taobao.com.danuoyi.tbcache.com.</span><br><span class=\"line\">www.taobao.com.danuoyi.tbcache.com. 599\tIN A\t205.204.104.227</span><br><span class=\"line\"></span><br><span class=\"line\">;; Query time: 73 msec</span><br><span class=\"line\">;; SERVER: 8.8.8.8#53(8.8.8.8)</span><br><span class=\"line\">;; WHEN: Wed May 11 21:07:41 2016</span><br><span class=\"line\">;; MSG SIZE  rcvd: 93</span><br><span class=\"line\"></span><br><span class=\"line\">--- ~ »</span><br></pre></td></tr></table></figure>\n<h2 id=\"dig-trace\"><a href=\"#dig-trace\" class=\"headerlink\" title=\"dig +trace\"></a>dig +trace</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">--- ~ » dig www.google.com +trace                                                                                                                                      9 ↵</span><br><span class=\"line\"></span><br><span class=\"line\">; &lt;&lt;&gt;&gt; DiG 9.8.3-P1 &lt;&lt;&gt;&gt; www.google.com +trace</span><br><span class=\"line\">;; global options: +cmd</span><br><span class=\"line\">.\t\t\t5236\tIN\tNS\ta.root-servers.net.</span><br><span class=\"line\">.\t\t\t5236\tIN\tNS\tb.root-servers.net.</span><br><span class=\"line\">.\t\t\t5236\tIN\tNS\tc.root-servers.net.</span><br><span class=\"line\">.\t\t\t5236\tIN\tNS\td.root-servers.net.</span><br><span class=\"line\">.\t\t\t5236\tIN\tNS\te.root-servers.net.</span><br><span class=\"line\">.\t\t\t5236\tIN\tNS\tf.root-servers.net.</span><br><span class=\"line\">.\t\t\t5236\tIN\tNS\tg.root-servers.net.</span><br><span class=\"line\">.\t\t\t5236\tIN\tNS\th.root-servers.net.</span><br><span class=\"line\">.\t\t\t5236\tIN\tNS\ti.root-servers.net.</span><br><span class=\"line\">.\t\t\t5236\tIN\tNS\tj.root-servers.net.</span><br><span class=\"line\">.\t\t\t5236\tIN\tNS\tk.root-servers.net.</span><br><span class=\"line\">.\t\t\t5236\tIN\tNS\tl.root-servers.net.</span><br><span class=\"line\">.\t\t\t5236\tIN\tNS\tm.root-servers.net.</span><br><span class=\"line\">;; Received 228 bytes from 8.8.8.8#53(8.8.8.8) in 63 ms</span><br><span class=\"line\"></span><br><span class=\"line\">com.\t\t\t172800\tIN\tNS\tm.gtld-servers.net.</span><br><span class=\"line\">com.\t\t\t172800\tIN\tNS\te.gtld-servers.net.</span><br><span class=\"line\">com.\t\t\t172800\tIN\tNS\td.gtld-servers.net.</span><br><span class=\"line\">com.\t\t\t172800\tIN\tNS\tb.gtld-servers.net.</span><br><span class=\"line\">com.\t\t\t172800\tIN\tNS\tj.gtld-servers.net.</span><br><span class=\"line\">com.\t\t\t172800\tIN\tNS\tf.gtld-servers.net.</span><br><span class=\"line\">com.\t\t\t172800\tIN\tNS\tg.gtld-servers.net.</span><br><span class=\"line\">com.\t\t\t172800\tIN\tNS\tl.gtld-servers.net.</span><br><span class=\"line\">com.\t\t\t172800\tIN\tNS\tk.gtld-servers.net.</span><br><span class=\"line\">com.\t\t\t172800\tIN\tNS\th.gtld-servers.net.</span><br><span class=\"line\">com.\t\t\t172800\tIN\tNS\ti.gtld-servers.net.</span><br><span class=\"line\">com.\t\t\t172800\tIN\tNS\ta.gtld-servers.net.</span><br><span class=\"line\">com.\t\t\t172800\tIN\tNS\tc.gtld-servers.net.</span><br><span class=\"line\">;; Received 504 bytes from 192.5.5.241#53(192.5.5.241) in 38 ms</span><br><span class=\"line\"></span><br><span class=\"line\">;; connection timed out; no servers could be reached</span><br><span class=\"line\">--- ~ »</span><br></pre></td></tr></table></figure>\n<h1 id=\"几种域名解析方式\"><a href=\"#几种域名解析方式\" class=\"headerlink\" title=\"几种域名解析方式\"></a>几种域名解析方式</h1><ul>\n<li>A记录，指定域名对应IP。</li>\n<li>MX记录，表示Mail Exchange，将某个域名下邮件服务器指向自己Mail Server。正常通过Web请求仍然解析A记录IP。</li>\n<li>CNAME记录，Canonical Name(别名解析)。</li>\n<li>NS记录，为某个域名指定DNS解析服务器。</li>\n<li>TXT记录，为某个主机名或域名设置说明。</li>\n</ul>\n"},{"title":"Java8 -- 初识lambda","date":"2016-12-12T16:00:00.000Z","_content":"\n#\tJava8新特性 -- lambda表达式\n\n###\t新引入概念\n\n*\t默认接口方法\n\nJDK8之前，接口不能定义任何实现，现在可以添加默认方法允许为接口方法定义一个或多个默认实现。\n\n```Java\npublic interface A {\n\n    default void hello() {\n        System.out.println(\"This is A .\");\n    }\n    \n}\n```\n\n*\t函数式接口\n\n函数式接口是指仅指定了一个抽象方法的接口，例如 Runnable 或者 Comparator。\n\n接着上面默认接口方法，当一个接口仅定义了唯一一个方法，就称之为函数式接口，其功能由其唯一方法定义。 \n\n可以在任意函数式接口上标注 @FunctionalInterface ，这样做有两个好处：\t\n1.\t编译器会检查标注改注解的实体，检查它是否是只包含一个抽象方法的接口。\n2.\tjavadoc 页面上也会包含一条说明，说明这个接口是一个函数式接口。\n\nps:\t该注解并不要求强制使用，使用注解会让代码看上去更清楚。\n \n \n##\tlambda表达式是什么\n\nlambda表达式本质是一个匿名方法，但仅限于实现由函数式接口定义的方法。因此，lambda表达式会产生一个匿名类，常被称为闭包。\n\nlambda表达式是一段可以传递的代码，因此它可以被执行一次或多次。\n\n函数式接口可以指定Object定义的任何公有方法，例如equals()，而不影响其作为“函数式接口”的状态。\n\n##\tlambda语法特征\n\n1.\t运算符 ->\n2. \t没有方法名称\n3. \t形参类型推导\n4. \t返回类型推导\n\n\n##\t示例\n```Java\npublic class Sample0 {\n\n    class S1 implements Runnable {\n        @Override\n        public void run() {\n            System.out.println(\"This is S1\");\n        }\n    }\n\n\n    public static void main(String[] args) {\n        test1();\n\n        test2();\n    }\n\n\n    static void test1() {\n        Sample0 sample0 = new Sample0();\n        S1 s1 = sample0.new S1();\n        s1.run();\n\n        Runnable abc = () -> System.out.println(\"This is lambda\");\n        abc.run();\n    }\n\n    static void test2() {\n        List<Integer> list = new ArrayList<>();\n        for (int i = 0; i < 10; i++) {\n            list.add(i);\n        }\n\n        list.forEach(System.out::println);\n    }\n}\n```\n\n\n```Java\npublic interface MyValue {\n\n    double myValue();\n\n}\n```\n\n```Java\npublic interface MyValue2 {\n\n    double myValue(int i);\n\n}\n```\n\n```Java\npublic class Sample1 {\n\n    private static MyValue myValue;\n\n    public static void main(String[] args) {\n        myValue = () -> Math.random();\n\n        MyValue _myValue = () -> 1.1;\n\n\n        MyValue2 myValue2 = n -> n * 100;\n\n        MyValue2 _myValue2 = (n) -> n * 100;\n    }\n}\n```\n\n##\t变量捕获\n\nlambda表达式和块lambda表达式作用域访问和普通作用域基本一致，但是，当lambda表达式使用其外层作用域内定义的局部变量时，会产生一种特殊的情况，成为变量捕获。这种情况下，lambda表达式只能使用实际上为final的局部变量，修改局部变量会移除其实质上的final状态(可以不显示声明final关键字)，从而使捕获该变量变得不合法。\n\nlambda表达式可以使用和修改其调用类的实例变量，只是不能使用其外层作用域中的局部变量，除非该变量实质上是final。\n\n```Java\npublic interface MyFunc {\n\n    int func(int n);\n}\n```\n\n```Java\npublic class Sample2 {\n\n    public static void main(String[] args) {\n        int num = 10;\n\n        MyFunc myFunc = n -> {\n            int res = n + num;\n            return res;\n        };\n\n\t\t//输出18\n        System.out.println(myFunc.func(8));\n\t\t//非法 编译器检查错误\n       // num = 9;\n    }\n}\n```\n\n##\t方法引用\n\n方法引用提供了一种引用方法而不执行方法的方式。该特性与lambda表达式相关，因为它也需要由兼容的函数式接口构成的目标类型上下文。\n\n###\t静态方法的方法引用\n\n####\t语法\nClassName::methodName\n\n类名与方法名之间使用双冒号分隔开。::是JDK8新增的分隔符，专门用于此目的。\n\n```Java\npublic interface IntPredicate {\n\n    boolean test(int i);\n}\n```\n\n```Java\npublic class MyIntPredicates {\n\n    static boolean isPrime(int n) {\n        if (n < 2)\n            return false;\n\n        for (int i = 2; i < n / i; i++) {\n            if (n % i == 0)\n                return false;\n        }\n\n        return true;\n    }\n\n    static boolean isEven(int n) {\n        return n % 2 == 0;\n    }\n\n    static boolean isPositive(int n) {\n        return n > 0;\n    }\n}\n```\n\n```Java\npublic class Sample1 {\n\n    static boolean numTest(IntPredicate p, int v) {\n        return p.test(v);\n    }\n\n    public static void main(String[] args) {\n        boolean result;\n\n        result = numTest(MyIntPredicates::isPrime, 17);\n\n        result = numTest(MyIntPredicates::isEven, 12);\n\n        result = numTest(MyIntPredicates::isPositive, 11);\n    }\n}\n\n```\n\n注意\n```Java\nresult = numTest(MyIntPredicates::isPrime, 17);\n```\n这里将对静态方法 isPrime() 引用传递给了 numTest() 方法的第一个参数，这是可行的，因为 isPrime 与 IntPredicate 函数式接口兼容( 其中 isPrime 提供了 IntPredicate 的 test() 方法的实现)。\n\n###\t实例方法的方法引用\n\n####\t语法\n\nobjRef::methodName\n\n语法与静态方法语法类似，只不过这里是对象引用，而不是类名。\n\n```Java\npublic interface IntPredicate {\n\n    boolean test(int i);\n}\n```\n\n```Java\npublic class MyIntNum {\n\n    private int v;\n\n    MyIntNum(int x) {\n        this.v = x;\n    }\n\n    int getNum() {\n        return v;\n    }\n\n    boolean isFactor(int n) {\n        return (v % n) == 0;\n    }\n}\n```\n\n```Java\npublic class Sample2 {\n\n    public static void main(String[] args) {\n        boolean result;\n\n        MyIntNum myIntNum = new MyIntNum(12);\n\n        MyIntNum myIntNum2 = new MyIntNum(16);\n\n        IntPredicate ip = myIntNum::isFactor;\n        result = ip.test(3);\n\n\n        ip = myIntNum2::isFactor;\n        result = ip.test(3);\n\n    }\n}\n```\n\n###\t构造函数引用\n\n####\t语法\nclassname::new\n\n```Java\npublic interface MyFunc {\n\n    MyClass func(String s);\n}\n```\n\n```Java\npublic class MyClass {\n\n    MyClass(String str) {\n        this.str = str;\n    }\n\n    MyClass() {\n        this.str = \"\";\n    }\n\n    private String str;\n\n    public String getStr() {\n        return str;\n    }\n\n    public void setStr(String str) {\n        this.str = str;\n    }\n}\n```\n\n```Java\npublic class Sample3 {\n\n    public static void main(String[] args) {\n        MyFunc myFunc = MyClass::new;\n\n        MyClass mc = myFunc.func(\"test\");\n\n        System.out.println(mc.getStr());\n    }\n}\n```\n\n表达式 MyClass:new 创建了对 MyClass 构造函数的引用，并不针对哪个构造函数。后面的 func() 方法接受一个 String 类型的形参，所以被引用的构造函数是 MyClass(String str)。\n\n###\t预定义函数式接口\n\nJDK8 中包含了新包 java.util.function，其中提供了一些预定义的函数式接口。现在 Java8 本身API使用了这些接口，任何一个 lambda 表达式都可以等价转换成现在所使用API中对应的函数式接口。\n\n\n","source":"_posts/Java Web/Java8新特性 -- 初识lambda.md","raw":"---\ntitle: Java8 -- 初识lambda\ndate: 2016-12-13\ncategories: Java Web\ntags: \n- Java8\n---\n\n#\tJava8新特性 -- lambda表达式\n\n###\t新引入概念\n\n*\t默认接口方法\n\nJDK8之前，接口不能定义任何实现，现在可以添加默认方法允许为接口方法定义一个或多个默认实现。\n\n```Java\npublic interface A {\n\n    default void hello() {\n        System.out.println(\"This is A .\");\n    }\n    \n}\n```\n\n*\t函数式接口\n\n函数式接口是指仅指定了一个抽象方法的接口，例如 Runnable 或者 Comparator。\n\n接着上面默认接口方法，当一个接口仅定义了唯一一个方法，就称之为函数式接口，其功能由其唯一方法定义。 \n\n可以在任意函数式接口上标注 @FunctionalInterface ，这样做有两个好处：\t\n1.\t编译器会检查标注改注解的实体，检查它是否是只包含一个抽象方法的接口。\n2.\tjavadoc 页面上也会包含一条说明，说明这个接口是一个函数式接口。\n\nps:\t该注解并不要求强制使用，使用注解会让代码看上去更清楚。\n \n \n##\tlambda表达式是什么\n\nlambda表达式本质是一个匿名方法，但仅限于实现由函数式接口定义的方法。因此，lambda表达式会产生一个匿名类，常被称为闭包。\n\nlambda表达式是一段可以传递的代码，因此它可以被执行一次或多次。\n\n函数式接口可以指定Object定义的任何公有方法，例如equals()，而不影响其作为“函数式接口”的状态。\n\n##\tlambda语法特征\n\n1.\t运算符 ->\n2. \t没有方法名称\n3. \t形参类型推导\n4. \t返回类型推导\n\n\n##\t示例\n```Java\npublic class Sample0 {\n\n    class S1 implements Runnable {\n        @Override\n        public void run() {\n            System.out.println(\"This is S1\");\n        }\n    }\n\n\n    public static void main(String[] args) {\n        test1();\n\n        test2();\n    }\n\n\n    static void test1() {\n        Sample0 sample0 = new Sample0();\n        S1 s1 = sample0.new S1();\n        s1.run();\n\n        Runnable abc = () -> System.out.println(\"This is lambda\");\n        abc.run();\n    }\n\n    static void test2() {\n        List<Integer> list = new ArrayList<>();\n        for (int i = 0; i < 10; i++) {\n            list.add(i);\n        }\n\n        list.forEach(System.out::println);\n    }\n}\n```\n\n\n```Java\npublic interface MyValue {\n\n    double myValue();\n\n}\n```\n\n```Java\npublic interface MyValue2 {\n\n    double myValue(int i);\n\n}\n```\n\n```Java\npublic class Sample1 {\n\n    private static MyValue myValue;\n\n    public static void main(String[] args) {\n        myValue = () -> Math.random();\n\n        MyValue _myValue = () -> 1.1;\n\n\n        MyValue2 myValue2 = n -> n * 100;\n\n        MyValue2 _myValue2 = (n) -> n * 100;\n    }\n}\n```\n\n##\t变量捕获\n\nlambda表达式和块lambda表达式作用域访问和普通作用域基本一致，但是，当lambda表达式使用其外层作用域内定义的局部变量时，会产生一种特殊的情况，成为变量捕获。这种情况下，lambda表达式只能使用实际上为final的局部变量，修改局部变量会移除其实质上的final状态(可以不显示声明final关键字)，从而使捕获该变量变得不合法。\n\nlambda表达式可以使用和修改其调用类的实例变量，只是不能使用其外层作用域中的局部变量，除非该变量实质上是final。\n\n```Java\npublic interface MyFunc {\n\n    int func(int n);\n}\n```\n\n```Java\npublic class Sample2 {\n\n    public static void main(String[] args) {\n        int num = 10;\n\n        MyFunc myFunc = n -> {\n            int res = n + num;\n            return res;\n        };\n\n\t\t//输出18\n        System.out.println(myFunc.func(8));\n\t\t//非法 编译器检查错误\n       // num = 9;\n    }\n}\n```\n\n##\t方法引用\n\n方法引用提供了一种引用方法而不执行方法的方式。该特性与lambda表达式相关，因为它也需要由兼容的函数式接口构成的目标类型上下文。\n\n###\t静态方法的方法引用\n\n####\t语法\nClassName::methodName\n\n类名与方法名之间使用双冒号分隔开。::是JDK8新增的分隔符，专门用于此目的。\n\n```Java\npublic interface IntPredicate {\n\n    boolean test(int i);\n}\n```\n\n```Java\npublic class MyIntPredicates {\n\n    static boolean isPrime(int n) {\n        if (n < 2)\n            return false;\n\n        for (int i = 2; i < n / i; i++) {\n            if (n % i == 0)\n                return false;\n        }\n\n        return true;\n    }\n\n    static boolean isEven(int n) {\n        return n % 2 == 0;\n    }\n\n    static boolean isPositive(int n) {\n        return n > 0;\n    }\n}\n```\n\n```Java\npublic class Sample1 {\n\n    static boolean numTest(IntPredicate p, int v) {\n        return p.test(v);\n    }\n\n    public static void main(String[] args) {\n        boolean result;\n\n        result = numTest(MyIntPredicates::isPrime, 17);\n\n        result = numTest(MyIntPredicates::isEven, 12);\n\n        result = numTest(MyIntPredicates::isPositive, 11);\n    }\n}\n\n```\n\n注意\n```Java\nresult = numTest(MyIntPredicates::isPrime, 17);\n```\n这里将对静态方法 isPrime() 引用传递给了 numTest() 方法的第一个参数，这是可行的，因为 isPrime 与 IntPredicate 函数式接口兼容( 其中 isPrime 提供了 IntPredicate 的 test() 方法的实现)。\n\n###\t实例方法的方法引用\n\n####\t语法\n\nobjRef::methodName\n\n语法与静态方法语法类似，只不过这里是对象引用，而不是类名。\n\n```Java\npublic interface IntPredicate {\n\n    boolean test(int i);\n}\n```\n\n```Java\npublic class MyIntNum {\n\n    private int v;\n\n    MyIntNum(int x) {\n        this.v = x;\n    }\n\n    int getNum() {\n        return v;\n    }\n\n    boolean isFactor(int n) {\n        return (v % n) == 0;\n    }\n}\n```\n\n```Java\npublic class Sample2 {\n\n    public static void main(String[] args) {\n        boolean result;\n\n        MyIntNum myIntNum = new MyIntNum(12);\n\n        MyIntNum myIntNum2 = new MyIntNum(16);\n\n        IntPredicate ip = myIntNum::isFactor;\n        result = ip.test(3);\n\n\n        ip = myIntNum2::isFactor;\n        result = ip.test(3);\n\n    }\n}\n```\n\n###\t构造函数引用\n\n####\t语法\nclassname::new\n\n```Java\npublic interface MyFunc {\n\n    MyClass func(String s);\n}\n```\n\n```Java\npublic class MyClass {\n\n    MyClass(String str) {\n        this.str = str;\n    }\n\n    MyClass() {\n        this.str = \"\";\n    }\n\n    private String str;\n\n    public String getStr() {\n        return str;\n    }\n\n    public void setStr(String str) {\n        this.str = str;\n    }\n}\n```\n\n```Java\npublic class Sample3 {\n\n    public static void main(String[] args) {\n        MyFunc myFunc = MyClass::new;\n\n        MyClass mc = myFunc.func(\"test\");\n\n        System.out.println(mc.getStr());\n    }\n}\n```\n\n表达式 MyClass:new 创建了对 MyClass 构造函数的引用，并不针对哪个构造函数。后面的 func() 方法接受一个 String 类型的形参，所以被引用的构造函数是 MyClass(String str)。\n\n###\t预定义函数式接口\n\nJDK8 中包含了新包 java.util.function，其中提供了一些预定义的函数式接口。现在 Java8 本身API使用了这些接口，任何一个 lambda 表达式都可以等价转换成现在所使用API中对应的函数式接口。\n\n\n","slug":"Java Web/Java8新特性 -- 初识lambda","published":1,"updated":"2019-05-17T05:57:58.554Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1j8f2h5000l7h9mi55tg8s5","content":"<h1 id=\"Java8新特性-–-lambda表达式\"><a href=\"#Java8新特性-–-lambda表达式\" class=\"headerlink\" title=\"Java8新特性 – lambda表达式\"></a>Java8新特性 – lambda表达式</h1><h3 id=\"新引入概念\"><a href=\"#新引入概念\" class=\"headerlink\" title=\"新引入概念\"></a>新引入概念</h3><ul>\n<li>默认接口方法</li>\n</ul>\n<p>JDK8之前，接口不能定义任何实现，现在可以添加默认方法允许为接口方法定义一个或多个默认实现。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">default</span> <span class=\"keyword\">void</span> <span class=\"title\">hello</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"This is A .\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>函数式接口</li>\n</ul>\n<p>函数式接口是指仅指定了一个抽象方法的接口，例如 Runnable 或者 Comparator。</p>\n<p>接着上面默认接口方法，当一个接口仅定义了唯一一个方法，就称之为函数式接口，其功能由其唯一方法定义。 </p>\n<p>可以在任意函数式接口上标注 @FunctionalInterface ，这样做有两个好处：    </p>\n<ol>\n<li>编译器会检查标注改注解的实体，检查它是否是只包含一个抽象方法的接口。</li>\n<li>javadoc 页面上也会包含一条说明，说明这个接口是一个函数式接口。</li>\n</ol>\n<p>ps:    该注解并不要求强制使用，使用注解会让代码看上去更清楚。</p>\n<h2 id=\"lambda表达式是什么\"><a href=\"#lambda表达式是什么\" class=\"headerlink\" title=\"lambda表达式是什么\"></a>lambda表达式是什么</h2><p>lambda表达式本质是一个匿名方法，但仅限于实现由函数式接口定义的方法。因此，lambda表达式会产生一个匿名类，常被称为闭包。</p>\n<p>lambda表达式是一段可以传递的代码，因此它可以被执行一次或多次。</p>\n<p>函数式接口可以指定Object定义的任何公有方法，例如equals()，而不影响其作为“函数式接口”的状态。</p>\n<h2 id=\"lambda语法特征\"><a href=\"#lambda语法特征\" class=\"headerlink\" title=\"lambda语法特征\"></a>lambda语法特征</h2><ol>\n<li>运算符 -&gt;</li>\n<li>没有方法名称</li>\n<li>形参类型推导</li>\n<li>返回类型推导</li>\n</ol>\n<h2 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sample0</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">S1</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"This is S1\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        test1();</span><br><span class=\"line\"></span><br><span class=\"line\">        test2();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">test1</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Sample0 sample0 = <span class=\"keyword\">new</span> Sample0();</span><br><span class=\"line\">        S1 s1 = sample0.new S1();</span><br><span class=\"line\">        s1.run();</span><br><span class=\"line\"></span><br><span class=\"line\">        Runnable abc = () -&gt; System.out.println(<span class=\"string\">\"This is lambda\"</span>);</span><br><span class=\"line\">        abc.run();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">test2</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        List&lt;Integer&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">            list.add(i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        list.forEach(System.out::println);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">MyValue</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">double</span> <span class=\"title\">myValue</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">MyValue2</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">double</span> <span class=\"title\">myValue</span><span class=\"params\">(<span class=\"keyword\">int</span> i)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sample1</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> MyValue myValue;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        myValue = () -&gt; Math.random();</span><br><span class=\"line\"></span><br><span class=\"line\">        MyValue _myValue = () -&gt; <span class=\"number\">1.1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        MyValue2 myValue2 = n -&gt; n * <span class=\"number\">100</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        MyValue2 _myValue2 = (n) -&gt; n * <span class=\"number\">100</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"变量捕获\"><a href=\"#变量捕获\" class=\"headerlink\" title=\"变量捕获\"></a>变量捕获</h2><p>lambda表达式和块lambda表达式作用域访问和普通作用域基本一致，但是，当lambda表达式使用其外层作用域内定义的局部变量时，会产生一种特殊的情况，成为变量捕获。这种情况下，lambda表达式只能使用实际上为final的局部变量，修改局部变量会移除其实质上的final状态(可以不显示声明final关键字)，从而使捕获该变量变得不合法。</p>\n<p>lambda表达式可以使用和修改其调用类的实例变量，只是不能使用其外层作用域中的局部变量，除非该变量实质上是final。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">MyFunc</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">func</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sample2</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> num = <span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        MyFunc myFunc = n -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> res = n + num;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//输出18</span></span><br><span class=\"line\">        System.out.println(myFunc.func(<span class=\"number\">8</span>));</span><br><span class=\"line\">\t\t<span class=\"comment\">//非法 编译器检查错误</span></span><br><span class=\"line\">       <span class=\"comment\">// num = 9;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"方法引用\"><a href=\"#方法引用\" class=\"headerlink\" title=\"方法引用\"></a>方法引用</h2><p>方法引用提供了一种引用方法而不执行方法的方式。该特性与lambda表达式相关，因为它也需要由兼容的函数式接口构成的目标类型上下文。</p>\n<h3 id=\"静态方法的方法引用\"><a href=\"#静态方法的方法引用\" class=\"headerlink\" title=\"静态方法的方法引用\"></a>静态方法的方法引用</h3><h4 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h4><p>ClassName::methodName</p>\n<p>类名与方法名之间使用双冒号分隔开。::是JDK8新增的分隔符，专门用于此目的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">IntPredicate</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">test</span><span class=\"params\">(<span class=\"keyword\">int</span> i)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyIntPredicates</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isPrime</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n &lt; <span class=\"number\">2</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">2</span>; i &lt; n / i; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (n % i == <span class=\"number\">0</span>)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isEven</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> n % <span class=\"number\">2</span> == <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isPositive</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> n &gt; <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sample1</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">boolean</span> <span class=\"title\">numTest</span><span class=\"params\">(IntPredicate p, <span class=\"keyword\">int</span> v)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> p.test(v);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> result;</span><br><span class=\"line\"></span><br><span class=\"line\">        result = numTest(MyIntPredicates::isPrime, <span class=\"number\">17</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        result = numTest(MyIntPredicates::isEven, <span class=\"number\">12</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        result = numTest(MyIntPredicates::isPositive, <span class=\"number\">11</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注意<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">result = numTest(MyIntPredicates::isPrime, <span class=\"number\">17</span>);</span><br></pre></td></tr></table></figure></p>\n<p>这里将对静态方法 isPrime() 引用传递给了 numTest() 方法的第一个参数，这是可行的，因为 isPrime 与 IntPredicate 函数式接口兼容( 其中 isPrime 提供了 IntPredicate 的 test() 方法的实现)。</p>\n<h3 id=\"实例方法的方法引用\"><a href=\"#实例方法的方法引用\" class=\"headerlink\" title=\"实例方法的方法引用\"></a>实例方法的方法引用</h3><h4 id=\"语法-1\"><a href=\"#语法-1\" class=\"headerlink\" title=\"语法\"></a>语法</h4><p>objRef::methodName</p>\n<p>语法与静态方法语法类似，只不过这里是对象引用，而不是类名。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">IntPredicate</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">test</span><span class=\"params\">(<span class=\"keyword\">int</span> i)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyIntNum</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> v;</span><br><span class=\"line\"></span><br><span class=\"line\">    MyIntNum(<span class=\"keyword\">int</span> x) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.v = x;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getNum</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> v;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">isFactor</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (v % n) == <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sample2</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> result;</span><br><span class=\"line\"></span><br><span class=\"line\">        MyIntNum myIntNum = <span class=\"keyword\">new</span> MyIntNum(<span class=\"number\">12</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        MyIntNum myIntNum2 = <span class=\"keyword\">new</span> MyIntNum(<span class=\"number\">16</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        IntPredicate ip = myIntNum::isFactor;</span><br><span class=\"line\">        result = ip.test(<span class=\"number\">3</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        ip = myIntNum2::isFactor;</span><br><span class=\"line\">        result = ip.test(<span class=\"number\">3</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"构造函数引用\"><a href=\"#构造函数引用\" class=\"headerlink\" title=\"构造函数引用\"></a>构造函数引用</h3><h4 id=\"语法-2\"><a href=\"#语法-2\" class=\"headerlink\" title=\"语法\"></a>语法</h4><p>classname::new</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">MyFunc</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">MyClass <span class=\"title\">func</span><span class=\"params\">(String s)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyClass</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    MyClass(String str) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.str = str;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    MyClass() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.str = <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String str;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getStr</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> str;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setStr</span><span class=\"params\">(String str)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.str = str;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sample3</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        MyFunc myFunc = MyClass::<span class=\"keyword\">new</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        MyClass mc = myFunc.func(<span class=\"string\">\"test\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(mc.getStr());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>表达式 MyClass:new 创建了对 MyClass 构造函数的引用，并不针对哪个构造函数。后面的 func() 方法接受一个 String 类型的形参，所以被引用的构造函数是 MyClass(String str)。</p>\n<h3 id=\"预定义函数式接口\"><a href=\"#预定义函数式接口\" class=\"headerlink\" title=\"预定义函数式接口\"></a>预定义函数式接口</h3><p>JDK8 中包含了新包 java.util.function，其中提供了一些预定义的函数式接口。现在 Java8 本身API使用了这些接口，任何一个 lambda 表达式都可以等价转换成现在所使用API中对应的函数式接口。</p>\n","excerpt":"","more":"<h1 id=\"Java8新特性-–-lambda表达式\"><a href=\"#Java8新特性-–-lambda表达式\" class=\"headerlink\" title=\"Java8新特性 – lambda表达式\"></a>Java8新特性 – lambda表达式</h1><h3 id=\"新引入概念\"><a href=\"#新引入概念\" class=\"headerlink\" title=\"新引入概念\"></a>新引入概念</h3><ul>\n<li>默认接口方法</li>\n</ul>\n<p>JDK8之前，接口不能定义任何实现，现在可以添加默认方法允许为接口方法定义一个或多个默认实现。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">default</span> <span class=\"keyword\">void</span> <span class=\"title\">hello</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"This is A .\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>函数式接口</li>\n</ul>\n<p>函数式接口是指仅指定了一个抽象方法的接口，例如 Runnable 或者 Comparator。</p>\n<p>接着上面默认接口方法，当一个接口仅定义了唯一一个方法，就称之为函数式接口，其功能由其唯一方法定义。 </p>\n<p>可以在任意函数式接口上标注 @FunctionalInterface ，这样做有两个好处：    </p>\n<ol>\n<li>编译器会检查标注改注解的实体，检查它是否是只包含一个抽象方法的接口。</li>\n<li>javadoc 页面上也会包含一条说明，说明这个接口是一个函数式接口。</li>\n</ol>\n<p>ps:    该注解并不要求强制使用，使用注解会让代码看上去更清楚。</p>\n<h2 id=\"lambda表达式是什么\"><a href=\"#lambda表达式是什么\" class=\"headerlink\" title=\"lambda表达式是什么\"></a>lambda表达式是什么</h2><p>lambda表达式本质是一个匿名方法，但仅限于实现由函数式接口定义的方法。因此，lambda表达式会产生一个匿名类，常被称为闭包。</p>\n<p>lambda表达式是一段可以传递的代码，因此它可以被执行一次或多次。</p>\n<p>函数式接口可以指定Object定义的任何公有方法，例如equals()，而不影响其作为“函数式接口”的状态。</p>\n<h2 id=\"lambda语法特征\"><a href=\"#lambda语法特征\" class=\"headerlink\" title=\"lambda语法特征\"></a>lambda语法特征</h2><ol>\n<li>运算符 -&gt;</li>\n<li>没有方法名称</li>\n<li>形参类型推导</li>\n<li>返回类型推导</li>\n</ol>\n<h2 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sample0</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">S1</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"This is S1\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        test1();</span><br><span class=\"line\"></span><br><span class=\"line\">        test2();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">test1</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Sample0 sample0 = <span class=\"keyword\">new</span> Sample0();</span><br><span class=\"line\">        S1 s1 = sample0.new S1();</span><br><span class=\"line\">        s1.run();</span><br><span class=\"line\"></span><br><span class=\"line\">        Runnable abc = () -&gt; System.out.println(<span class=\"string\">\"This is lambda\"</span>);</span><br><span class=\"line\">        abc.run();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">test2</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        List&lt;Integer&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">            list.add(i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        list.forEach(System.out::println);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">MyValue</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">double</span> <span class=\"title\">myValue</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">MyValue2</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">double</span> <span class=\"title\">myValue</span><span class=\"params\">(<span class=\"keyword\">int</span> i)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sample1</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> MyValue myValue;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        myValue = () -&gt; Math.random();</span><br><span class=\"line\"></span><br><span class=\"line\">        MyValue _myValue = () -&gt; <span class=\"number\">1.1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        MyValue2 myValue2 = n -&gt; n * <span class=\"number\">100</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        MyValue2 _myValue2 = (n) -&gt; n * <span class=\"number\">100</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"变量捕获\"><a href=\"#变量捕获\" class=\"headerlink\" title=\"变量捕获\"></a>变量捕获</h2><p>lambda表达式和块lambda表达式作用域访问和普通作用域基本一致，但是，当lambda表达式使用其外层作用域内定义的局部变量时，会产生一种特殊的情况，成为变量捕获。这种情况下，lambda表达式只能使用实际上为final的局部变量，修改局部变量会移除其实质上的final状态(可以不显示声明final关键字)，从而使捕获该变量变得不合法。</p>\n<p>lambda表达式可以使用和修改其调用类的实例变量，只是不能使用其外层作用域中的局部变量，除非该变量实质上是final。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">MyFunc</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">func</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sample2</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> num = <span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        MyFunc myFunc = n -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> res = n + num;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//输出18</span></span><br><span class=\"line\">        System.out.println(myFunc.func(<span class=\"number\">8</span>));</span><br><span class=\"line\">\t\t<span class=\"comment\">//非法 编译器检查错误</span></span><br><span class=\"line\">       <span class=\"comment\">// num = 9;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"方法引用\"><a href=\"#方法引用\" class=\"headerlink\" title=\"方法引用\"></a>方法引用</h2><p>方法引用提供了一种引用方法而不执行方法的方式。该特性与lambda表达式相关，因为它也需要由兼容的函数式接口构成的目标类型上下文。</p>\n<h3 id=\"静态方法的方法引用\"><a href=\"#静态方法的方法引用\" class=\"headerlink\" title=\"静态方法的方法引用\"></a>静态方法的方法引用</h3><h4 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h4><p>ClassName::methodName</p>\n<p>类名与方法名之间使用双冒号分隔开。::是JDK8新增的分隔符，专门用于此目的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">IntPredicate</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">test</span><span class=\"params\">(<span class=\"keyword\">int</span> i)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyIntPredicates</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isPrime</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n &lt; <span class=\"number\">2</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">2</span>; i &lt; n / i; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (n % i == <span class=\"number\">0</span>)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isEven</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> n % <span class=\"number\">2</span> == <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isPositive</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> n &gt; <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sample1</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">boolean</span> <span class=\"title\">numTest</span><span class=\"params\">(IntPredicate p, <span class=\"keyword\">int</span> v)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> p.test(v);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> result;</span><br><span class=\"line\"></span><br><span class=\"line\">        result = numTest(MyIntPredicates::isPrime, <span class=\"number\">17</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        result = numTest(MyIntPredicates::isEven, <span class=\"number\">12</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        result = numTest(MyIntPredicates::isPositive, <span class=\"number\">11</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注意<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">result = numTest(MyIntPredicates::isPrime, <span class=\"number\">17</span>);</span><br></pre></td></tr></table></figure></p>\n<p>这里将对静态方法 isPrime() 引用传递给了 numTest() 方法的第一个参数，这是可行的，因为 isPrime 与 IntPredicate 函数式接口兼容( 其中 isPrime 提供了 IntPredicate 的 test() 方法的实现)。</p>\n<h3 id=\"实例方法的方法引用\"><a href=\"#实例方法的方法引用\" class=\"headerlink\" title=\"实例方法的方法引用\"></a>实例方法的方法引用</h3><h4 id=\"语法-1\"><a href=\"#语法-1\" class=\"headerlink\" title=\"语法\"></a>语法</h4><p>objRef::methodName</p>\n<p>语法与静态方法语法类似，只不过这里是对象引用，而不是类名。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">IntPredicate</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">test</span><span class=\"params\">(<span class=\"keyword\">int</span> i)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyIntNum</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> v;</span><br><span class=\"line\"></span><br><span class=\"line\">    MyIntNum(<span class=\"keyword\">int</span> x) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.v = x;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getNum</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> v;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">isFactor</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (v % n) == <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sample2</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> result;</span><br><span class=\"line\"></span><br><span class=\"line\">        MyIntNum myIntNum = <span class=\"keyword\">new</span> MyIntNum(<span class=\"number\">12</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        MyIntNum myIntNum2 = <span class=\"keyword\">new</span> MyIntNum(<span class=\"number\">16</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        IntPredicate ip = myIntNum::isFactor;</span><br><span class=\"line\">        result = ip.test(<span class=\"number\">3</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        ip = myIntNum2::isFactor;</span><br><span class=\"line\">        result = ip.test(<span class=\"number\">3</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"构造函数引用\"><a href=\"#构造函数引用\" class=\"headerlink\" title=\"构造函数引用\"></a>构造函数引用</h3><h4 id=\"语法-2\"><a href=\"#语法-2\" class=\"headerlink\" title=\"语法\"></a>语法</h4><p>classname::new</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">MyFunc</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">MyClass <span class=\"title\">func</span><span class=\"params\">(String s)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyClass</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    MyClass(String str) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.str = str;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    MyClass() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.str = <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String str;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getStr</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> str;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setStr</span><span class=\"params\">(String str)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.str = str;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sample3</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        MyFunc myFunc = MyClass::<span class=\"keyword\">new</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        MyClass mc = myFunc.func(<span class=\"string\">\"test\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(mc.getStr());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>表达式 MyClass:new 创建了对 MyClass 构造函数的引用，并不针对哪个构造函数。后面的 func() 方法接受一个 String 类型的形参，所以被引用的构造函数是 MyClass(String str)。</p>\n<h3 id=\"预定义函数式接口\"><a href=\"#预定义函数式接口\" class=\"headerlink\" title=\"预定义函数式接口\"></a>预定义函数式接口</h3><p>JDK8 中包含了新包 java.util.function，其中提供了一些预定义的函数式接口。现在 Java8 本身API使用了这些接口，任何一个 lambda 表达式都可以等价转换成现在所使用API中对应的函数式接口。</p>\n"},{"title":"NIO工作机制","date":"2016-05-17T16:00:00.000Z","_content":"\n#\tNIO的工作方式\n\n##\tNIO工作机制\nNIO引入了Channel、Buffer和Selector，Channel是高速通道，Buffer是高速通道上的具体单位，Selector是调度器。当我们调用write()往SendQ写数据时，当一次写的数据超过SendQ长度时需要按照SendQ的长度进行分割，在这个过程中需要将用户空间数据和内核地址空间进行切换，而这个切换不是你可以控制的，但在Buffer中我们可以控制Buffer的容量、是否扩容以及如何扩容。\n\n调用Selector的静态工厂创建一个选择器，创建一个服务端的Channel，绑定到一个Socket对象，并把这个通信信道注册到选择器上，把这个通信信道设置为非阻塞模式。然后就可以调用Selector的selectedKeys方法来检查已经注册在这个选择器上的所有通信信道是否有需要的事件发生，如果与某个事件发生，将会返回所有的SelectionKey，通过这个对象的Channel方法就可以就可以取得这个通信信道对象，从而读取通信的数据，而这里读取的数据是Buffer，这个Buffer是我们可以控制的缓冲器。\n\n```\tjava\npublic void selector() throws IOException {\n        ByteBuffer buffer = ByteBuffer.allocate(1024);\n        Selector selector = Selector.open();\n        ServerSocketChannel ssc = ServerSocketChannel.open();\n        ssc.configureBlocking(false); //设置为非阻塞方式\n        ssc.register(selector, SelectionKey.OP_ACCEPT);\n        while (true) {\n            Set selectedKeys = selector.selectedKeys();\n            Iterator it = selectedKeys.iterator();\n            while (it.hasNext()) {\n                SelectionKey key = (SelectionKey) it.next();\n                if ((key.readyOps() & SelectionKey.OP_ACCEPT) == SelectionKey.OP_ACCEPT) {\n                    ServerSocketChannel ssChannel = (ServerSocketChannel) key.channel();\n                    SocketChannel sc = ssChannel.accept(); //接受到服务端请求\n                    sc.configureBlocking(false);\n                    sc.register(selector, SelectionKey.OP_READ);\n                    it.remove();\n                } else if ((key.readyOps() & SelectionKey.OP_READ) == SelectionKey.OP_READ) {\n                    SocketChannel sc = (SocketChannel) key.channel();\n                    while (true) {\n                        buffer.clear();\n                        int n = sc.read(buffer);\n                        if (n <= 0) {\n                            break;\n                        }\n                        buffer.flip();\n                    }\n                    it.remove();\n                }\n            }\n        }\n    }\n```\n\n在上面这段程序中，将Server端的监听连接请求的事件和处理请求的事件放在一个线程中，但是在事件应用中，我们通常会把它们放在两个线程中：一个线程专门负责监听客户端的连接请求，而且是以阻塞方式运行的；另外一个线程专门负责处理请求，这个专门处理请求的线程才会真正采用NIO的方式，像Web服务器Tomcat和Jetty都是使用这个处理方式。\n\nSelector可以同时监听一组通信信道(Channel)上的IO状态，前提是这个Selector已经注册到这些通信信道中。选择器Selector可以调用select()方法检查已经注册的通信信道上IO是否已经准备好，如果没有至少一个信道IO状态有变化，那么select方法会阻塞等待或在超时时间后返回0。如果有多个信道有数据，那么将会把这些数据分配到对应的数据Buffer中。所以关键的地方是，有一个线程来处理所有连接的数据交互，每个连接的数据交互都不是阻塞方式，所以可以同时处理大量的连续请求。\n\n##\tBuffer的工作方式\n把Buffer简单理解为一组基本数据类型的元素列表，它通过几个变量来保存这个数据的当前位置状态，也就是有4个索引，如下所示：   \n\t\t\n|索引|说明|\n|:---:|:---:| \n|capacity|缓冲区数组的总长度|\n|position|下一个要操作的数据元素位置|\n|limit|缓冲区数组中不可操作的下一个元素的位置，limit<=capacity|\n|mark|记录当前position的前一根位置或默认是0|\n\n通过Channel获取的IO数据首先要经过OS的Socket缓冲区，再将数据复制到Buffer中，这个OS缓冲区就是底层的TCP所关联的RecvQ或者SendQ队列，从OS缓冲区到用户缓冲区复制数据比较耗性能，Buffer提供了另外一种直接操作OS缓冲区的方式，即ByteBuffer.allocateDirector(size)，这个方法返回的DirectByteBuffer就是与底层存储空间关联的缓冲区，它通过Native代码操作非JVM堆的内存空间。每次创建或者释放的时候都调用一次System.gc()。\n\nDirectByteBuffer和Non-DirectBuffer对比\n\t\t\t\t\n\t\t\t\t\n| |HeapByteBuffer|DirectByteBuffer|\n|:---:|:---:|:---:| \n|存储位置|Java Heap中|Native内存中\n|I/O|需要在用户地址空间和OS内核地址空间交换数据|不需复制|\n|内存管理|Java GC回收，创建和回收开销少|通过调用System.gc()要释放掉Java对象引用的DirectByteBuffer内存空间，如果Java对象长时间持有引用会导致Native内存泄露，创建和回收内存开销较大|\n|适用场景|并发连接数少于1000，I/O操作较少时比较合适|数据量比较大，生命周期比较长的情况下比较合适|\n\n\n##\tNIO的数据访问方式\nNIO提供了比传统文件访问方式更好的方法，NIO有2个优化方法：一个是FileChannel.transferTo、FileChannel.transferFrom;另一个是FileChannel.map。\n\n1.\tFileChannel.transferXXX  \n与传统的访问文件方式相比，可以减少数据从内核到用户空间的复制，数据直接在内核空间中移动，在Linux中使用sendfile系统调用。\n\n2.\tFileChannel.map\n将文件按照一定大小块映射为内存区域，当程序访问这个内存区域时将直接操作这个文件数据，这种方式省去了数据从内核空间向用户空间复制的损耗。这种方式适合对大文件的只读性操作，如大文件的MD5校验。这种方式是和OS的底层I/O实现相关的，代码如下：\n\n```\tjava\n    public static void map() {\n        int bufferSize = 1024;\n        String fileName = \"test.db\";\n        long fileLength = new File(fileName).length();\n        int bufferCount = 1 + (int) (fileLength / bufferSize);\n        MappedByteBuffer[] buffers = new MappedByteBuffer[bufferCount];\n        long remaining = fileLength;\n        for (int i = 0; i < bufferCount; i++) {\n            RandomAccessFile file;\n            try {\n                file = new RandomAccessFile(fileName, \"r\");\n                buffers[i] = file.getChannel().map(FileChannel.MapMode.READ_ONLY, i * bufferSize, (int) Math.min(remaining, bufferSize));\n            } catch (Exception e) {\n\n            }\n            remaining -= bufferSize;\n        }\n    }\n```\n","source":"_posts/Java Web/NIO的工作机制.md","raw":"---\ntitle: NIO工作机制\ndate: 2016-05-18\ncategories: Java Web\ntags: \n- Java\n- NIO \n---\n\n#\tNIO的工作方式\n\n##\tNIO工作机制\nNIO引入了Channel、Buffer和Selector，Channel是高速通道，Buffer是高速通道上的具体单位，Selector是调度器。当我们调用write()往SendQ写数据时，当一次写的数据超过SendQ长度时需要按照SendQ的长度进行分割，在这个过程中需要将用户空间数据和内核地址空间进行切换，而这个切换不是你可以控制的，但在Buffer中我们可以控制Buffer的容量、是否扩容以及如何扩容。\n\n调用Selector的静态工厂创建一个选择器，创建一个服务端的Channel，绑定到一个Socket对象，并把这个通信信道注册到选择器上，把这个通信信道设置为非阻塞模式。然后就可以调用Selector的selectedKeys方法来检查已经注册在这个选择器上的所有通信信道是否有需要的事件发生，如果与某个事件发生，将会返回所有的SelectionKey，通过这个对象的Channel方法就可以就可以取得这个通信信道对象，从而读取通信的数据，而这里读取的数据是Buffer，这个Buffer是我们可以控制的缓冲器。\n\n```\tjava\npublic void selector() throws IOException {\n        ByteBuffer buffer = ByteBuffer.allocate(1024);\n        Selector selector = Selector.open();\n        ServerSocketChannel ssc = ServerSocketChannel.open();\n        ssc.configureBlocking(false); //设置为非阻塞方式\n        ssc.register(selector, SelectionKey.OP_ACCEPT);\n        while (true) {\n            Set selectedKeys = selector.selectedKeys();\n            Iterator it = selectedKeys.iterator();\n            while (it.hasNext()) {\n                SelectionKey key = (SelectionKey) it.next();\n                if ((key.readyOps() & SelectionKey.OP_ACCEPT) == SelectionKey.OP_ACCEPT) {\n                    ServerSocketChannel ssChannel = (ServerSocketChannel) key.channel();\n                    SocketChannel sc = ssChannel.accept(); //接受到服务端请求\n                    sc.configureBlocking(false);\n                    sc.register(selector, SelectionKey.OP_READ);\n                    it.remove();\n                } else if ((key.readyOps() & SelectionKey.OP_READ) == SelectionKey.OP_READ) {\n                    SocketChannel sc = (SocketChannel) key.channel();\n                    while (true) {\n                        buffer.clear();\n                        int n = sc.read(buffer);\n                        if (n <= 0) {\n                            break;\n                        }\n                        buffer.flip();\n                    }\n                    it.remove();\n                }\n            }\n        }\n    }\n```\n\n在上面这段程序中，将Server端的监听连接请求的事件和处理请求的事件放在一个线程中，但是在事件应用中，我们通常会把它们放在两个线程中：一个线程专门负责监听客户端的连接请求，而且是以阻塞方式运行的；另外一个线程专门负责处理请求，这个专门处理请求的线程才会真正采用NIO的方式，像Web服务器Tomcat和Jetty都是使用这个处理方式。\n\nSelector可以同时监听一组通信信道(Channel)上的IO状态，前提是这个Selector已经注册到这些通信信道中。选择器Selector可以调用select()方法检查已经注册的通信信道上IO是否已经准备好，如果没有至少一个信道IO状态有变化，那么select方法会阻塞等待或在超时时间后返回0。如果有多个信道有数据，那么将会把这些数据分配到对应的数据Buffer中。所以关键的地方是，有一个线程来处理所有连接的数据交互，每个连接的数据交互都不是阻塞方式，所以可以同时处理大量的连续请求。\n\n##\tBuffer的工作方式\n把Buffer简单理解为一组基本数据类型的元素列表，它通过几个变量来保存这个数据的当前位置状态，也就是有4个索引，如下所示：   \n\t\t\n|索引|说明|\n|:---:|:---:| \n|capacity|缓冲区数组的总长度|\n|position|下一个要操作的数据元素位置|\n|limit|缓冲区数组中不可操作的下一个元素的位置，limit<=capacity|\n|mark|记录当前position的前一根位置或默认是0|\n\n通过Channel获取的IO数据首先要经过OS的Socket缓冲区，再将数据复制到Buffer中，这个OS缓冲区就是底层的TCP所关联的RecvQ或者SendQ队列，从OS缓冲区到用户缓冲区复制数据比较耗性能，Buffer提供了另外一种直接操作OS缓冲区的方式，即ByteBuffer.allocateDirector(size)，这个方法返回的DirectByteBuffer就是与底层存储空间关联的缓冲区，它通过Native代码操作非JVM堆的内存空间。每次创建或者释放的时候都调用一次System.gc()。\n\nDirectByteBuffer和Non-DirectBuffer对比\n\t\t\t\t\n\t\t\t\t\n| |HeapByteBuffer|DirectByteBuffer|\n|:---:|:---:|:---:| \n|存储位置|Java Heap中|Native内存中\n|I/O|需要在用户地址空间和OS内核地址空间交换数据|不需复制|\n|内存管理|Java GC回收，创建和回收开销少|通过调用System.gc()要释放掉Java对象引用的DirectByteBuffer内存空间，如果Java对象长时间持有引用会导致Native内存泄露，创建和回收内存开销较大|\n|适用场景|并发连接数少于1000，I/O操作较少时比较合适|数据量比较大，生命周期比较长的情况下比较合适|\n\n\n##\tNIO的数据访问方式\nNIO提供了比传统文件访问方式更好的方法，NIO有2个优化方法：一个是FileChannel.transferTo、FileChannel.transferFrom;另一个是FileChannel.map。\n\n1.\tFileChannel.transferXXX  \n与传统的访问文件方式相比，可以减少数据从内核到用户空间的复制，数据直接在内核空间中移动，在Linux中使用sendfile系统调用。\n\n2.\tFileChannel.map\n将文件按照一定大小块映射为内存区域，当程序访问这个内存区域时将直接操作这个文件数据，这种方式省去了数据从内核空间向用户空间复制的损耗。这种方式适合对大文件的只读性操作，如大文件的MD5校验。这种方式是和OS的底层I/O实现相关的，代码如下：\n\n```\tjava\n    public static void map() {\n        int bufferSize = 1024;\n        String fileName = \"test.db\";\n        long fileLength = new File(fileName).length();\n        int bufferCount = 1 + (int) (fileLength / bufferSize);\n        MappedByteBuffer[] buffers = new MappedByteBuffer[bufferCount];\n        long remaining = fileLength;\n        for (int i = 0; i < bufferCount; i++) {\n            RandomAccessFile file;\n            try {\n                file = new RandomAccessFile(fileName, \"r\");\n                buffers[i] = file.getChannel().map(FileChannel.MapMode.READ_ONLY, i * bufferSize, (int) Math.min(remaining, bufferSize));\n            } catch (Exception e) {\n\n            }\n            remaining -= bufferSize;\n        }\n    }\n```\n","slug":"Java Web/NIO的工作机制","published":1,"updated":"2019-05-17T05:57:58.555Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1j8f2h6000n7h9mkrwrrim0","content":"<h1 id=\"NIO的工作方式\"><a href=\"#NIO的工作方式\" class=\"headerlink\" title=\"NIO的工作方式\"></a>NIO的工作方式</h1><h2 id=\"NIO工作机制\"><a href=\"#NIO工作机制\" class=\"headerlink\" title=\"NIO工作机制\"></a>NIO工作机制</h2><p>NIO引入了Channel、Buffer和Selector，Channel是高速通道，Buffer是高速通道上的具体单位，Selector是调度器。当我们调用write()往SendQ写数据时，当一次写的数据超过SendQ长度时需要按照SendQ的长度进行分割，在这个过程中需要将用户空间数据和内核地址空间进行切换，而这个切换不是你可以控制的，但在Buffer中我们可以控制Buffer的容量、是否扩容以及如何扩容。</p>\n<p>调用Selector的静态工厂创建一个选择器，创建一个服务端的Channel，绑定到一个Socket对象，并把这个通信信道注册到选择器上，把这个通信信道设置为非阻塞模式。然后就可以调用Selector的selectedKeys方法来检查已经注册在这个选择器上的所有通信信道是否有需要的事件发生，如果与某个事件发生，将会返回所有的SelectionKey，通过这个对象的Channel方法就可以就可以取得这个通信信道对象，从而读取通信的数据，而这里读取的数据是Buffer，这个Buffer是我们可以控制的缓冲器。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">selector</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        ByteBuffer buffer = ByteBuffer.allocate(<span class=\"number\">1024</span>);</span><br><span class=\"line\">        Selector selector = Selector.open();</span><br><span class=\"line\">        ServerSocketChannel ssc = ServerSocketChannel.open();</span><br><span class=\"line\">        ssc.configureBlocking(<span class=\"keyword\">false</span>); <span class=\"comment\">//设置为非阻塞方式</span></span><br><span class=\"line\">        ssc.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">            Set selectedKeys = selector.selectedKeys();</span><br><span class=\"line\">            Iterator it = selectedKeys.iterator();</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (it.hasNext()) &#123;</span><br><span class=\"line\">                SelectionKey key = (SelectionKey) it.next();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> ((key.readyOps() &amp; SelectionKey.OP_ACCEPT) == SelectionKey.OP_ACCEPT) &#123;</span><br><span class=\"line\">                    ServerSocketChannel ssChannel = (ServerSocketChannel) key.channel();</span><br><span class=\"line\">                    SocketChannel sc = ssChannel.accept(); <span class=\"comment\">//接受到服务端请求</span></span><br><span class=\"line\">                    sc.configureBlocking(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">                    sc.register(selector, SelectionKey.OP_READ);</span><br><span class=\"line\">                    it.remove();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((key.readyOps() &amp; SelectionKey.OP_READ) == SelectionKey.OP_READ) &#123;</span><br><span class=\"line\">                    SocketChannel sc = (SocketChannel) key.channel();</span><br><span class=\"line\">                    <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">                        buffer.clear();</span><br><span class=\"line\">                        <span class=\"keyword\">int</span> n = sc.read(buffer);</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (n &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        buffer.flip();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    it.remove();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>在上面这段程序中，将Server端的监听连接请求的事件和处理请求的事件放在一个线程中，但是在事件应用中，我们通常会把它们放在两个线程中：一个线程专门负责监听客户端的连接请求，而且是以阻塞方式运行的；另外一个线程专门负责处理请求，这个专门处理请求的线程才会真正采用NIO的方式，像Web服务器Tomcat和Jetty都是使用这个处理方式。</p>\n<p>Selector可以同时监听一组通信信道(Channel)上的IO状态，前提是这个Selector已经注册到这些通信信道中。选择器Selector可以调用select()方法检查已经注册的通信信道上IO是否已经准备好，如果没有至少一个信道IO状态有变化，那么select方法会阻塞等待或在超时时间后返回0。如果有多个信道有数据，那么将会把这些数据分配到对应的数据Buffer中。所以关键的地方是，有一个线程来处理所有连接的数据交互，每个连接的数据交互都不是阻塞方式，所以可以同时处理大量的连续请求。</p>\n<h2 id=\"Buffer的工作方式\"><a href=\"#Buffer的工作方式\" class=\"headerlink\" title=\"Buffer的工作方式\"></a>Buffer的工作方式</h2><p>把Buffer简单理解为一组基本数据类型的元素列表，它通过几个变量来保存这个数据的当前位置状态，也就是有4个索引，如下所示：   </p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">索引</th>\n<th style=\"text-align:center\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">capacity</td>\n<td style=\"text-align:center\">缓冲区数组的总长度</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">position</td>\n<td style=\"text-align:center\">下一个要操作的数据元素位置</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">limit</td>\n<td style=\"text-align:center\">缓冲区数组中不可操作的下一个元素的位置，limit&lt;=capacity</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">mark</td>\n<td style=\"text-align:center\">记录当前position的前一根位置或默认是0</td>\n</tr>\n</tbody>\n</table>\n<p>通过Channel获取的IO数据首先要经过OS的Socket缓冲区，再将数据复制到Buffer中，这个OS缓冲区就是底层的TCP所关联的RecvQ或者SendQ队列，从OS缓冲区到用户缓冲区复制数据比较耗性能，Buffer提供了另外一种直接操作OS缓冲区的方式，即ByteBuffer.allocateDirector(size)，这个方法返回的DirectByteBuffer就是与底层存储空间关联的缓冲区，它通过Native代码操作非JVM堆的内存空间。每次创建或者释放的时候都调用一次System.gc()。</p>\n<p>DirectByteBuffer和Non-DirectBuffer对比</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\"></th>\n<th style=\"text-align:center\">HeapByteBuffer</th>\n<th style=\"text-align:center\">DirectByteBuffer</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">存储位置</td>\n<td style=\"text-align:center\">Java Heap中</td>\n<td style=\"text-align:center\">Native内存中</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">I/O</td>\n<td style=\"text-align:center\">需要在用户地址空间和OS内核地址空间交换数据</td>\n<td style=\"text-align:center\">不需复制</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">内存管理</td>\n<td style=\"text-align:center\">Java GC回收，创建和回收开销少</td>\n<td style=\"text-align:center\">通过调用System.gc()要释放掉Java对象引用的DirectByteBuffer内存空间，如果Java对象长时间持有引用会导致Native内存泄露，创建和回收内存开销较大</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">适用场景</td>\n<td style=\"text-align:center\">并发连接数少于1000，I/O操作较少时比较合适</td>\n<td style=\"text-align:center\">数据量比较大，生命周期比较长的情况下比较合适</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"NIO的数据访问方式\"><a href=\"#NIO的数据访问方式\" class=\"headerlink\" title=\"NIO的数据访问方式\"></a>NIO的数据访问方式</h2><p>NIO提供了比传统文件访问方式更好的方法，NIO有2个优化方法：一个是FileChannel.transferTo、FileChannel.transferFrom;另一个是FileChannel.map。</p>\n<ol>\n<li><p>FileChannel.transferXXX<br>与传统的访问文件方式相比，可以减少数据从内核到用户空间的复制，数据直接在内核空间中移动，在Linux中使用sendfile系统调用。</p>\n</li>\n<li><p>FileChannel.map<br>将文件按照一定大小块映射为内存区域，当程序访问这个内存区域时将直接操作这个文件数据，这种方式省去了数据从内核空间向用户空间复制的损耗。这种方式适合对大文件的只读性操作，如大文件的MD5校验。这种方式是和OS的底层I/O实现相关的，代码如下：</p>\n</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">map</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> bufferSize = <span class=\"number\">1024</span>;</span><br><span class=\"line\">    String fileName = <span class=\"string\">\"test.db\"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> fileLength = <span class=\"keyword\">new</span> File(fileName).length();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> bufferCount = <span class=\"number\">1</span> + (<span class=\"keyword\">int</span>) (fileLength / bufferSize);</span><br><span class=\"line\">    MappedByteBuffer[] buffers = <span class=\"keyword\">new</span> MappedByteBuffer[bufferCount];</span><br><span class=\"line\">    <span class=\"keyword\">long</span> remaining = fileLength;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; bufferCount; i++) &#123;</span><br><span class=\"line\">        RandomAccessFile file;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            file = <span class=\"keyword\">new</span> RandomAccessFile(fileName, <span class=\"string\">\"r\"</span>);</span><br><span class=\"line\">            buffers[i] = file.getChannel().map(FileChannel.MapMode.READ_ONLY, i * bufferSize, (<span class=\"keyword\">int</span>) Math.min(remaining, bufferSize));</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        remaining -= bufferSize;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","excerpt":"","more":"<h1 id=\"NIO的工作方式\"><a href=\"#NIO的工作方式\" class=\"headerlink\" title=\"NIO的工作方式\"></a>NIO的工作方式</h1><h2 id=\"NIO工作机制\"><a href=\"#NIO工作机制\" class=\"headerlink\" title=\"NIO工作机制\"></a>NIO工作机制</h2><p>NIO引入了Channel、Buffer和Selector，Channel是高速通道，Buffer是高速通道上的具体单位，Selector是调度器。当我们调用write()往SendQ写数据时，当一次写的数据超过SendQ长度时需要按照SendQ的长度进行分割，在这个过程中需要将用户空间数据和内核地址空间进行切换，而这个切换不是你可以控制的，但在Buffer中我们可以控制Buffer的容量、是否扩容以及如何扩容。</p>\n<p>调用Selector的静态工厂创建一个选择器，创建一个服务端的Channel，绑定到一个Socket对象，并把这个通信信道注册到选择器上，把这个通信信道设置为非阻塞模式。然后就可以调用Selector的selectedKeys方法来检查已经注册在这个选择器上的所有通信信道是否有需要的事件发生，如果与某个事件发生，将会返回所有的SelectionKey，通过这个对象的Channel方法就可以就可以取得这个通信信道对象，从而读取通信的数据，而这里读取的数据是Buffer，这个Buffer是我们可以控制的缓冲器。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">selector</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        ByteBuffer buffer = ByteBuffer.allocate(<span class=\"number\">1024</span>);</span><br><span class=\"line\">        Selector selector = Selector.open();</span><br><span class=\"line\">        ServerSocketChannel ssc = ServerSocketChannel.open();</span><br><span class=\"line\">        ssc.configureBlocking(<span class=\"keyword\">false</span>); <span class=\"comment\">//设置为非阻塞方式</span></span><br><span class=\"line\">        ssc.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">            Set selectedKeys = selector.selectedKeys();</span><br><span class=\"line\">            Iterator it = selectedKeys.iterator();</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (it.hasNext()) &#123;</span><br><span class=\"line\">                SelectionKey key = (SelectionKey) it.next();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> ((key.readyOps() &amp; SelectionKey.OP_ACCEPT) == SelectionKey.OP_ACCEPT) &#123;</span><br><span class=\"line\">                    ServerSocketChannel ssChannel = (ServerSocketChannel) key.channel();</span><br><span class=\"line\">                    SocketChannel sc = ssChannel.accept(); <span class=\"comment\">//接受到服务端请求</span></span><br><span class=\"line\">                    sc.configureBlocking(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">                    sc.register(selector, SelectionKey.OP_READ);</span><br><span class=\"line\">                    it.remove();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((key.readyOps() &amp; SelectionKey.OP_READ) == SelectionKey.OP_READ) &#123;</span><br><span class=\"line\">                    SocketChannel sc = (SocketChannel) key.channel();</span><br><span class=\"line\">                    <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">                        buffer.clear();</span><br><span class=\"line\">                        <span class=\"keyword\">int</span> n = sc.read(buffer);</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (n &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        buffer.flip();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    it.remove();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>在上面这段程序中，将Server端的监听连接请求的事件和处理请求的事件放在一个线程中，但是在事件应用中，我们通常会把它们放在两个线程中：一个线程专门负责监听客户端的连接请求，而且是以阻塞方式运行的；另外一个线程专门负责处理请求，这个专门处理请求的线程才会真正采用NIO的方式，像Web服务器Tomcat和Jetty都是使用这个处理方式。</p>\n<p>Selector可以同时监听一组通信信道(Channel)上的IO状态，前提是这个Selector已经注册到这些通信信道中。选择器Selector可以调用select()方法检查已经注册的通信信道上IO是否已经准备好，如果没有至少一个信道IO状态有变化，那么select方法会阻塞等待或在超时时间后返回0。如果有多个信道有数据，那么将会把这些数据分配到对应的数据Buffer中。所以关键的地方是，有一个线程来处理所有连接的数据交互，每个连接的数据交互都不是阻塞方式，所以可以同时处理大量的连续请求。</p>\n<h2 id=\"Buffer的工作方式\"><a href=\"#Buffer的工作方式\" class=\"headerlink\" title=\"Buffer的工作方式\"></a>Buffer的工作方式</h2><p>把Buffer简单理解为一组基本数据类型的元素列表，它通过几个变量来保存这个数据的当前位置状态，也就是有4个索引，如下所示：   </p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">索引</th>\n<th style=\"text-align:center\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">capacity</td>\n<td style=\"text-align:center\">缓冲区数组的总长度</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">position</td>\n<td style=\"text-align:center\">下一个要操作的数据元素位置</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">limit</td>\n<td style=\"text-align:center\">缓冲区数组中不可操作的下一个元素的位置，limit&lt;=capacity</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">mark</td>\n<td style=\"text-align:center\">记录当前position的前一根位置或默认是0</td>\n</tr>\n</tbody>\n</table>\n<p>通过Channel获取的IO数据首先要经过OS的Socket缓冲区，再将数据复制到Buffer中，这个OS缓冲区就是底层的TCP所关联的RecvQ或者SendQ队列，从OS缓冲区到用户缓冲区复制数据比较耗性能，Buffer提供了另外一种直接操作OS缓冲区的方式，即ByteBuffer.allocateDirector(size)，这个方法返回的DirectByteBuffer就是与底层存储空间关联的缓冲区，它通过Native代码操作非JVM堆的内存空间。每次创建或者释放的时候都调用一次System.gc()。</p>\n<p>DirectByteBuffer和Non-DirectBuffer对比</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\"></th>\n<th style=\"text-align:center\">HeapByteBuffer</th>\n<th style=\"text-align:center\">DirectByteBuffer</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">存储位置</td>\n<td style=\"text-align:center\">Java Heap中</td>\n<td style=\"text-align:center\">Native内存中</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">I/O</td>\n<td style=\"text-align:center\">需要在用户地址空间和OS内核地址空间交换数据</td>\n<td style=\"text-align:center\">不需复制</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">内存管理</td>\n<td style=\"text-align:center\">Java GC回收，创建和回收开销少</td>\n<td style=\"text-align:center\">通过调用System.gc()要释放掉Java对象引用的DirectByteBuffer内存空间，如果Java对象长时间持有引用会导致Native内存泄露，创建和回收内存开销较大</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">适用场景</td>\n<td style=\"text-align:center\">并发连接数少于1000，I/O操作较少时比较合适</td>\n<td style=\"text-align:center\">数据量比较大，生命周期比较长的情况下比较合适</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"NIO的数据访问方式\"><a href=\"#NIO的数据访问方式\" class=\"headerlink\" title=\"NIO的数据访问方式\"></a>NIO的数据访问方式</h2><p>NIO提供了比传统文件访问方式更好的方法，NIO有2个优化方法：一个是FileChannel.transferTo、FileChannel.transferFrom;另一个是FileChannel.map。</p>\n<ol>\n<li><p>FileChannel.transferXXX<br>与传统的访问文件方式相比，可以减少数据从内核到用户空间的复制，数据直接在内核空间中移动，在Linux中使用sendfile系统调用。</p>\n</li>\n<li><p>FileChannel.map<br>将文件按照一定大小块映射为内存区域，当程序访问这个内存区域时将直接操作这个文件数据，这种方式省去了数据从内核空间向用户空间复制的损耗。这种方式适合对大文件的只读性操作，如大文件的MD5校验。这种方式是和OS的底层I/O实现相关的，代码如下：</p>\n</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">map</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> bufferSize = <span class=\"number\">1024</span>;</span><br><span class=\"line\">    String fileName = <span class=\"string\">\"test.db\"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> fileLength = <span class=\"keyword\">new</span> File(fileName).length();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> bufferCount = <span class=\"number\">1</span> + (<span class=\"keyword\">int</span>) (fileLength / bufferSize);</span><br><span class=\"line\">    MappedByteBuffer[] buffers = <span class=\"keyword\">new</span> MappedByteBuffer[bufferCount];</span><br><span class=\"line\">    <span class=\"keyword\">long</span> remaining = fileLength;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; bufferCount; i++) &#123;</span><br><span class=\"line\">        RandomAccessFile file;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            file = <span class=\"keyword\">new</span> RandomAccessFile(fileName, <span class=\"string\">\"r\"</span>);</span><br><span class=\"line\">            buffers[i] = file.getChannel().map(FileChannel.MapMode.READ_ONLY, i * bufferSize, (<span class=\"keyword\">int</span>) Math.min(remaining, bufferSize));</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        remaining -= bufferSize;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"深入分析ClassLoader","date":"2016-05-27T16:00:00.000Z","_content":"\nClassLoader除了能将Class加载到JVM中之外，还能审查每个类该由谁加载。它是一种父优先的等级加载机制。\n\n##\tClassLoader等级加载机制\t\n\n1.\tBootstrap ClassLoader，主要加载JVM自身工作需要的类，完全由JVM自己控制，外部无法访问，这个ClassLoader不遵守等级加载规则。\n2. \tExtClassLoader，不是JVM亲自实现。服务目标在System.getProperties(\"java.ext.dirs\")目录下。\n3. \tAppClassLoader，父类是ExtClassLoader，所有在System.getProperties(\"java.class.path\")目录下的类都可以被这个类加载器加载，这就是我们常用到的classpath。\n\n如果我们要实现自己的类加载器，不管是直接实现抽象类ClassLoader，还是继承URLClassLoader或其他子类，它的父加载器都是AppClassLoader，不管调用哪个父类构造器，创建对象都必须最终调用getSystemCLassLoader()作为父加载器，而getSystemClassLoader()方法获取到的正是AppClassLoader。\n\nBootstrap ClassLoader并不属于JVM的类层次结构，因为BootstrapClassLoader并没有遵守ClassLoader的加载规则。Bootstrap ClassLoader并没有子类，ExtClassLoader父类也不是Bootstrap ClassLoader，ExtClassLoader并没有父类，应用中能提取到的顶层父类是ExtClassLoader。\n\nExtClassLoader和AppClassLoader都位于sun.misc.Launcher类中，它们是Launcher类的内部类，都继承了URLClassLoader类，URLClassLoader实现了抽象类ClassLoader。\n\n##\t如何加载class文件\t\n抽象类ClassLoader中并没有定义如何加载，需要子类实现findClass()方法。看一下URLClassLoader实现findClass()过程：\t\n1.\t通过URLClassPath类取得加载的class文件字节流，找到后读取它的byte字节流。\t\n2. \t调用defineClass()创建类对象。\n\n创建URLClassLoader对象会根据传过来的URL数组中路径来判断是文件还是jar包，根据路径的不同分别创建FileLoader和JarLoader，或者使用默认的加载器。\n\n###\t验证与解析\n1.\t字节码验证，确保格式正确，行为正确。\n2. \t类准备，准备字段、方法和实现接口所必须的数据结构。\n3. \t解析，类装入器装入类引用的其他所有类。\t\n4.\t初始化对象，该阶段末尾静态字段被初始化默认值。\n\n##\t实现自己的ClassLoader\t\n应用场景：\t\n*\t在自定义路径下查找自定义的class类文件，也许我们需要的class文件并不总是在classPath下面。\t\n* \t对我们自己要加载的类做特殊处理，如保证通过网络传输的安全性，可以将类经过加密后传输，在加载到JVM之前需要对类的字节码再解密。\t\t\n*  \t可以定义类的实现机制，例如实现热部署：检查已经加载的class文件是否被修改，如修改可重新加载。\t\n\nJVM表示一个类是否是同一个类有两个条件：\t\n1.\t检查完整类名是否一致。\t\t\n2. \t检查加载这个类的ClassLoader是否是同一个，这里指的是ClassLoader实例是否是同一个。","source":"_posts/Java Web/深入分析ClassLoader.md","raw":"---\ntitle: 深入分析ClassLoader\ndate: 2016-05-28\ncategories: Java Web\ntags: \n- Java\n- JVM\n---\n\nClassLoader除了能将Class加载到JVM中之外，还能审查每个类该由谁加载。它是一种父优先的等级加载机制。\n\n##\tClassLoader等级加载机制\t\n\n1.\tBootstrap ClassLoader，主要加载JVM自身工作需要的类，完全由JVM自己控制，外部无法访问，这个ClassLoader不遵守等级加载规则。\n2. \tExtClassLoader，不是JVM亲自实现。服务目标在System.getProperties(\"java.ext.dirs\")目录下。\n3. \tAppClassLoader，父类是ExtClassLoader，所有在System.getProperties(\"java.class.path\")目录下的类都可以被这个类加载器加载，这就是我们常用到的classpath。\n\n如果我们要实现自己的类加载器，不管是直接实现抽象类ClassLoader，还是继承URLClassLoader或其他子类，它的父加载器都是AppClassLoader，不管调用哪个父类构造器，创建对象都必须最终调用getSystemCLassLoader()作为父加载器，而getSystemClassLoader()方法获取到的正是AppClassLoader。\n\nBootstrap ClassLoader并不属于JVM的类层次结构，因为BootstrapClassLoader并没有遵守ClassLoader的加载规则。Bootstrap ClassLoader并没有子类，ExtClassLoader父类也不是Bootstrap ClassLoader，ExtClassLoader并没有父类，应用中能提取到的顶层父类是ExtClassLoader。\n\nExtClassLoader和AppClassLoader都位于sun.misc.Launcher类中，它们是Launcher类的内部类，都继承了URLClassLoader类，URLClassLoader实现了抽象类ClassLoader。\n\n##\t如何加载class文件\t\n抽象类ClassLoader中并没有定义如何加载，需要子类实现findClass()方法。看一下URLClassLoader实现findClass()过程：\t\n1.\t通过URLClassPath类取得加载的class文件字节流，找到后读取它的byte字节流。\t\n2. \t调用defineClass()创建类对象。\n\n创建URLClassLoader对象会根据传过来的URL数组中路径来判断是文件还是jar包，根据路径的不同分别创建FileLoader和JarLoader，或者使用默认的加载器。\n\n###\t验证与解析\n1.\t字节码验证，确保格式正确，行为正确。\n2. \t类准备，准备字段、方法和实现接口所必须的数据结构。\n3. \t解析，类装入器装入类引用的其他所有类。\t\n4.\t初始化对象，该阶段末尾静态字段被初始化默认值。\n\n##\t实现自己的ClassLoader\t\n应用场景：\t\n*\t在自定义路径下查找自定义的class类文件，也许我们需要的class文件并不总是在classPath下面。\t\n* \t对我们自己要加载的类做特殊处理，如保证通过网络传输的安全性，可以将类经过加密后传输，在加载到JVM之前需要对类的字节码再解密。\t\t\n*  \t可以定义类的实现机制，例如实现热部署：检查已经加载的class文件是否被修改，如修改可重新加载。\t\n\nJVM表示一个类是否是同一个类有两个条件：\t\n1.\t检查完整类名是否一致。\t\t\n2. \t检查加载这个类的ClassLoader是否是同一个，这里指的是ClassLoader实例是否是同一个。","slug":"Java Web/深入分析ClassLoader","published":1,"updated":"2019-05-17T05:57:58.557Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1j8f2h7000p7h9mmr7s1412","content":"<p>ClassLoader除了能将Class加载到JVM中之外，还能审查每个类该由谁加载。它是一种父优先的等级加载机制。</p>\n<h2 id=\"ClassLoader等级加载机制\"><a href=\"#ClassLoader等级加载机制\" class=\"headerlink\" title=\"ClassLoader等级加载机制\"></a>ClassLoader等级加载机制</h2><ol>\n<li>Bootstrap ClassLoader，主要加载JVM自身工作需要的类，完全由JVM自己控制，外部无法访问，这个ClassLoader不遵守等级加载规则。</li>\n<li>ExtClassLoader，不是JVM亲自实现。服务目标在System.getProperties(“java.ext.dirs”)目录下。</li>\n<li>AppClassLoader，父类是ExtClassLoader，所有在System.getProperties(“java.class.path”)目录下的类都可以被这个类加载器加载，这就是我们常用到的classpath。</li>\n</ol>\n<p>如果我们要实现自己的类加载器，不管是直接实现抽象类ClassLoader，还是继承URLClassLoader或其他子类，它的父加载器都是AppClassLoader，不管调用哪个父类构造器，创建对象都必须最终调用getSystemCLassLoader()作为父加载器，而getSystemClassLoader()方法获取到的正是AppClassLoader。</p>\n<p>Bootstrap ClassLoader并不属于JVM的类层次结构，因为BootstrapClassLoader并没有遵守ClassLoader的加载规则。Bootstrap ClassLoader并没有子类，ExtClassLoader父类也不是Bootstrap ClassLoader，ExtClassLoader并没有父类，应用中能提取到的顶层父类是ExtClassLoader。</p>\n<p>ExtClassLoader和AppClassLoader都位于sun.misc.Launcher类中，它们是Launcher类的内部类，都继承了URLClassLoader类，URLClassLoader实现了抽象类ClassLoader。</p>\n<h2 id=\"如何加载class文件\"><a href=\"#如何加载class文件\" class=\"headerlink\" title=\"如何加载class文件\"></a>如何加载class文件</h2><p>抽象类ClassLoader中并没有定义如何加载，需要子类实现findClass()方法。看一下URLClassLoader实现findClass()过程：    </p>\n<ol>\n<li>通过URLClassPath类取得加载的class文件字节流，找到后读取它的byte字节流。    </li>\n<li>调用defineClass()创建类对象。</li>\n</ol>\n<p>创建URLClassLoader对象会根据传过来的URL数组中路径来判断是文件还是jar包，根据路径的不同分别创建FileLoader和JarLoader，或者使用默认的加载器。</p>\n<h3 id=\"验证与解析\"><a href=\"#验证与解析\" class=\"headerlink\" title=\"验证与解析\"></a>验证与解析</h3><ol>\n<li>字节码验证，确保格式正确，行为正确。</li>\n<li>类准备，准备字段、方法和实现接口所必须的数据结构。</li>\n<li>解析，类装入器装入类引用的其他所有类。    </li>\n<li>初始化对象，该阶段末尾静态字段被初始化默认值。</li>\n</ol>\n<h2 id=\"实现自己的ClassLoader\"><a href=\"#实现自己的ClassLoader\" class=\"headerlink\" title=\"实现自己的ClassLoader\"></a>实现自己的ClassLoader</h2><p>应用场景：    </p>\n<ul>\n<li>在自定义路径下查找自定义的class类文件，也许我们需要的class文件并不总是在classPath下面。    </li>\n<li>对我们自己要加载的类做特殊处理，如保证通过网络传输的安全性，可以将类经过加密后传输，在加载到JVM之前需要对类的字节码再解密。        </li>\n<li>可以定义类的实现机制，例如实现热部署：检查已经加载的class文件是否被修改，如修改可重新加载。    </li>\n</ul>\n<p>JVM表示一个类是否是同一个类有两个条件：    </p>\n<ol>\n<li>检查完整类名是否一致。        </li>\n<li>检查加载这个类的ClassLoader是否是同一个，这里指的是ClassLoader实例是否是同一个。</li>\n</ol>\n","excerpt":"","more":"<p>ClassLoader除了能将Class加载到JVM中之外，还能审查每个类该由谁加载。它是一种父优先的等级加载机制。</p>\n<h2 id=\"ClassLoader等级加载机制\"><a href=\"#ClassLoader等级加载机制\" class=\"headerlink\" title=\"ClassLoader等级加载机制\"></a>ClassLoader等级加载机制</h2><ol>\n<li>Bootstrap ClassLoader，主要加载JVM自身工作需要的类，完全由JVM自己控制，外部无法访问，这个ClassLoader不遵守等级加载规则。</li>\n<li>ExtClassLoader，不是JVM亲自实现。服务目标在System.getProperties(“java.ext.dirs”)目录下。</li>\n<li>AppClassLoader，父类是ExtClassLoader，所有在System.getProperties(“java.class.path”)目录下的类都可以被这个类加载器加载，这就是我们常用到的classpath。</li>\n</ol>\n<p>如果我们要实现自己的类加载器，不管是直接实现抽象类ClassLoader，还是继承URLClassLoader或其他子类，它的父加载器都是AppClassLoader，不管调用哪个父类构造器，创建对象都必须最终调用getSystemCLassLoader()作为父加载器，而getSystemClassLoader()方法获取到的正是AppClassLoader。</p>\n<p>Bootstrap ClassLoader并不属于JVM的类层次结构，因为BootstrapClassLoader并没有遵守ClassLoader的加载规则。Bootstrap ClassLoader并没有子类，ExtClassLoader父类也不是Bootstrap ClassLoader，ExtClassLoader并没有父类，应用中能提取到的顶层父类是ExtClassLoader。</p>\n<p>ExtClassLoader和AppClassLoader都位于sun.misc.Launcher类中，它们是Launcher类的内部类，都继承了URLClassLoader类，URLClassLoader实现了抽象类ClassLoader。</p>\n<h2 id=\"如何加载class文件\"><a href=\"#如何加载class文件\" class=\"headerlink\" title=\"如何加载class文件\"></a>如何加载class文件</h2><p>抽象类ClassLoader中并没有定义如何加载，需要子类实现findClass()方法。看一下URLClassLoader实现findClass()过程：    </p>\n<ol>\n<li>通过URLClassPath类取得加载的class文件字节流，找到后读取它的byte字节流。    </li>\n<li>调用defineClass()创建类对象。</li>\n</ol>\n<p>创建URLClassLoader对象会根据传过来的URL数组中路径来判断是文件还是jar包，根据路径的不同分别创建FileLoader和JarLoader，或者使用默认的加载器。</p>\n<h3 id=\"验证与解析\"><a href=\"#验证与解析\" class=\"headerlink\" title=\"验证与解析\"></a>验证与解析</h3><ol>\n<li>字节码验证，确保格式正确，行为正确。</li>\n<li>类准备，准备字段、方法和实现接口所必须的数据结构。</li>\n<li>解析，类装入器装入类引用的其他所有类。    </li>\n<li>初始化对象，该阶段末尾静态字段被初始化默认值。</li>\n</ol>\n<h2 id=\"实现自己的ClassLoader\"><a href=\"#实现自己的ClassLoader\" class=\"headerlink\" title=\"实现自己的ClassLoader\"></a>实现自己的ClassLoader</h2><p>应用场景：    </p>\n<ul>\n<li>在自定义路径下查找自定义的class类文件，也许我们需要的class文件并不总是在classPath下面。    </li>\n<li>对我们自己要加载的类做特殊处理，如保证通过网络传输的安全性，可以将类经过加密后传输，在加载到JVM之前需要对类的字节码再解密。        </li>\n<li>可以定义类的实现机制，例如实现热部署：检查已经加载的class文件是否被修改，如修改可重新加载。    </li>\n</ul>\n<p>JVM表示一个类是否是同一个类有两个条件：    </p>\n<ol>\n<li>检查完整类名是否一致。        </li>\n<li>检查加载这个类的ClassLoader是否是同一个，这里指的是ClassLoader实例是否是同一个。</li>\n</ol>\n"},{"title":"Scala基础","date":"2016-06-06T16:00:00.000Z","_content":"\n##\t变量\t\n*\tval，定义immutable variable，不可变\t\t\n* \tvar，定义mutable variable，可变\n*  \tlazy val，惰性常量\t\n\n\n##\t数据类型\n\n超级父类 Any\n\nByte, Short, Int, Long, Char, String, Float, Double, Boolean\n\nnull表示对象引用类型为空，nothing表示程序异常终止。\n\n```scala\nscala> def foo()=throw new Exception(\"error\")\nfoo: ()Nothing\n```\n\nString构建与Java的String之上，新增字符串插值特性。\n\n```scala\nval name = \"Hello\"\t\ns\"new name is ${name}\"\n```\n\n可以不显示指定变量类型，Scala会自动进行类型推导。\n\n##\t代码块\t\n```scala\n{exp1 ;exp2}\n\n{\nexp1\nexp2\n}\n```\n表达式可以写在一行，分号分隔。也可以写多行。\n\n##\t函数\t\n\n```scala\ndef functionName( param: ParamType): ReturnType = {\n\t//function body: expressions\n}\n```\n```scala\nscala> def add(x:Int, y:Int)= {x+y}\nadd: (x: Int, y: Int)Int\n\nscala> add(1,1)\nres4: Int = 2\n\nscala> def add(x:Int, y:Int):Int= {x+y}\nadd: (x: Int, y: Int)Int\n\nscala> add(1,1)\nres5: Int = 2\n```\n多个参数用逗号分隔。\n\n## if表达式\n```scala\nif (logical_exp) valA else valB\n```\n和Java类似。\n\n##\tfor表达式\n```scala\nscala> val l = List(\"a\", \"b\", \"c\")\nl: List[String] = List(a, b, c)\n\nscala> for (\ns <- l\n) println(s)\na\nb\nc\n```\n\n##\ttry表达式\n```scala\ntry{ }\ncatch{ }\nfinally{ }\n```\n与Java不同，try是表达式，不是关键字。\n\n```scala\ntry{\n\tInteger.parseInt(\"abc\")\n} catch {\n\tcase _ => 0\n} finally {\n\tprintln(\"always be printed\")\n}\n```\n\n##\tmatch表达式\n```scala\nexp match {\n\tcase p1 => val1\n\tcase p2 => val2\n\t...\n\tcase _ => valn\n}\n```\n```scala\nval code = 1\nval result_match = code match {\n\tcase 1 => \"ONE\"\n\tcase 2 => \"TWO\"\n\tcase _ => \"OTHERS\"\n}\n```\n\n_ 表示通配，相当于Java中switch语句的default关键字。\n\n##\t求值策略\n*\tCall By Value 对函数实参求值，且仅求值一次\n* \tCall By Name\t函数实参每次在函数体内被用到时都会求值\n\nScala默认使用Call By Value\t\n如果函数形参类型以 => 开头，那么会使用Call By Name\t\t\n\t\ndef foo(x: Int) = x //call by value\t\t\ndef foo(x: => Int) = x //call by name\t\n\ncall by name在调用时不会解析入参中的表达式，call by value则相反。\n\n##\t函数\nScala函数特性：\t\n1.\t把函数作为实参传递给另一个函数。\t\n2. \t把函数作为返回值。\t\n3. \t把函数赋值给变量。\t\n4. \t把函数存储在数据结构里。\t\n5. \t函数和普通变量一样，具有函数的类型。\n\n##\t函数类型\n函数类型格式为 A => B ，表示一个接受类型A的参数，并返回类型B的函数。\n\n例子： Int => String 是把整型映射为字符串的函数类型。\n\n##\t高阶函数\n用函数作为形参或返回值的函数，称为高阶函数。\n\n```scala\ndef operate(f: (Int, Int) => Int) = {\n\tf(4, 4)\n}\n\ndef greeting() = (name: String) => {\"hello\" + \" \" + name}\t//匿名函数\n```\n\n##\t柯里化\n柯里化函数，把具有多个参数的函数转换为一条函数链，每个节点上是单一参数。\n\n例子：以下2个add函数定义是等价的\n\n```scala\ndef add(x: Int, y: Int) = x + y\t\ndef add(x: Int)(y: Int) = x + y //Scala柯里化语法\n```\n\n##\t尾递归函数\n尾递归函数中所有递归形式的调用都出现在函数的末尾。\n\n当编译器检测到一个函数调用是尾递归的时候，它就覆盖当前的活动记录而不是在栈中去创建一个新的。（避免堆栈内存溢出）\n\n例子：\n\n```scala\n@annotation.tailrec\ndef factorial(n: Int, m: Int): Int =\n\tif (n <= 0) m\n\telse factoria(n-1, m*n)\nfactorial(5, 1)\n```\n```scala\ndef sum(f: Int => Int)(a: Int)(b: Int): Int = {\n\n    @annotation.tailrec\n    def loop(n: Int, acc: Int): Int = {\n      if (n > b) {\n        println(s\"n=${n}, acc=${acc}\")\n        acc\n      } else {\n        println(s\"n=${n}, acc=${acc}\")\n        loop(n + 1, acc + f(n))\n      }\n    }\n\n    loop(a, 0)\n}\n  \n  sum(x => x)(1)(5)\n\n//输出\nn=1, acc=0\nn=2, acc=1\nn=3, acc=3\nn=4, acc=6\nn=5, acc=10\nn=6, acc=15\n```\n","source":"_posts/Scala/Scala基础.md","raw":"---\ntitle: Scala基础\ndate: 2016-06-07\ncategories: Scala\ntags: Scala\n---\n\n##\t变量\t\n*\tval，定义immutable variable，不可变\t\t\n* \tvar，定义mutable variable，可变\n*  \tlazy val，惰性常量\t\n\n\n##\t数据类型\n\n超级父类 Any\n\nByte, Short, Int, Long, Char, String, Float, Double, Boolean\n\nnull表示对象引用类型为空，nothing表示程序异常终止。\n\n```scala\nscala> def foo()=throw new Exception(\"error\")\nfoo: ()Nothing\n```\n\nString构建与Java的String之上，新增字符串插值特性。\n\n```scala\nval name = \"Hello\"\t\ns\"new name is ${name}\"\n```\n\n可以不显示指定变量类型，Scala会自动进行类型推导。\n\n##\t代码块\t\n```scala\n{exp1 ;exp2}\n\n{\nexp1\nexp2\n}\n```\n表达式可以写在一行，分号分隔。也可以写多行。\n\n##\t函数\t\n\n```scala\ndef functionName( param: ParamType): ReturnType = {\n\t//function body: expressions\n}\n```\n```scala\nscala> def add(x:Int, y:Int)= {x+y}\nadd: (x: Int, y: Int)Int\n\nscala> add(1,1)\nres4: Int = 2\n\nscala> def add(x:Int, y:Int):Int= {x+y}\nadd: (x: Int, y: Int)Int\n\nscala> add(1,1)\nres5: Int = 2\n```\n多个参数用逗号分隔。\n\n## if表达式\n```scala\nif (logical_exp) valA else valB\n```\n和Java类似。\n\n##\tfor表达式\n```scala\nscala> val l = List(\"a\", \"b\", \"c\")\nl: List[String] = List(a, b, c)\n\nscala> for (\ns <- l\n) println(s)\na\nb\nc\n```\n\n##\ttry表达式\n```scala\ntry{ }\ncatch{ }\nfinally{ }\n```\n与Java不同，try是表达式，不是关键字。\n\n```scala\ntry{\n\tInteger.parseInt(\"abc\")\n} catch {\n\tcase _ => 0\n} finally {\n\tprintln(\"always be printed\")\n}\n```\n\n##\tmatch表达式\n```scala\nexp match {\n\tcase p1 => val1\n\tcase p2 => val2\n\t...\n\tcase _ => valn\n}\n```\n```scala\nval code = 1\nval result_match = code match {\n\tcase 1 => \"ONE\"\n\tcase 2 => \"TWO\"\n\tcase _ => \"OTHERS\"\n}\n```\n\n_ 表示通配，相当于Java中switch语句的default关键字。\n\n##\t求值策略\n*\tCall By Value 对函数实参求值，且仅求值一次\n* \tCall By Name\t函数实参每次在函数体内被用到时都会求值\n\nScala默认使用Call By Value\t\n如果函数形参类型以 => 开头，那么会使用Call By Name\t\t\n\t\ndef foo(x: Int) = x //call by value\t\t\ndef foo(x: => Int) = x //call by name\t\n\ncall by name在调用时不会解析入参中的表达式，call by value则相反。\n\n##\t函数\nScala函数特性：\t\n1.\t把函数作为实参传递给另一个函数。\t\n2. \t把函数作为返回值。\t\n3. \t把函数赋值给变量。\t\n4. \t把函数存储在数据结构里。\t\n5. \t函数和普通变量一样，具有函数的类型。\n\n##\t函数类型\n函数类型格式为 A => B ，表示一个接受类型A的参数，并返回类型B的函数。\n\n例子： Int => String 是把整型映射为字符串的函数类型。\n\n##\t高阶函数\n用函数作为形参或返回值的函数，称为高阶函数。\n\n```scala\ndef operate(f: (Int, Int) => Int) = {\n\tf(4, 4)\n}\n\ndef greeting() = (name: String) => {\"hello\" + \" \" + name}\t//匿名函数\n```\n\n##\t柯里化\n柯里化函数，把具有多个参数的函数转换为一条函数链，每个节点上是单一参数。\n\n例子：以下2个add函数定义是等价的\n\n```scala\ndef add(x: Int, y: Int) = x + y\t\ndef add(x: Int)(y: Int) = x + y //Scala柯里化语法\n```\n\n##\t尾递归函数\n尾递归函数中所有递归形式的调用都出现在函数的末尾。\n\n当编译器检测到一个函数调用是尾递归的时候，它就覆盖当前的活动记录而不是在栈中去创建一个新的。（避免堆栈内存溢出）\n\n例子：\n\n```scala\n@annotation.tailrec\ndef factorial(n: Int, m: Int): Int =\n\tif (n <= 0) m\n\telse factoria(n-1, m*n)\nfactorial(5, 1)\n```\n```scala\ndef sum(f: Int => Int)(a: Int)(b: Int): Int = {\n\n    @annotation.tailrec\n    def loop(n: Int, acc: Int): Int = {\n      if (n > b) {\n        println(s\"n=${n}, acc=${acc}\")\n        acc\n      } else {\n        println(s\"n=${n}, acc=${acc}\")\n        loop(n + 1, acc + f(n))\n      }\n    }\n\n    loop(a, 0)\n}\n  \n  sum(x => x)(1)(5)\n\n//输出\nn=1, acc=0\nn=2, acc=1\nn=3, acc=3\nn=4, acc=6\nn=5, acc=10\nn=6, acc=15\n```\n","slug":"Scala/Scala基础","published":1,"updated":"2019-05-17T05:57:58.559Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1j8f2h8000q7h9mm8y8dmas","content":"<h2 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h2><ul>\n<li>val，定义immutable variable，不可变        </li>\n<li>var，定义mutable variable，可变</li>\n<li>lazy val，惰性常量    </li>\n</ul>\n<h2 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h2><p>超级父类 Any</p>\n<p>Byte, Short, Int, Long, Char, String, Float, Double, Boolean</p>\n<p>null表示对象引用类型为空，nothing表示程序异常终止。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scala&gt; <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">foo</span></span>()=<span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"type\">Exception</span>(<span class=\"string\">\"error\"</span>)</span><br><span class=\"line\">foo: ()<span class=\"type\">Nothing</span></span><br></pre></td></tr></table></figure>\n<p>String构建与Java的String之上，新增字符串插值特性。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> name = <span class=\"string\">\"Hello\"</span>\t</span><br><span class=\"line\"><span class=\"string\">s\"new name is <span class=\"subst\">$&#123;name&#125;</span>\"</span></span><br></pre></td></tr></table></figure>\n<p>可以不显示指定变量类型，Scala会自动进行类型推导。</p>\n<h2 id=\"代码块\"><a href=\"#代码块\" class=\"headerlink\" title=\"代码块\"></a>代码块</h2><figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;exp1 ;exp2&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">exp1</span><br><span class=\"line\">exp2</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>表达式可以写在一行，分号分隔。也可以写多行。</p>\n<h2 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h2><figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">functionName</span></span>( param: <span class=\"type\">ParamType</span>): <span class=\"type\">ReturnType</span> = &#123;</span><br><span class=\"line\">\t<span class=\"comment\">//function body: expressions</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scala&gt; <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">add</span></span>(x:<span class=\"type\">Int</span>, y:<span class=\"type\">Int</span>)= &#123;x+y&#125;</span><br><span class=\"line\">add: (x: <span class=\"type\">Int</span>, y: <span class=\"type\">Int</span>)<span class=\"type\">Int</span></span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; add(<span class=\"number\">1</span>,<span class=\"number\">1</span>)</span><br><span class=\"line\">res4: <span class=\"type\">Int</span> = <span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">add</span></span>(x:<span class=\"type\">Int</span>, y:<span class=\"type\">Int</span>):<span class=\"type\">Int</span>= &#123;x+y&#125;</span><br><span class=\"line\">add: (x: <span class=\"type\">Int</span>, y: <span class=\"type\">Int</span>)<span class=\"type\">Int</span></span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; add(<span class=\"number\">1</span>,<span class=\"number\">1</span>)</span><br><span class=\"line\">res5: <span class=\"type\">Int</span> = <span class=\"number\">2</span></span><br></pre></td></tr></table></figure>\n<p>多个参数用逗号分隔。</p>\n<h2 id=\"if表达式\"><a href=\"#if表达式\" class=\"headerlink\" title=\"if表达式\"></a>if表达式</h2><figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (logical_exp) valA <span class=\"keyword\">else</span> valB</span><br></pre></td></tr></table></figure>\n<p>和Java类似。</p>\n<h2 id=\"for表达式\"><a href=\"#for表达式\" class=\"headerlink\" title=\"for表达式\"></a>for表达式</h2><figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scala&gt; <span class=\"keyword\">val</span> l = <span class=\"type\">List</span>(<span class=\"string\">\"a\"</span>, <span class=\"string\">\"b\"</span>, <span class=\"string\">\"c\"</span>)</span><br><span class=\"line\">l: <span class=\"type\">List</span>[<span class=\"type\">String</span>] = <span class=\"type\">List</span>(a, b, c)</span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; <span class=\"keyword\">for</span> (</span><br><span class=\"line\">s &lt;- l</span><br><span class=\"line\">) println(s)</span><br><span class=\"line\">a</span><br><span class=\"line\">b</span><br><span class=\"line\">c</span><br></pre></td></tr></table></figure>\n<h2 id=\"try表达式\"><a href=\"#try表达式\" class=\"headerlink\" title=\"try表达式\"></a>try表达式</h2><figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span>&#123; &#125;</span><br><span class=\"line\"><span class=\"keyword\">catch</span>&#123; &#125;</span><br><span class=\"line\"><span class=\"keyword\">finally</span>&#123; &#125;</span><br></pre></td></tr></table></figure>\n<p>与Java不同，try是表达式，不是关键字。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">Integer</span>.parseInt(<span class=\"string\">\"abc\"</span>)</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">case</span> _ =&gt; <span class=\"number\">0</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">\tprintln(<span class=\"string\">\"always be printed\"</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"match表达式\"><a href=\"#match表达式\" class=\"headerlink\" title=\"match表达式\"></a>match表达式</h2><figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">exp <span class=\"keyword\">match</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">case</span> p1 =&gt; val1</span><br><span class=\"line\">\t<span class=\"keyword\">case</span> p2 =&gt; val2</span><br><span class=\"line\">\t...</span><br><span class=\"line\">\t<span class=\"keyword\">case</span> _ =&gt; valn</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> code = <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> result_match = code <span class=\"keyword\">match</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">case</span> <span class=\"number\">1</span> =&gt; <span class=\"string\">\"ONE\"</span></span><br><span class=\"line\">\t<span class=\"keyword\">case</span> <span class=\"number\">2</span> =&gt; <span class=\"string\">\"TWO\"</span></span><br><span class=\"line\">\t<span class=\"keyword\">case</span> _ =&gt; <span class=\"string\">\"OTHERS\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>_ 表示通配，相当于Java中switch语句的default关键字。</p>\n<h2 id=\"求值策略\"><a href=\"#求值策略\" class=\"headerlink\" title=\"求值策略\"></a>求值策略</h2><ul>\n<li>Call By Value 对函数实参求值，且仅求值一次</li>\n<li>Call By Name    函数实参每次在函数体内被用到时都会求值</li>\n</ul>\n<p>Scala默认使用Call By Value<br>如果函数形参类型以 =&gt; 开头，那么会使用Call By Name        </p>\n<p>def foo(x: Int) = x //call by value<br>def foo(x: =&gt; Int) = x //call by name    </p>\n<p>call by name在调用时不会解析入参中的表达式，call by value则相反。</p>\n<h2 id=\"函数-1\"><a href=\"#函数-1\" class=\"headerlink\" title=\"函数\"></a>函数</h2><p>Scala函数特性：    </p>\n<ol>\n<li>把函数作为实参传递给另一个函数。    </li>\n<li>把函数作为返回值。    </li>\n<li>把函数赋值给变量。    </li>\n<li>把函数存储在数据结构里。    </li>\n<li>函数和普通变量一样，具有函数的类型。</li>\n</ol>\n<h2 id=\"函数类型\"><a href=\"#函数类型\" class=\"headerlink\" title=\"函数类型\"></a>函数类型</h2><p>函数类型格式为 A =&gt; B ，表示一个接受类型A的参数，并返回类型B的函数。</p>\n<p>例子： Int =&gt; String 是把整型映射为字符串的函数类型。</p>\n<h2 id=\"高阶函数\"><a href=\"#高阶函数\" class=\"headerlink\" title=\"高阶函数\"></a>高阶函数</h2><p>用函数作为形参或返回值的函数，称为高阶函数。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">operate</span></span>(f: (<span class=\"type\">Int</span>, <span class=\"type\">Int</span>) =&gt; <span class=\"type\">Int</span>) = &#123;</span><br><span class=\"line\">\tf(<span class=\"number\">4</span>, <span class=\"number\">4</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">greeting</span></span>() = (name: <span class=\"type\">String</span>) =&gt; &#123;<span class=\"string\">\"hello\"</span> + <span class=\"string\">\" \"</span> + name&#125;\t<span class=\"comment\">//匿名函数</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"柯里化\"><a href=\"#柯里化\" class=\"headerlink\" title=\"柯里化\"></a>柯里化</h2><p>柯里化函数，把具有多个参数的函数转换为一条函数链，每个节点上是单一参数。</p>\n<p>例子：以下2个add函数定义是等价的</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">add</span></span>(x: <span class=\"type\">Int</span>, y: <span class=\"type\">Int</span>) = x + y\t</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">add</span></span>(x: <span class=\"type\">Int</span>)(y: <span class=\"type\">Int</span>) = x + y <span class=\"comment\">//Scala柯里化语法</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"尾递归函数\"><a href=\"#尾递归函数\" class=\"headerlink\" title=\"尾递归函数\"></a>尾递归函数</h2><p>尾递归函数中所有递归形式的调用都出现在函数的末尾。</p>\n<p>当编译器检测到一个函数调用是尾递归的时候，它就覆盖当前的活动记录而不是在栈中去创建一个新的。（避免堆栈内存溢出）</p>\n<p>例子：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@annotation</span>.tailrec</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">factorial</span></span>(n: <span class=\"type\">Int</span>, m: <span class=\"type\">Int</span>): <span class=\"type\">Int</span> =</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (n &lt;= <span class=\"number\">0</span>) m</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> factoria(n<span class=\"number\">-1</span>, m*n)</span><br><span class=\"line\">factorial(<span class=\"number\">5</span>, <span class=\"number\">1</span>)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">sum</span></span>(f: <span class=\"type\">Int</span> =&gt; <span class=\"type\">Int</span>)(a: <span class=\"type\">Int</span>)(b: <span class=\"type\">Int</span>): <span class=\"type\">Int</span> = &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@annotation</span>.tailrec</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">loop</span></span>(n: <span class=\"type\">Int</span>, acc: <span class=\"type\">Int</span>): <span class=\"type\">Int</span> = &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (n &gt; b) &#123;</span><br><span class=\"line\">        println(<span class=\"string\">s\"n=<span class=\"subst\">$&#123;n&#125;</span>, acc=<span class=\"subst\">$&#123;acc&#125;</span>\"</span>)</span><br><span class=\"line\">        acc</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        println(<span class=\"string\">s\"n=<span class=\"subst\">$&#123;n&#125;</span>, acc=<span class=\"subst\">$&#123;acc&#125;</span>\"</span>)</span><br><span class=\"line\">        loop(n + <span class=\"number\">1</span>, acc + f(n))</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    loop(a, <span class=\"number\">0</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  sum(x =&gt; x)(<span class=\"number\">1</span>)(<span class=\"number\">5</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//输出</span></span><br><span class=\"line\">n=<span class=\"number\">1</span>, acc=<span class=\"number\">0</span></span><br><span class=\"line\">n=<span class=\"number\">2</span>, acc=<span class=\"number\">1</span></span><br><span class=\"line\">n=<span class=\"number\">3</span>, acc=<span class=\"number\">3</span></span><br><span class=\"line\">n=<span class=\"number\">4</span>, acc=<span class=\"number\">6</span></span><br><span class=\"line\">n=<span class=\"number\">5</span>, acc=<span class=\"number\">10</span></span><br><span class=\"line\">n=<span class=\"number\">6</span>, acc=<span class=\"number\">15</span></span><br></pre></td></tr></table></figure>\n","excerpt":"","more":"<h2 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h2><ul>\n<li>val，定义immutable variable，不可变        </li>\n<li>var，定义mutable variable，可变</li>\n<li>lazy val，惰性常量    </li>\n</ul>\n<h2 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h2><p>超级父类 Any</p>\n<p>Byte, Short, Int, Long, Char, String, Float, Double, Boolean</p>\n<p>null表示对象引用类型为空，nothing表示程序异常终止。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scala&gt; <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">foo</span></span>()=<span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"type\">Exception</span>(<span class=\"string\">\"error\"</span>)</span><br><span class=\"line\">foo: ()<span class=\"type\">Nothing</span></span><br></pre></td></tr></table></figure>\n<p>String构建与Java的String之上，新增字符串插值特性。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> name = <span class=\"string\">\"Hello\"</span>\t</span><br><span class=\"line\"><span class=\"string\">s\"new name is <span class=\"subst\">$&#123;name&#125;</span>\"</span></span><br></pre></td></tr></table></figure>\n<p>可以不显示指定变量类型，Scala会自动进行类型推导。</p>\n<h2 id=\"代码块\"><a href=\"#代码块\" class=\"headerlink\" title=\"代码块\"></a>代码块</h2><figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;exp1 ;exp2&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">exp1</span><br><span class=\"line\">exp2</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>表达式可以写在一行，分号分隔。也可以写多行。</p>\n<h2 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h2><figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">functionName</span></span>( param: <span class=\"type\">ParamType</span>): <span class=\"type\">ReturnType</span> = &#123;</span><br><span class=\"line\">\t<span class=\"comment\">//function body: expressions</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scala&gt; <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">add</span></span>(x:<span class=\"type\">Int</span>, y:<span class=\"type\">Int</span>)= &#123;x+y&#125;</span><br><span class=\"line\">add: (x: <span class=\"type\">Int</span>, y: <span class=\"type\">Int</span>)<span class=\"type\">Int</span></span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; add(<span class=\"number\">1</span>,<span class=\"number\">1</span>)</span><br><span class=\"line\">res4: <span class=\"type\">Int</span> = <span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">add</span></span>(x:<span class=\"type\">Int</span>, y:<span class=\"type\">Int</span>):<span class=\"type\">Int</span>= &#123;x+y&#125;</span><br><span class=\"line\">add: (x: <span class=\"type\">Int</span>, y: <span class=\"type\">Int</span>)<span class=\"type\">Int</span></span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; add(<span class=\"number\">1</span>,<span class=\"number\">1</span>)</span><br><span class=\"line\">res5: <span class=\"type\">Int</span> = <span class=\"number\">2</span></span><br></pre></td></tr></table></figure>\n<p>多个参数用逗号分隔。</p>\n<h2 id=\"if表达式\"><a href=\"#if表达式\" class=\"headerlink\" title=\"if表达式\"></a>if表达式</h2><figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (logical_exp) valA <span class=\"keyword\">else</span> valB</span><br></pre></td></tr></table></figure>\n<p>和Java类似。</p>\n<h2 id=\"for表达式\"><a href=\"#for表达式\" class=\"headerlink\" title=\"for表达式\"></a>for表达式</h2><figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scala&gt; <span class=\"keyword\">val</span> l = <span class=\"type\">List</span>(<span class=\"string\">\"a\"</span>, <span class=\"string\">\"b\"</span>, <span class=\"string\">\"c\"</span>)</span><br><span class=\"line\">l: <span class=\"type\">List</span>[<span class=\"type\">String</span>] = <span class=\"type\">List</span>(a, b, c)</span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; <span class=\"keyword\">for</span> (</span><br><span class=\"line\">s &lt;- l</span><br><span class=\"line\">) println(s)</span><br><span class=\"line\">a</span><br><span class=\"line\">b</span><br><span class=\"line\">c</span><br></pre></td></tr></table></figure>\n<h2 id=\"try表达式\"><a href=\"#try表达式\" class=\"headerlink\" title=\"try表达式\"></a>try表达式</h2><figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span>&#123; &#125;</span><br><span class=\"line\"><span class=\"keyword\">catch</span>&#123; &#125;</span><br><span class=\"line\"><span class=\"keyword\">finally</span>&#123; &#125;</span><br></pre></td></tr></table></figure>\n<p>与Java不同，try是表达式，不是关键字。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">Integer</span>.parseInt(<span class=\"string\">\"abc\"</span>)</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">case</span> _ =&gt; <span class=\"number\">0</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">\tprintln(<span class=\"string\">\"always be printed\"</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"match表达式\"><a href=\"#match表达式\" class=\"headerlink\" title=\"match表达式\"></a>match表达式</h2><figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">exp <span class=\"keyword\">match</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">case</span> p1 =&gt; val1</span><br><span class=\"line\">\t<span class=\"keyword\">case</span> p2 =&gt; val2</span><br><span class=\"line\">\t...</span><br><span class=\"line\">\t<span class=\"keyword\">case</span> _ =&gt; valn</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> code = <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> result_match = code <span class=\"keyword\">match</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">case</span> <span class=\"number\">1</span> =&gt; <span class=\"string\">\"ONE\"</span></span><br><span class=\"line\">\t<span class=\"keyword\">case</span> <span class=\"number\">2</span> =&gt; <span class=\"string\">\"TWO\"</span></span><br><span class=\"line\">\t<span class=\"keyword\">case</span> _ =&gt; <span class=\"string\">\"OTHERS\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>_ 表示通配，相当于Java中switch语句的default关键字。</p>\n<h2 id=\"求值策略\"><a href=\"#求值策略\" class=\"headerlink\" title=\"求值策略\"></a>求值策略</h2><ul>\n<li>Call By Value 对函数实参求值，且仅求值一次</li>\n<li>Call By Name    函数实参每次在函数体内被用到时都会求值</li>\n</ul>\n<p>Scala默认使用Call By Value<br>如果函数形参类型以 =&gt; 开头，那么会使用Call By Name        </p>\n<p>def foo(x: Int) = x //call by value<br>def foo(x: =&gt; Int) = x //call by name    </p>\n<p>call by name在调用时不会解析入参中的表达式，call by value则相反。</p>\n<h2 id=\"函数-1\"><a href=\"#函数-1\" class=\"headerlink\" title=\"函数\"></a>函数</h2><p>Scala函数特性：    </p>\n<ol>\n<li>把函数作为实参传递给另一个函数。    </li>\n<li>把函数作为返回值。    </li>\n<li>把函数赋值给变量。    </li>\n<li>把函数存储在数据结构里。    </li>\n<li>函数和普通变量一样，具有函数的类型。</li>\n</ol>\n<h2 id=\"函数类型\"><a href=\"#函数类型\" class=\"headerlink\" title=\"函数类型\"></a>函数类型</h2><p>函数类型格式为 A =&gt; B ，表示一个接受类型A的参数，并返回类型B的函数。</p>\n<p>例子： Int =&gt; String 是把整型映射为字符串的函数类型。</p>\n<h2 id=\"高阶函数\"><a href=\"#高阶函数\" class=\"headerlink\" title=\"高阶函数\"></a>高阶函数</h2><p>用函数作为形参或返回值的函数，称为高阶函数。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">operate</span></span>(f: (<span class=\"type\">Int</span>, <span class=\"type\">Int</span>) =&gt; <span class=\"type\">Int</span>) = &#123;</span><br><span class=\"line\">\tf(<span class=\"number\">4</span>, <span class=\"number\">4</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">greeting</span></span>() = (name: <span class=\"type\">String</span>) =&gt; &#123;<span class=\"string\">\"hello\"</span> + <span class=\"string\">\" \"</span> + name&#125;\t<span class=\"comment\">//匿名函数</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"柯里化\"><a href=\"#柯里化\" class=\"headerlink\" title=\"柯里化\"></a>柯里化</h2><p>柯里化函数，把具有多个参数的函数转换为一条函数链，每个节点上是单一参数。</p>\n<p>例子：以下2个add函数定义是等价的</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">add</span></span>(x: <span class=\"type\">Int</span>, y: <span class=\"type\">Int</span>) = x + y\t</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">add</span></span>(x: <span class=\"type\">Int</span>)(y: <span class=\"type\">Int</span>) = x + y <span class=\"comment\">//Scala柯里化语法</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"尾递归函数\"><a href=\"#尾递归函数\" class=\"headerlink\" title=\"尾递归函数\"></a>尾递归函数</h2><p>尾递归函数中所有递归形式的调用都出现在函数的末尾。</p>\n<p>当编译器检测到一个函数调用是尾递归的时候，它就覆盖当前的活动记录而不是在栈中去创建一个新的。（避免堆栈内存溢出）</p>\n<p>例子：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@annotation</span>.tailrec</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">factorial</span></span>(n: <span class=\"type\">Int</span>, m: <span class=\"type\">Int</span>): <span class=\"type\">Int</span> =</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (n &lt;= <span class=\"number\">0</span>) m</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> factoria(n<span class=\"number\">-1</span>, m*n)</span><br><span class=\"line\">factorial(<span class=\"number\">5</span>, <span class=\"number\">1</span>)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">sum</span></span>(f: <span class=\"type\">Int</span> =&gt; <span class=\"type\">Int</span>)(a: <span class=\"type\">Int</span>)(b: <span class=\"type\">Int</span>): <span class=\"type\">Int</span> = &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@annotation</span>.tailrec</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">loop</span></span>(n: <span class=\"type\">Int</span>, acc: <span class=\"type\">Int</span>): <span class=\"type\">Int</span> = &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (n &gt; b) &#123;</span><br><span class=\"line\">        println(<span class=\"string\">s\"n=<span class=\"subst\">$&#123;n&#125;</span>, acc=<span class=\"subst\">$&#123;acc&#125;</span>\"</span>)</span><br><span class=\"line\">        acc</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        println(<span class=\"string\">s\"n=<span class=\"subst\">$&#123;n&#125;</span>, acc=<span class=\"subst\">$&#123;acc&#125;</span>\"</span>)</span><br><span class=\"line\">        loop(n + <span class=\"number\">1</span>, acc + f(n))</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    loop(a, <span class=\"number\">0</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  sum(x =&gt; x)(<span class=\"number\">1</span>)(<span class=\"number\">5</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//输出</span></span><br><span class=\"line\">n=<span class=\"number\">1</span>, acc=<span class=\"number\">0</span></span><br><span class=\"line\">n=<span class=\"number\">2</span>, acc=<span class=\"number\">1</span></span><br><span class=\"line\">n=<span class=\"number\">3</span>, acc=<span class=\"number\">3</span></span><br><span class=\"line\">n=<span class=\"number\">4</span>, acc=<span class=\"number\">6</span></span><br><span class=\"line\">n=<span class=\"number\">5</span>, acc=<span class=\"number\">10</span></span><br><span class=\"line\">n=<span class=\"number\">6</span>, acc=<span class=\"number\">15</span></span><br></pre></td></tr></table></figure>\n"},{"title":"RedisRDB文件结构","date":"2015-07-03T16:00:00.000Z","_content":"\nRedis RDB文件保存的是二进制数据，结构包括5部分:\nREDIS | db_version | databases | EOF | check_sum\n\ndb_version长度为4个字节，它的值是一个字符串表示的整数，记录RDB文件的版本号。\n\ndatabases记录数据库实例，和各个数据库实例的键值对数据，如果redis-server中所有db都为空，那这个值也为空，长度为0字节。\n\nEOF常量长度为1字节，标志着RDB文件正文内容结束。\n\ncheck_sum是一个8字节长的无符号整数，保存着一个校验和，这个校验和是程序通过对REDIS、db_version、databases、EOF四个部分内容计算而来。Redis在载入RDB文件时，会将载入数据的检验和与该值对比，以此来检查RDB文件是否出错或损坏。\n\n1.databases  \n每个非空数据库在RDB文件中的都保存为SELECTDB、db_number、key_value_pairs三个部分。  \nSELECTDB | db_number | key_value_pairs  \nSELECTDB常量长度为1字节，标识后面的数据库号码。  \ndb_number保存数据库号码，根据号码大小不同，长度为1字节、2字节或5字节。当程序读入db_number部分后，服务器啊会调用SELECT命令，根据读入的数据库号码进行数据库切换。\nkey_value_pairs保存了数据库中所有键值对数据，如果键值对带有过期时间，那么过期时间也会和键值对保存在一起。\n\n2.key_value_pairs  \n不带过期时间的键值对结构\nTYPE | key | value\n带过期时间的键值对结构\nEXPIRETIME_MS | ms | TYPE | key | value\n其中，TYPE记录value的类型，是以下常量中任意一个：\nREDIS_RDB_TYPE_STRING  \nREDIS_RDB_TYPE_LIST  \nREDIS_RDB_TYPE_SET  \nREDIS_RDB_TYPE_ZSET  \nREDIS_RDB_TYPE_HASH  \nREDIS_RDB_TYPE_LIST_ZIPLIST  \nREDIS_RDB_TYPE_SET_INSERT  \nREDIS_RDB_TYPE_ZSET_ZIPLIST  \nREDIS_RDB_TYPE_HASH_ZIPLIST  \nkey总是一个字符串对象，编码和REDIS_RDB_TYPE_STRING类型的value一样。  \nvalue根据TYPE类型不同，结构和长度也会不同。  \nEXPIRETIME_MS常量长度为1字节，当程序读入该常量时，会表示下一个读入的将是一个以毫秒为单位的过期时间。  \nms是一个8字节长的带符号整数，记录了一个以毫秒为单位的unix时间戳，即过期时间。\n\n3.value编码  \na.字符串对象  \nTYPE是REDIS_RDB_TYPE_STRING，字符串对象编码可以是REDIS_ENCODING_INT或者REDIS_ENCODING_RAW，对应保存的值类型是整数和字符串。  \n如果字符串对象编码为REDIS_ENCODING_RAW，字符串长度若大于20字节，那么这个字符串会被压缩保存，否则原样保存。  \n无压缩字符串结构  \nlen | string  \n压缩后结构  \nREDIS_RDB_ENC_LZF | compressed_len | origin_len | compressed_string  \n其中REDIS_RDB_ENC_LZF常量标志字符串已被LZF算法压缩，程序在读入过程中，碰到这个常量时，会根据之后的compressed_len和orgin_len和compressed_string 三部分对字符串进行解压。\n\nb.列表对象  \nTYPE为REDIS_RDB_TYPE_LIST，value保存的是一个REDIS_ENCODING_LINKEDLIST编码的列表对象，结构如下  \nlist_length | item1| item2 | item3 | ... | itemN  \nlist_length记录了列表的长度，item部分代表列表的项，每项都是字符串对象。\n\nc.集合对象  \nTYPE为REDIS_RDB_TYPE_SET，value保存的是一个REDIS_ENCODING_HT编码的对象集合，结构如下  \nset_size | elem1 | elem2 | elem3 | ... | elemN  \nset_size记录集合大小，elem开头部分代表元素集合，每个元素都是一个字符串对象。\n\nd.哈希表对象  \nTYPE为REDIS_RDB_TYPE_HASH，value保存的是一个REDIS_ENCODING_HT编码的集合对象，结构如下  \nhash_size | key_value_pair 1 | key_value_pair 2 | key_value_pair 3 | ... | key_value_pair N  \nhash_size记录了哈希表的大小。key_value_pair部分代表键值对，结构中的每个键值对都以键紧挨着值的方式排列。结构如下  \nkey1 | value1 | key2 | value2 | key3 | value3 | ....\n\ne.有序集合对象  \nTYPE为REDIS_RDB_TYPE_ZSET，value保存的是一个REDIS_ENCODING_SKIPLIST编码的有序集合对象。结构如下  \nsorted_set_size | elem1 | elem2 | elem3 | ... | elemN  \nsorted_set_size记录有序集合大小，elem开头部分代表有序集合中的元素，每个元素又分为成员 (member)和分值(score)两部分，成员是一个字符串对象，分值则是一个double类型的浮点数，程序在保存RDB文件时会先将分支转换成字符串对象，再用保存字符串的方法将分值保存起来。  \n有序集合中每个元素都是以成员紧挨着分值方式排列，结构如下  \nsorted_set_size | member1 | score 1 | member2 | score2 | ... | memberN | scoreN\n\nf.INTSET编码集合  \nTYPE为REDIS_RDB_TYPE_SET_INTSET，value保存的是一个整数集合对象，RDB保存这种对象方法是先将整数集合转换为字符串对象，再保存到RDB文件中。读取是相反。\n\ng.ZIPLIST编码的列表、哈希表或有序集合  \nTYPE为REDIS_RDB_TYPE_LIST_ZIPLIST、REDIS_RDB_TYPE_HASH_ZIPLIST或者REDIS_RDB_TYPE_ZSET_ZIPLIST，那么value保存的是一个压缩列表对象，RDB文件保存方法是:\n1)将压缩列表转换成一个字符串对象；\n2)将转换所得的字符串对象保存到RDB文件。\n读取时做对应类型转换即可。\n","source":"_posts/redis设计与实现/RedisRDB文件结构.md","raw":"---\ntitle: RedisRDB文件结构\ndate: 2015-07-04\ncategories: Redis设计与实现\ntags: Redis\n---\n\nRedis RDB文件保存的是二进制数据，结构包括5部分:\nREDIS | db_version | databases | EOF | check_sum\n\ndb_version长度为4个字节，它的值是一个字符串表示的整数，记录RDB文件的版本号。\n\ndatabases记录数据库实例，和各个数据库实例的键值对数据，如果redis-server中所有db都为空，那这个值也为空，长度为0字节。\n\nEOF常量长度为1字节，标志着RDB文件正文内容结束。\n\ncheck_sum是一个8字节长的无符号整数，保存着一个校验和，这个校验和是程序通过对REDIS、db_version、databases、EOF四个部分内容计算而来。Redis在载入RDB文件时，会将载入数据的检验和与该值对比，以此来检查RDB文件是否出错或损坏。\n\n1.databases  \n每个非空数据库在RDB文件中的都保存为SELECTDB、db_number、key_value_pairs三个部分。  \nSELECTDB | db_number | key_value_pairs  \nSELECTDB常量长度为1字节，标识后面的数据库号码。  \ndb_number保存数据库号码，根据号码大小不同，长度为1字节、2字节或5字节。当程序读入db_number部分后，服务器啊会调用SELECT命令，根据读入的数据库号码进行数据库切换。\nkey_value_pairs保存了数据库中所有键值对数据，如果键值对带有过期时间，那么过期时间也会和键值对保存在一起。\n\n2.key_value_pairs  \n不带过期时间的键值对结构\nTYPE | key | value\n带过期时间的键值对结构\nEXPIRETIME_MS | ms | TYPE | key | value\n其中，TYPE记录value的类型，是以下常量中任意一个：\nREDIS_RDB_TYPE_STRING  \nREDIS_RDB_TYPE_LIST  \nREDIS_RDB_TYPE_SET  \nREDIS_RDB_TYPE_ZSET  \nREDIS_RDB_TYPE_HASH  \nREDIS_RDB_TYPE_LIST_ZIPLIST  \nREDIS_RDB_TYPE_SET_INSERT  \nREDIS_RDB_TYPE_ZSET_ZIPLIST  \nREDIS_RDB_TYPE_HASH_ZIPLIST  \nkey总是一个字符串对象，编码和REDIS_RDB_TYPE_STRING类型的value一样。  \nvalue根据TYPE类型不同，结构和长度也会不同。  \nEXPIRETIME_MS常量长度为1字节，当程序读入该常量时，会表示下一个读入的将是一个以毫秒为单位的过期时间。  \nms是一个8字节长的带符号整数，记录了一个以毫秒为单位的unix时间戳，即过期时间。\n\n3.value编码  \na.字符串对象  \nTYPE是REDIS_RDB_TYPE_STRING，字符串对象编码可以是REDIS_ENCODING_INT或者REDIS_ENCODING_RAW，对应保存的值类型是整数和字符串。  \n如果字符串对象编码为REDIS_ENCODING_RAW，字符串长度若大于20字节，那么这个字符串会被压缩保存，否则原样保存。  \n无压缩字符串结构  \nlen | string  \n压缩后结构  \nREDIS_RDB_ENC_LZF | compressed_len | origin_len | compressed_string  \n其中REDIS_RDB_ENC_LZF常量标志字符串已被LZF算法压缩，程序在读入过程中，碰到这个常量时，会根据之后的compressed_len和orgin_len和compressed_string 三部分对字符串进行解压。\n\nb.列表对象  \nTYPE为REDIS_RDB_TYPE_LIST，value保存的是一个REDIS_ENCODING_LINKEDLIST编码的列表对象，结构如下  \nlist_length | item1| item2 | item3 | ... | itemN  \nlist_length记录了列表的长度，item部分代表列表的项，每项都是字符串对象。\n\nc.集合对象  \nTYPE为REDIS_RDB_TYPE_SET，value保存的是一个REDIS_ENCODING_HT编码的对象集合，结构如下  \nset_size | elem1 | elem2 | elem3 | ... | elemN  \nset_size记录集合大小，elem开头部分代表元素集合，每个元素都是一个字符串对象。\n\nd.哈希表对象  \nTYPE为REDIS_RDB_TYPE_HASH，value保存的是一个REDIS_ENCODING_HT编码的集合对象，结构如下  \nhash_size | key_value_pair 1 | key_value_pair 2 | key_value_pair 3 | ... | key_value_pair N  \nhash_size记录了哈希表的大小。key_value_pair部分代表键值对，结构中的每个键值对都以键紧挨着值的方式排列。结构如下  \nkey1 | value1 | key2 | value2 | key3 | value3 | ....\n\ne.有序集合对象  \nTYPE为REDIS_RDB_TYPE_ZSET，value保存的是一个REDIS_ENCODING_SKIPLIST编码的有序集合对象。结构如下  \nsorted_set_size | elem1 | elem2 | elem3 | ... | elemN  \nsorted_set_size记录有序集合大小，elem开头部分代表有序集合中的元素，每个元素又分为成员 (member)和分值(score)两部分，成员是一个字符串对象，分值则是一个double类型的浮点数，程序在保存RDB文件时会先将分支转换成字符串对象，再用保存字符串的方法将分值保存起来。  \n有序集合中每个元素都是以成员紧挨着分值方式排列，结构如下  \nsorted_set_size | member1 | score 1 | member2 | score2 | ... | memberN | scoreN\n\nf.INTSET编码集合  \nTYPE为REDIS_RDB_TYPE_SET_INTSET，value保存的是一个整数集合对象，RDB保存这种对象方法是先将整数集合转换为字符串对象，再保存到RDB文件中。读取是相反。\n\ng.ZIPLIST编码的列表、哈希表或有序集合  \nTYPE为REDIS_RDB_TYPE_LIST_ZIPLIST、REDIS_RDB_TYPE_HASH_ZIPLIST或者REDIS_RDB_TYPE_ZSET_ZIPLIST，那么value保存的是一个压缩列表对象，RDB文件保存方法是:\n1)将压缩列表转换成一个字符串对象；\n2)将转换所得的字符串对象保存到RDB文件。\n读取时做对应类型转换即可。\n","slug":"redis设计与实现/RedisRDB文件结构","published":1,"updated":"2019-05-17T05:57:58.560Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1j8f2hb000r7h9m8yrm344n","content":"<p>Redis RDB文件保存的是二进制数据，结构包括5部分:<br>REDIS | db_version | databases | EOF | check_sum</p>\n<p>db_version长度为4个字节，它的值是一个字符串表示的整数，记录RDB文件的版本号。</p>\n<p>databases记录数据库实例，和各个数据库实例的键值对数据，如果redis-server中所有db都为空，那这个值也为空，长度为0字节。</p>\n<p>EOF常量长度为1字节，标志着RDB文件正文内容结束。</p>\n<p>check_sum是一个8字节长的无符号整数，保存着一个校验和，这个校验和是程序通过对REDIS、db_version、databases、EOF四个部分内容计算而来。Redis在载入RDB文件时，会将载入数据的检验和与该值对比，以此来检查RDB文件是否出错或损坏。</p>\n<p>1.databases<br>每个非空数据库在RDB文件中的都保存为SELECTDB、db_number、key_value_pairs三个部分。<br>SELECTDB | db_number | key_value_pairs<br>SELECTDB常量长度为1字节，标识后面的数据库号码。<br>db_number保存数据库号码，根据号码大小不同，长度为1字节、2字节或5字节。当程序读入db_number部分后，服务器啊会调用SELECT命令，根据读入的数据库号码进行数据库切换。<br>key_value_pairs保存了数据库中所有键值对数据，如果键值对带有过期时间，那么过期时间也会和键值对保存在一起。</p>\n<p>2.key_value_pairs<br>不带过期时间的键值对结构<br>TYPE | key | value<br>带过期时间的键值对结构<br>EXPIRETIME_MS | ms | TYPE | key | value<br>其中，TYPE记录value的类型，是以下常量中任意一个：<br>REDIS_RDB_TYPE_STRING<br>REDIS_RDB_TYPE_LIST<br>REDIS_RDB_TYPE_SET<br>REDIS_RDB_TYPE_ZSET<br>REDIS_RDB_TYPE_HASH<br>REDIS_RDB_TYPE_LIST_ZIPLIST<br>REDIS_RDB_TYPE_SET_INSERT<br>REDIS_RDB_TYPE_ZSET_ZIPLIST<br>REDIS_RDB_TYPE_HASH_ZIPLIST<br>key总是一个字符串对象，编码和REDIS_RDB_TYPE_STRING类型的value一样。<br>value根据TYPE类型不同，结构和长度也会不同。<br>EXPIRETIME_MS常量长度为1字节，当程序读入该常量时，会表示下一个读入的将是一个以毫秒为单位的过期时间。<br>ms是一个8字节长的带符号整数，记录了一个以毫秒为单位的unix时间戳，即过期时间。</p>\n<p>3.value编码<br>a.字符串对象<br>TYPE是REDIS_RDB_TYPE_STRING，字符串对象编码可以是REDIS_ENCODING_INT或者REDIS_ENCODING_RAW，对应保存的值类型是整数和字符串。<br>如果字符串对象编码为REDIS_ENCODING_RAW，字符串长度若大于20字节，那么这个字符串会被压缩保存，否则原样保存。<br>无压缩字符串结构<br>len | string<br>压缩后结构<br>REDIS_RDB_ENC_LZF | compressed_len | origin_len | compressed_string<br>其中REDIS_RDB_ENC_LZF常量标志字符串已被LZF算法压缩，程序在读入过程中，碰到这个常量时，会根据之后的compressed_len和orgin_len和compressed_string 三部分对字符串进行解压。</p>\n<p>b.列表对象<br>TYPE为REDIS_RDB_TYPE_LIST，value保存的是一个REDIS_ENCODING_LINKEDLIST编码的列表对象，结构如下<br>list_length | item1| item2 | item3 | … | itemN<br>list_length记录了列表的长度，item部分代表列表的项，每项都是字符串对象。</p>\n<p>c.集合对象<br>TYPE为REDIS_RDB_TYPE_SET，value保存的是一个REDIS_ENCODING_HT编码的对象集合，结构如下<br>set_size | elem1 | elem2 | elem3 | … | elemN<br>set_size记录集合大小，elem开头部分代表元素集合，每个元素都是一个字符串对象。</p>\n<p>d.哈希表对象<br>TYPE为REDIS_RDB_TYPE_HASH，value保存的是一个REDIS_ENCODING_HT编码的集合对象，结构如下<br>hash_size | key_value_pair 1 | key_value_pair 2 | key_value_pair 3 | … | key_value_pair N<br>hash_size记录了哈希表的大小。key_value_pair部分代表键值对，结构中的每个键值对都以键紧挨着值的方式排列。结构如下<br>key1 | value1 | key2 | value2 | key3 | value3 | ….</p>\n<p>e.有序集合对象<br>TYPE为REDIS_RDB_TYPE_ZSET，value保存的是一个REDIS_ENCODING_SKIPLIST编码的有序集合对象。结构如下<br>sorted_set_size | elem1 | elem2 | elem3 | … | elemN<br>sorted_set_size记录有序集合大小，elem开头部分代表有序集合中的元素，每个元素又分为成员 (member)和分值(score)两部分，成员是一个字符串对象，分值则是一个double类型的浮点数，程序在保存RDB文件时会先将分支转换成字符串对象，再用保存字符串的方法将分值保存起来。<br>有序集合中每个元素都是以成员紧挨着分值方式排列，结构如下<br>sorted_set_size | member1 | score 1 | member2 | score2 | … | memberN | scoreN</p>\n<p>f.INTSET编码集合<br>TYPE为REDIS_RDB_TYPE_SET_INTSET，value保存的是一个整数集合对象，RDB保存这种对象方法是先将整数集合转换为字符串对象，再保存到RDB文件中。读取是相反。</p>\n<p>g.ZIPLIST编码的列表、哈希表或有序集合<br>TYPE为REDIS_RDB_TYPE_LIST_ZIPLIST、REDIS_RDB_TYPE_HASH_ZIPLIST或者REDIS_RDB_TYPE_ZSET_ZIPLIST，那么value保存的是一个压缩列表对象，RDB文件保存方法是:<br>1)将压缩列表转换成一个字符串对象；<br>2)将转换所得的字符串对象保存到RDB文件。<br>读取时做对应类型转换即可。</p>\n","excerpt":"","more":"<p>Redis RDB文件保存的是二进制数据，结构包括5部分:<br>REDIS | db_version | databases | EOF | check_sum</p>\n<p>db_version长度为4个字节，它的值是一个字符串表示的整数，记录RDB文件的版本号。</p>\n<p>databases记录数据库实例，和各个数据库实例的键值对数据，如果redis-server中所有db都为空，那这个值也为空，长度为0字节。</p>\n<p>EOF常量长度为1字节，标志着RDB文件正文内容结束。</p>\n<p>check_sum是一个8字节长的无符号整数，保存着一个校验和，这个校验和是程序通过对REDIS、db_version、databases、EOF四个部分内容计算而来。Redis在载入RDB文件时，会将载入数据的检验和与该值对比，以此来检查RDB文件是否出错或损坏。</p>\n<p>1.databases<br>每个非空数据库在RDB文件中的都保存为SELECTDB、db_number、key_value_pairs三个部分。<br>SELECTDB | db_number | key_value_pairs<br>SELECTDB常量长度为1字节，标识后面的数据库号码。<br>db_number保存数据库号码，根据号码大小不同，长度为1字节、2字节或5字节。当程序读入db_number部分后，服务器啊会调用SELECT命令，根据读入的数据库号码进行数据库切换。<br>key_value_pairs保存了数据库中所有键值对数据，如果键值对带有过期时间，那么过期时间也会和键值对保存在一起。</p>\n<p>2.key_value_pairs<br>不带过期时间的键值对结构<br>TYPE | key | value<br>带过期时间的键值对结构<br>EXPIRETIME_MS | ms | TYPE | key | value<br>其中，TYPE记录value的类型，是以下常量中任意一个：<br>REDIS_RDB_TYPE_STRING<br>REDIS_RDB_TYPE_LIST<br>REDIS_RDB_TYPE_SET<br>REDIS_RDB_TYPE_ZSET<br>REDIS_RDB_TYPE_HASH<br>REDIS_RDB_TYPE_LIST_ZIPLIST<br>REDIS_RDB_TYPE_SET_INSERT<br>REDIS_RDB_TYPE_ZSET_ZIPLIST<br>REDIS_RDB_TYPE_HASH_ZIPLIST<br>key总是一个字符串对象，编码和REDIS_RDB_TYPE_STRING类型的value一样。<br>value根据TYPE类型不同，结构和长度也会不同。<br>EXPIRETIME_MS常量长度为1字节，当程序读入该常量时，会表示下一个读入的将是一个以毫秒为单位的过期时间。<br>ms是一个8字节长的带符号整数，记录了一个以毫秒为单位的unix时间戳，即过期时间。</p>\n<p>3.value编码<br>a.字符串对象<br>TYPE是REDIS_RDB_TYPE_STRING，字符串对象编码可以是REDIS_ENCODING_INT或者REDIS_ENCODING_RAW，对应保存的值类型是整数和字符串。<br>如果字符串对象编码为REDIS_ENCODING_RAW，字符串长度若大于20字节，那么这个字符串会被压缩保存，否则原样保存。<br>无压缩字符串结构<br>len | string<br>压缩后结构<br>REDIS_RDB_ENC_LZF | compressed_len | origin_len | compressed_string<br>其中REDIS_RDB_ENC_LZF常量标志字符串已被LZF算法压缩，程序在读入过程中，碰到这个常量时，会根据之后的compressed_len和orgin_len和compressed_string 三部分对字符串进行解压。</p>\n<p>b.列表对象<br>TYPE为REDIS_RDB_TYPE_LIST，value保存的是一个REDIS_ENCODING_LINKEDLIST编码的列表对象，结构如下<br>list_length | item1| item2 | item3 | … | itemN<br>list_length记录了列表的长度，item部分代表列表的项，每项都是字符串对象。</p>\n<p>c.集合对象<br>TYPE为REDIS_RDB_TYPE_SET，value保存的是一个REDIS_ENCODING_HT编码的对象集合，结构如下<br>set_size | elem1 | elem2 | elem3 | … | elemN<br>set_size记录集合大小，elem开头部分代表元素集合，每个元素都是一个字符串对象。</p>\n<p>d.哈希表对象<br>TYPE为REDIS_RDB_TYPE_HASH，value保存的是一个REDIS_ENCODING_HT编码的集合对象，结构如下<br>hash_size | key_value_pair 1 | key_value_pair 2 | key_value_pair 3 | … | key_value_pair N<br>hash_size记录了哈希表的大小。key_value_pair部分代表键值对，结构中的每个键值对都以键紧挨着值的方式排列。结构如下<br>key1 | value1 | key2 | value2 | key3 | value3 | ….</p>\n<p>e.有序集合对象<br>TYPE为REDIS_RDB_TYPE_ZSET，value保存的是一个REDIS_ENCODING_SKIPLIST编码的有序集合对象。结构如下<br>sorted_set_size | elem1 | elem2 | elem3 | … | elemN<br>sorted_set_size记录有序集合大小，elem开头部分代表有序集合中的元素，每个元素又分为成员 (member)和分值(score)两部分，成员是一个字符串对象，分值则是一个double类型的浮点数，程序在保存RDB文件时会先将分支转换成字符串对象，再用保存字符串的方法将分值保存起来。<br>有序集合中每个元素都是以成员紧挨着分值方式排列，结构如下<br>sorted_set_size | member1 | score 1 | member2 | score2 | … | memberN | scoreN</p>\n<p>f.INTSET编码集合<br>TYPE为REDIS_RDB_TYPE_SET_INTSET，value保存的是一个整数集合对象，RDB保存这种对象方法是先将整数集合转换为字符串对象，再保存到RDB文件中。读取是相反。</p>\n<p>g.ZIPLIST编码的列表、哈希表或有序集合<br>TYPE为REDIS_RDB_TYPE_LIST_ZIPLIST、REDIS_RDB_TYPE_HASH_ZIPLIST或者REDIS_RDB_TYPE_ZSET_ZIPLIST，那么value保存的是一个压缩列表对象，RDB文件保存方法是:<br>1)将压缩列表转换成一个字符串对象；<br>2)将转换所得的字符串对象保存到RDB文件。<br>读取时做对应类型转换即可。</p>\n"},{"title":"Redis中的数据库","date":"2015-06-30T16:00:00.000Z","_content":"\nRedis服务器的所有数据库都保存在服务器状态 redis.h/redisServer结构的db数组中，db数组中每项都是一个 redis.h/redisDb结构，代表一个数据库实例。\n\n``` bash\nstruct redisServer {\n\t//...\n\tint dbnum;\n\t//...\n\tredisDb *db;\n\t//...\n} ;\n```\n\n\n初始化数据库实例默认是16个，可以用过select 0~15 来切换。\n``` bash\ntypeof struct redisClient {\n\t//...\n\t//记录客户端当前正在使用的数据库\n\tredisDb *db;\n\t//...\n} redisClient;\n```\n\nredisDb 结构中的dict字典保存了数据库中的所有键值对，这个字典称之为键空间。\n``` bash\ntypeof struct redisDb {\n\t//...\n\tdict *dict\n\t//...\n} redisDb;\n```\n我们在对键进行增删改查操作时候，其实就是在对dict的字典结构进行对应操作。\n\n读写键的维护操作：\n1.读取一个key后(读和写都要先读)，服务器会更新键空间命中次数和不命中次数。这2个值可以在INFO命令的status属性 keyspace_hit和keyspace_misses查看。\n2.读取一个key后，服务器会更新key的LRU(最后一次使用)时间，这个值可以用于计算key的闲置时间，使用Object idletime $key 命令可以查看。\n3.读取一个key时，发现该key已过期，会先删除。\n4.如果有watch命令监视了某个key，服务器在对该key进行修改后，会将这个键标记为脏(dirty)，从而让此key暴露给事物。\n5.服务器每修改一个key后，会对脏键计数器+1，这个计数器会触发redis的持久化以及复制操作。\n6.如果服务器开启了数据库通知功能，那么在key被修改后，redis会按配置发送相应的通知。\n\n\n\nRedis有4个命令可以设置键的过期时间：\n1. expire <key> <ttl> 设置key的生存时间为ttl秒；\n2. pexpire <key> <ttk> 设置key的生存时间为ttl毫秒； \n3. expireat <key> <ts> 设置key的过期时间为ts的秒数时间戳；\n4. pexpireat <key> <ts> 设置key的过期时间为ts的毫秒数时间戳；\n\n实际上 expire, pexpire, expireat 3个命令都是使用pexpireat实现的，只需要转换时间单位就行了。\n\nredisDb结构中，有一个expires字典保存了所有key的过期时间，这个字典称之为过期字典。\ntypeof struct redisDb {\n//...\ndict *expires;\n//...\n} redisDb;\n\n当一个key被设为过期后，redisDb中键空间字典和过期字典中的键重复，并不会出现重复对象，2个key指向的都是同一个对象。\n\nkey过期删除策略：\n1.定时删除：设置过期键的时候，创意一个定时器；\n2.惰性删除：放任过期键不管，每次访问时，判断是否过期，如过期则删除；\n3.定期删除：每隔一段时间，redis会扫描过期键，发现过期则删除；\n\nRedis实际使用的是惰性删除和定期删除2种配合使用。\n定期删除函数执行步骤：\n1.从一定量的数据库中去除一定数量的随机键检查，删除其中的过期键；\n2.全局变量current_db会记录当前函数检查的进度，并在下一次调用时，接着上一次的进度处理。\n3.随着函数不断被执行，所有过期键都会被检查到，这时将current_db变量重置为0，再开始新一轮的检查。\n","source":"_posts/redis设计与实现/Redis中的数据库.md","raw":"---\ntitle: Redis中的数据库\ndate: 2015-07-01\ncategories: Redis设计与实现\ntags: Redis\n---\n\nRedis服务器的所有数据库都保存在服务器状态 redis.h/redisServer结构的db数组中，db数组中每项都是一个 redis.h/redisDb结构，代表一个数据库实例。\n\n``` bash\nstruct redisServer {\n\t//...\n\tint dbnum;\n\t//...\n\tredisDb *db;\n\t//...\n} ;\n```\n\n\n初始化数据库实例默认是16个，可以用过select 0~15 来切换。\n``` bash\ntypeof struct redisClient {\n\t//...\n\t//记录客户端当前正在使用的数据库\n\tredisDb *db;\n\t//...\n} redisClient;\n```\n\nredisDb 结构中的dict字典保存了数据库中的所有键值对，这个字典称之为键空间。\n``` bash\ntypeof struct redisDb {\n\t//...\n\tdict *dict\n\t//...\n} redisDb;\n```\n我们在对键进行增删改查操作时候，其实就是在对dict的字典结构进行对应操作。\n\n读写键的维护操作：\n1.读取一个key后(读和写都要先读)，服务器会更新键空间命中次数和不命中次数。这2个值可以在INFO命令的status属性 keyspace_hit和keyspace_misses查看。\n2.读取一个key后，服务器会更新key的LRU(最后一次使用)时间，这个值可以用于计算key的闲置时间，使用Object idletime $key 命令可以查看。\n3.读取一个key时，发现该key已过期，会先删除。\n4.如果有watch命令监视了某个key，服务器在对该key进行修改后，会将这个键标记为脏(dirty)，从而让此key暴露给事物。\n5.服务器每修改一个key后，会对脏键计数器+1，这个计数器会触发redis的持久化以及复制操作。\n6.如果服务器开启了数据库通知功能，那么在key被修改后，redis会按配置发送相应的通知。\n\n\n\nRedis有4个命令可以设置键的过期时间：\n1. expire <key> <ttl> 设置key的生存时间为ttl秒；\n2. pexpire <key> <ttk> 设置key的生存时间为ttl毫秒； \n3. expireat <key> <ts> 设置key的过期时间为ts的秒数时间戳；\n4. pexpireat <key> <ts> 设置key的过期时间为ts的毫秒数时间戳；\n\n实际上 expire, pexpire, expireat 3个命令都是使用pexpireat实现的，只需要转换时间单位就行了。\n\nredisDb结构中，有一个expires字典保存了所有key的过期时间，这个字典称之为过期字典。\ntypeof struct redisDb {\n//...\ndict *expires;\n//...\n} redisDb;\n\n当一个key被设为过期后，redisDb中键空间字典和过期字典中的键重复，并不会出现重复对象，2个key指向的都是同一个对象。\n\nkey过期删除策略：\n1.定时删除：设置过期键的时候，创意一个定时器；\n2.惰性删除：放任过期键不管，每次访问时，判断是否过期，如过期则删除；\n3.定期删除：每隔一段时间，redis会扫描过期键，发现过期则删除；\n\nRedis实际使用的是惰性删除和定期删除2种配合使用。\n定期删除函数执行步骤：\n1.从一定量的数据库中去除一定数量的随机键检查，删除其中的过期键；\n2.全局变量current_db会记录当前函数检查的进度，并在下一次调用时，接着上一次的进度处理。\n3.随着函数不断被执行，所有过期键都会被检查到，这时将current_db变量重置为0，再开始新一轮的检查。\n","slug":"redis设计与实现/Redis中的数据库","published":1,"updated":"2019-05-17T05:57:58.560Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1j8f2hc000s7h9mzs437lzf","content":"<p>Redis服务器的所有数据库都保存在服务器状态 redis.h/redisServer结构的db数组中，db数组中每项都是一个 redis.h/redisDb结构，代表一个数据库实例。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct redisServer &#123;</span><br><span class=\"line\">\t//...</span><br><span class=\"line\">\tint dbnum;</span><br><span class=\"line\">\t//...</span><br><span class=\"line\">\tredisDb *db;</span><br><span class=\"line\">\t//...</span><br><span class=\"line\">&#125; ;</span><br></pre></td></tr></table></figure>\n<p>初始化数据库实例默认是16个，可以用过select 0~15 来切换。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typeof struct redisClient &#123;</span><br><span class=\"line\">\t//...</span><br><span class=\"line\">\t//记录客户端当前正在使用的数据库</span><br><span class=\"line\">\tredisDb *db;</span><br><span class=\"line\">\t//...</span><br><span class=\"line\">&#125; redisClient;</span><br></pre></td></tr></table></figure></p>\n<p>redisDb 结构中的dict字典保存了数据库中的所有键值对，这个字典称之为键空间。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typeof struct redisDb &#123;</span><br><span class=\"line\">\t//...</span><br><span class=\"line\">\tdict *dict</span><br><span class=\"line\">\t//...</span><br><span class=\"line\">&#125; redisDb;</span><br></pre></td></tr></table></figure></p>\n<p>我们在对键进行增删改查操作时候，其实就是在对dict的字典结构进行对应操作。</p>\n<p>读写键的维护操作：<br>1.读取一个key后(读和写都要先读)，服务器会更新键空间命中次数和不命中次数。这2个值可以在INFO命令的status属性 keyspace_hit和keyspace_misses查看。<br>2.读取一个key后，服务器会更新key的LRU(最后一次使用)时间，这个值可以用于计算key的闲置时间，使用Object idletime $key 命令可以查看。<br>3.读取一个key时，发现该key已过期，会先删除。<br>4.如果有watch命令监视了某个key，服务器在对该key进行修改后，会将这个键标记为脏(dirty)，从而让此key暴露给事物。<br>5.服务器每修改一个key后，会对脏键计数器+1，这个计数器会触发redis的持久化以及复制操作。<br>6.如果服务器开启了数据库通知功能，那么在key被修改后，redis会按配置发送相应的通知。</p>\n<p>Redis有4个命令可以设置键的过期时间：</p>\n<ol>\n<li>expire <key> <ttl> 设置key的生存时间为ttl秒；</ttl></key></li>\n<li>pexpire <key> <ttk> 设置key的生存时间为ttl毫秒； </ttk></key></li>\n<li>expireat <key> <ts> 设置key的过期时间为ts的秒数时间戳；</ts></key></li>\n<li>pexpireat <key> <ts> 设置key的过期时间为ts的毫秒数时间戳；</ts></key></li>\n</ol>\n<p>实际上 expire, pexpire, expireat 3个命令都是使用pexpireat实现的，只需要转换时间单位就行了。</p>\n<p>redisDb结构中，有一个expires字典保存了所有key的过期时间，这个字典称之为过期字典。<br>typeof struct redisDb {<br>//…<br>dict *expires;<br>//…<br>} redisDb;</p>\n<p>当一个key被设为过期后，redisDb中键空间字典和过期字典中的键重复，并不会出现重复对象，2个key指向的都是同一个对象。</p>\n<p>key过期删除策略：<br>1.定时删除：设置过期键的时候，创意一个定时器；<br>2.惰性删除：放任过期键不管，每次访问时，判断是否过期，如过期则删除；<br>3.定期删除：每隔一段时间，redis会扫描过期键，发现过期则删除；</p>\n<p>Redis实际使用的是惰性删除和定期删除2种配合使用。<br>定期删除函数执行步骤：<br>1.从一定量的数据库中去除一定数量的随机键检查，删除其中的过期键；<br>2.全局变量current_db会记录当前函数检查的进度，并在下一次调用时，接着上一次的进度处理。<br>3.随着函数不断被执行，所有过期键都会被检查到，这时将current_db变量重置为0，再开始新一轮的检查。</p>\n","excerpt":"","more":"<p>Redis服务器的所有数据库都保存在服务器状态 redis.h/redisServer结构的db数组中，db数组中每项都是一个 redis.h/redisDb结构，代表一个数据库实例。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct redisServer &#123;</span><br><span class=\"line\">\t//...</span><br><span class=\"line\">\tint dbnum;</span><br><span class=\"line\">\t//...</span><br><span class=\"line\">\tredisDb *db;</span><br><span class=\"line\">\t//...</span><br><span class=\"line\">&#125; ;</span><br></pre></td></tr></table></figure>\n<p>初始化数据库实例默认是16个，可以用过select 0~15 来切换。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typeof struct redisClient &#123;</span><br><span class=\"line\">\t//...</span><br><span class=\"line\">\t//记录客户端当前正在使用的数据库</span><br><span class=\"line\">\tredisDb *db;</span><br><span class=\"line\">\t//...</span><br><span class=\"line\">&#125; redisClient;</span><br></pre></td></tr></table></figure></p>\n<p>redisDb 结构中的dict字典保存了数据库中的所有键值对，这个字典称之为键空间。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typeof struct redisDb &#123;</span><br><span class=\"line\">\t//...</span><br><span class=\"line\">\tdict *dict</span><br><span class=\"line\">\t//...</span><br><span class=\"line\">&#125; redisDb;</span><br></pre></td></tr></table></figure></p>\n<p>我们在对键进行增删改查操作时候，其实就是在对dict的字典结构进行对应操作。</p>\n<p>读写键的维护操作：<br>1.读取一个key后(读和写都要先读)，服务器会更新键空间命中次数和不命中次数。这2个值可以在INFO命令的status属性 keyspace_hit和keyspace_misses查看。<br>2.读取一个key后，服务器会更新key的LRU(最后一次使用)时间，这个值可以用于计算key的闲置时间，使用Object idletime $key 命令可以查看。<br>3.读取一个key时，发现该key已过期，会先删除。<br>4.如果有watch命令监视了某个key，服务器在对该key进行修改后，会将这个键标记为脏(dirty)，从而让此key暴露给事物。<br>5.服务器每修改一个key后，会对脏键计数器+1，这个计数器会触发redis的持久化以及复制操作。<br>6.如果服务器开启了数据库通知功能，那么在key被修改后，redis会按配置发送相应的通知。</p>\n<p>Redis有4个命令可以设置键的过期时间：</p>\n<ol>\n<li>expire <key> <ttl> 设置key的生存时间为ttl秒；</li>\n<li>pexpire <key> <ttk> 设置key的生存时间为ttl毫秒； </li>\n<li>expireat <key> <ts> 设置key的过期时间为ts的秒数时间戳；</li>\n<li>pexpireat <key> <ts> 设置key的过期时间为ts的毫秒数时间戳；</li>\n</ol>\n<p>实际上 expire, pexpire, expireat 3个命令都是使用pexpireat实现的，只需要转换时间单位就行了。</p>\n<p>redisDb结构中，有一个expires字典保存了所有key的过期时间，这个字典称之为过期字典。<br>typeof struct redisDb {<br>//…<br>dict *expires;<br>//…<br>} redisDb;</p>\n<p>当一个key被设为过期后，redisDb中键空间字典和过期字典中的键重复，并不会出现重复对象，2个key指向的都是同一个对象。</p>\n<p>key过期删除策略：<br>1.定时删除：设置过期键的时候，创意一个定时器；<br>2.惰性删除：放任过期键不管，每次访问时，判断是否过期，如过期则删除；<br>3.定期删除：每隔一段时间，redis会扫描过期键，发现过期则删除；</p>\n<p>Redis实际使用的是惰性删除和定期删除2种配合使用。<br>定期删除函数执行步骤：<br>1.从一定量的数据库中去除一定数量的随机键检查，删除其中的过期键；<br>2.全局变量current_db会记录当前函数检查的进度，并在下一次调用时，接着上一次的进度处理。<br>3.随着函数不断被执行，所有过期键都会被检查到，这时将current_db变量重置为0，再开始新一轮的检查。</p>\n"},{"title":"Redis压缩列表","date":"2015-06-26T16:00:00.000Z","_content":"\n压缩列表（ziplist）是列表键和哈希键的底层实现之一。当一个列表键只包含少量列表项，并且每项都是小整数或短字符串时，Redis就会使用压缩列表作为列表键的底层实现。\n\nziplis组成：\nzlbytes : 记录列表占用内存字节数：在重新分配内存或计算zlend时使用\nzltail : 记录压缩列表表尾节点距离列表的起始地址有多少字节\nzllen : 记录压缩列表包含节点数量\nentryX : 各个节点\nzlend : 标记压缩列表末端\n\n压缩列表节点构成 entryX :\nprevious_entry_length : 记录前1个节点长度，单位为字节，程序可通过指针运算，根据当前节点的起始地址计算出前一个节点的起始地址。如前一节点长度小于254字节，则值为1个字节；反之若前一节点长度大于等于254字节，值为5字节，其中第一字节为0xFE(十进制254)，之后4个字节用于保存前1节点长度。\nencoding : 记录节点的content属性所保存数据的类型及长度\ncontent : 节点值\n\n连锁更新\n例如在一个压缩列表中，有多个连续的长度为250-253的节点e1至eN，现在在表头插入一个长度大于254的节点。\n想像一下，新节点插入后，e1需要修改previous_entry_length的值从1个字节扩展到5个字节，并且该变化会递归到eN。\n因此连锁更新在最坏的情况下需要对压缩列表执行N次空间重分配，每次空间重分配的最坏复杂度为O(N)，所以连锁更新的最坏复杂度为O(N平方)。\n但尽管该操作复杂度较高，但实际环境中，存在多个连续的250-253字节长度之间的节点并不多，所以我们可以不必担心连锁更新对性能的影响。\n","source":"_posts/redis设计与实现/Redis压缩列表.md","raw":"---\ntitle: Redis压缩列表\ndate: 2015-06-27\ncategories: Redis设计与实现\ntags: Redis\n---\n\n压缩列表（ziplist）是列表键和哈希键的底层实现之一。当一个列表键只包含少量列表项，并且每项都是小整数或短字符串时，Redis就会使用压缩列表作为列表键的底层实现。\n\nziplis组成：\nzlbytes : 记录列表占用内存字节数：在重新分配内存或计算zlend时使用\nzltail : 记录压缩列表表尾节点距离列表的起始地址有多少字节\nzllen : 记录压缩列表包含节点数量\nentryX : 各个节点\nzlend : 标记压缩列表末端\n\n压缩列表节点构成 entryX :\nprevious_entry_length : 记录前1个节点长度，单位为字节，程序可通过指针运算，根据当前节点的起始地址计算出前一个节点的起始地址。如前一节点长度小于254字节，则值为1个字节；反之若前一节点长度大于等于254字节，值为5字节，其中第一字节为0xFE(十进制254)，之后4个字节用于保存前1节点长度。\nencoding : 记录节点的content属性所保存数据的类型及长度\ncontent : 节点值\n\n连锁更新\n例如在一个压缩列表中，有多个连续的长度为250-253的节点e1至eN，现在在表头插入一个长度大于254的节点。\n想像一下，新节点插入后，e1需要修改previous_entry_length的值从1个字节扩展到5个字节，并且该变化会递归到eN。\n因此连锁更新在最坏的情况下需要对压缩列表执行N次空间重分配，每次空间重分配的最坏复杂度为O(N)，所以连锁更新的最坏复杂度为O(N平方)。\n但尽管该操作复杂度较高，但实际环境中，存在多个连续的250-253字节长度之间的节点并不多，所以我们可以不必担心连锁更新对性能的影响。\n","slug":"redis设计与实现/Redis压缩列表","published":1,"updated":"2019-05-17T05:57:58.562Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1j8f2hd000t7h9mcr3e8tzd","content":"<p>压缩列表（ziplist）是列表键和哈希键的底层实现之一。当一个列表键只包含少量列表项，并且每项都是小整数或短字符串时，Redis就会使用压缩列表作为列表键的底层实现。</p>\n<p>ziplis组成：<br>zlbytes : 记录列表占用内存字节数：在重新分配内存或计算zlend时使用<br>zltail : 记录压缩列表表尾节点距离列表的起始地址有多少字节<br>zllen : 记录压缩列表包含节点数量<br>entryX : 各个节点<br>zlend : 标记压缩列表末端</p>\n<p>压缩列表节点构成 entryX :<br>previous_entry_length : 记录前1个节点长度，单位为字节，程序可通过指针运算，根据当前节点的起始地址计算出前一个节点的起始地址。如前一节点长度小于254字节，则值为1个字节；反之若前一节点长度大于等于254字节，值为5字节，其中第一字节为0xFE(十进制254)，之后4个字节用于保存前1节点长度。<br>encoding : 记录节点的content属性所保存数据的类型及长度<br>content : 节点值</p>\n<p>连锁更新<br>例如在一个压缩列表中，有多个连续的长度为250-253的节点e1至eN，现在在表头插入一个长度大于254的节点。<br>想像一下，新节点插入后，e1需要修改previous_entry_length的值从1个字节扩展到5个字节，并且该变化会递归到eN。<br>因此连锁更新在最坏的情况下需要对压缩列表执行N次空间重分配，每次空间重分配的最坏复杂度为O(N)，所以连锁更新的最坏复杂度为O(N平方)。<br>但尽管该操作复杂度较高，但实际环境中，存在多个连续的250-253字节长度之间的节点并不多，所以我们可以不必担心连锁更新对性能的影响。</p>\n","excerpt":"","more":"<p>压缩列表（ziplist）是列表键和哈希键的底层实现之一。当一个列表键只包含少量列表项，并且每项都是小整数或短字符串时，Redis就会使用压缩列表作为列表键的底层实现。</p>\n<p>ziplis组成：<br>zlbytes : 记录列表占用内存字节数：在重新分配内存或计算zlend时使用<br>zltail : 记录压缩列表表尾节点距离列表的起始地址有多少字节<br>zllen : 记录压缩列表包含节点数量<br>entryX : 各个节点<br>zlend : 标记压缩列表末端</p>\n<p>压缩列表节点构成 entryX :<br>previous_entry_length : 记录前1个节点长度，单位为字节，程序可通过指针运算，根据当前节点的起始地址计算出前一个节点的起始地址。如前一节点长度小于254字节，则值为1个字节；反之若前一节点长度大于等于254字节，值为5字节，其中第一字节为0xFE(十进制254)，之后4个字节用于保存前1节点长度。<br>encoding : 记录节点的content属性所保存数据的类型及长度<br>content : 节点值</p>\n<p>连锁更新<br>例如在一个压缩列表中，有多个连续的长度为250-253的节点e1至eN，现在在表头插入一个长度大于254的节点。<br>想像一下，新节点插入后，e1需要修改previous_entry_length的值从1个字节扩展到5个字节，并且该变化会递归到eN。<br>因此连锁更新在最坏的情况下需要对压缩列表执行N次空间重分配，每次空间重分配的最坏复杂度为O(N)，所以连锁更新的最坏复杂度为O(N平方)。<br>但尽管该操作复杂度较高，但实际环境中，存在多个连续的250-253字节长度之间的节点并不多，所以我们可以不必担心连锁更新对性能的影响。</p>\n"},{"title":"Redis哈希对象","date":"2015-06-27T16:00:00.000Z","_content":"\n哈希对象编码可以是ziplist或者hashtable。\n\nziplist编码的哈希对象使用压缩列表作为底层实现。有新的键值对要保存时，程序会先将键值对的键推到列表表尾，再将键值对的值推到列表表尾。\n\nhashtable编码的哈希对象使用字典作为底层实现，哈希对象中的每个键值对都是用一个字典键值对来保存。\n\n当哈希对象满足下面2个条件时，哈希对象使用ziplist编码，其余都使用hashtable编码：\na.哈希对象保存所有键值对的键和值字符长度都小于64字节；\nb.哈希对象保存的键值对数量小于512个；\n\n上述2个条件的阀值是可以修改的，在配置文件中的 hash-max-ziplist-value 和 hash-max-ziplist-entries 选项中。\n","source":"_posts/redis设计与实现/Redis哈希对象.md","raw":"---\ntitle: Redis哈希对象\ndate: 2015-06-28\ncategories: Redis设计与实现\ntags: Redis\n---\n\n哈希对象编码可以是ziplist或者hashtable。\n\nziplist编码的哈希对象使用压缩列表作为底层实现。有新的键值对要保存时，程序会先将键值对的键推到列表表尾，再将键值对的值推到列表表尾。\n\nhashtable编码的哈希对象使用字典作为底层实现，哈希对象中的每个键值对都是用一个字典键值对来保存。\n\n当哈希对象满足下面2个条件时，哈希对象使用ziplist编码，其余都使用hashtable编码：\na.哈希对象保存所有键值对的键和值字符长度都小于64字节；\nb.哈希对象保存的键值对数量小于512个；\n\n上述2个条件的阀值是可以修改的，在配置文件中的 hash-max-ziplist-value 和 hash-max-ziplist-entries 选项中。\n","slug":"redis设计与实现/Redis哈希对象","published":1,"updated":"2019-05-17T05:57:58.562Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1j8f2he000u7h9mu2d9rsps","content":"<p>哈希对象编码可以是ziplist或者hashtable。</p>\n<p>ziplist编码的哈希对象使用压缩列表作为底层实现。有新的键值对要保存时，程序会先将键值对的键推到列表表尾，再将键值对的值推到列表表尾。</p>\n<p>hashtable编码的哈希对象使用字典作为底层实现，哈希对象中的每个键值对都是用一个字典键值对来保存。</p>\n<p>当哈希对象满足下面2个条件时，哈希对象使用ziplist编码，其余都使用hashtable编码：<br>a.哈希对象保存所有键值对的键和值字符长度都小于64字节；<br>b.哈希对象保存的键值对数量小于512个；</p>\n<p>上述2个条件的阀值是可以修改的，在配置文件中的 hash-max-ziplist-value 和 hash-max-ziplist-entries 选项中。</p>\n","excerpt":"","more":"<p>哈希对象编码可以是ziplist或者hashtable。</p>\n<p>ziplist编码的哈希对象使用压缩列表作为底层实现。有新的键值对要保存时，程序会先将键值对的键推到列表表尾，再将键值对的值推到列表表尾。</p>\n<p>hashtable编码的哈希对象使用字典作为底层实现，哈希对象中的每个键值对都是用一个字典键值对来保存。</p>\n<p>当哈希对象满足下面2个条件时，哈希对象使用ziplist编码，其余都使用hashtable编码：<br>a.哈希对象保存所有键值对的键和值字符长度都小于64字节；<br>b.哈希对象保存的键值对数量小于512个；</p>\n<p>上述2个条件的阀值是可以修改的，在配置文件中的 hash-max-ziplist-value 和 hash-max-ziplist-entries 选项中。</p>\n"},{"title":"Redis字典","date":"2015-06-24T16:00:00.000Z","_content":"\n字典就是我们熟悉的map，键值对(key-value pair)的抽象数据结构。Redis数据库就是使用字典来作为底层实现的。\n先介绍下数据结构：\n1.哈希表\n``` bash\ntypeof struct dictht {\n\t//哈希表数组\n\tdictEntry   **table;\n\t//哈希表大小\n\tunsigned long size;\n\t//哈希表大小掩码，用于计算索引\n\t//总是等于size-1\n\tunsigned long sizemask;\n\t//已有节点数量\n\tunsigned long used;\n} dictht;\n```\n\n这种数据结构很好理解，和Java里面HashMap实现差不多。哈希表里面每个节点都是一个entry对象。\n\n2.哈希表节点\n``` bash\ntypeof struct dictEntry {\n\t//键\n\tvoid *key;\n\t//值\n\tunion {\n\tvoid *val;\n\tunit64_t u64;\n\tint64_t s64;\n} v;\n\n//指向下个哈希表节点，形成链表\nstruct dictEntry *next;\n} dictEntry;\n```\n\nkey属性存着键值对中的键，v属性存值。键可以是一个指针，也可以是一个unit64_t整数，或是一个int^4_t整数。C语言没了解过，这种奇怪的整数也不知道什么意思，姑且理解为Java里面的hashCode吧。\nnext属性指向链表中的下一个节点，这点和Java一样，当多个对象哈希值相同时，就造成hash冲突，多个对象的索引值都落在同一索引下标上，该节点的数据结构为链表，需要遍历该链表才能找到对应元素。\n\n3.字典数据结构\n``` bash\ntypeof struct dict {\n\t//类型特定函数\n\tdictType *type;\n\t//私有数据\n\tvoid *privdata;\n\t//哈希表\n\tdictht ht[2];\n\t//rehash索引\n\t//当rehash不再进行时，值为-1\n\tint rehashidx;\n} dict;\n```\n\ntype属性和privdata属性针对不同类型的键值对，为创建多态字典设置的。\ntype属性是一个指向dictType结构的指针，每个dictType保存了一簇用于操作特定类型键值对的函数，Redis会为用途不同的字典设置不同的类型特定函数。\nprivdata属性保存了需要传给那些类型特定函数的可选参数。\n\n``` bash\ntypeof struct dictType {\n\t//计算哈希值的函数\n\tunsigned int (*hashFunction) (const void *key);\n\t//复制键的函数\n\tvoid *(*keyDup) (void *privdata, const void *key);\n\t//复制值的函数\n\tvoid *(*valDup)(void *privdata, const void *obj);\n\t//对比键的函数\n\tint (*keyCompare) (void *privdata, const void *key1, const void *key2);\n\t//销毁键的函数\n\tvoid (*keyDestructor) (void *privdata, void *key);\n\t//销毁值的函数\n\tvoid (*valDestructor) (void *privdata, void *obj);\n} dictType;\n```\n\nht属性是一个包含2个索引的数组，每个位置都是一个dictht哈希表，一般使用ht[0]，ht[1]用于存放对ht[0]哈希表进行rehash的结果。\nrehashidx记录目前rehash进度，当前没有执行rehash，值为-1。\n\n\n1.Redis 字典 Hash算法\n根据key计算hash值\nhash = dict -> type -> hashFunction(key);\n根据sizemask属性和哈希值,计算出索引,ht[x]可以是ht[0]或ht[1]\nindex = hash & dict -> ht[x].sizemask;\nRedis使用MurmurHash2算法计算键的哈希值，优点在于即使输入的键是有规律的，算法仍能给出一个很好的随机分布性。\n\n2.解决Hash冲突\n当2个或多个不同对象的Hash值相同时，会被分配到哈希表的同一个索引上，此时就称之为哈希冲突。\nRedis采用链地址法解决键冲突，每个哈希节点都有一个next指针，由此指针构成一个单向链表，新添加的元素在链表表头。\n\n3.rehash\n负载因子 = 哈希表节点数量/哈希表大小\nload_factor = ht[0].used / ht[0].size\n当哈希表的操作不断进行，需要把哈希表的负载因子保持在一个合理范围内，需要对哈希表进行扩容或缩容操作，2种操作都通过执行再散列操作来执行(rehash)：\na.为字典的ht[1]分配空间，如果是扩容操作，ht[1]的空间为ht[0]的节点数量2倍;如果是缩容,ht[1]的空间为ht[0]节点数量的一半。\nb.将ht[0]中的所有键值对rehash到ht[1]上面：rehash需要重新计算键的哈希值和索引值，然后放在ht[1]的指定位置上。\nc.当ht[0]所有键值对都迁移到ht[1]上之后，释放ht[0]，就是将ht[0]表置为空表，再将ht[1]置为ht[0],并将ht[1]新建一个大小为0的空哈希表。\n\n4.渐进式rehash\n上面讲到rehash过程中，需要将ht[0]上的键值对迁移到ht[1]上，但这个过程并不是一次性操作完成的。如果需要一次性完成，就必须对当前哈希表进行锁表操作，锁表期间会导致服务的不可用，所以rehash操作需要分多次、渐进式的完成。\na.为ht[1]分配空间，字典同时持有ht[0]和ht[1]两个哈希表\nb.将rehashidx值置为0，表示rehash工作开始。\nc.rehash期间，所有对字典执行的读写操作，都会在ht[0]和ht[1]两个表上操作，读操作如果在ht[0]上找到，会把结果rehash到ht[1]上，如果未找到会到ht[1]上去找，保存操作只会存在ht[1]上，当rehash工作完成之后,rehashidx++;\nd.随着字典操作的不断执行，最终ht[0]上所有节点会全部rehash到ht[1]上，这时将rehashidx值置为-1，表示rehash完成。\n","source":"_posts/redis设计与实现/Redis字典的实现.md","raw":"---\ntitle: Redis字典\ndate: 2015-06-25\ncategories: Redis设计与实现\ntags: Redis\n---\n\n字典就是我们熟悉的map，键值对(key-value pair)的抽象数据结构。Redis数据库就是使用字典来作为底层实现的。\n先介绍下数据结构：\n1.哈希表\n``` bash\ntypeof struct dictht {\n\t//哈希表数组\n\tdictEntry   **table;\n\t//哈希表大小\n\tunsigned long size;\n\t//哈希表大小掩码，用于计算索引\n\t//总是等于size-1\n\tunsigned long sizemask;\n\t//已有节点数量\n\tunsigned long used;\n} dictht;\n```\n\n这种数据结构很好理解，和Java里面HashMap实现差不多。哈希表里面每个节点都是一个entry对象。\n\n2.哈希表节点\n``` bash\ntypeof struct dictEntry {\n\t//键\n\tvoid *key;\n\t//值\n\tunion {\n\tvoid *val;\n\tunit64_t u64;\n\tint64_t s64;\n} v;\n\n//指向下个哈希表节点，形成链表\nstruct dictEntry *next;\n} dictEntry;\n```\n\nkey属性存着键值对中的键，v属性存值。键可以是一个指针，也可以是一个unit64_t整数，或是一个int^4_t整数。C语言没了解过，这种奇怪的整数也不知道什么意思，姑且理解为Java里面的hashCode吧。\nnext属性指向链表中的下一个节点，这点和Java一样，当多个对象哈希值相同时，就造成hash冲突，多个对象的索引值都落在同一索引下标上，该节点的数据结构为链表，需要遍历该链表才能找到对应元素。\n\n3.字典数据结构\n``` bash\ntypeof struct dict {\n\t//类型特定函数\n\tdictType *type;\n\t//私有数据\n\tvoid *privdata;\n\t//哈希表\n\tdictht ht[2];\n\t//rehash索引\n\t//当rehash不再进行时，值为-1\n\tint rehashidx;\n} dict;\n```\n\ntype属性和privdata属性针对不同类型的键值对，为创建多态字典设置的。\ntype属性是一个指向dictType结构的指针，每个dictType保存了一簇用于操作特定类型键值对的函数，Redis会为用途不同的字典设置不同的类型特定函数。\nprivdata属性保存了需要传给那些类型特定函数的可选参数。\n\n``` bash\ntypeof struct dictType {\n\t//计算哈希值的函数\n\tunsigned int (*hashFunction) (const void *key);\n\t//复制键的函数\n\tvoid *(*keyDup) (void *privdata, const void *key);\n\t//复制值的函数\n\tvoid *(*valDup)(void *privdata, const void *obj);\n\t//对比键的函数\n\tint (*keyCompare) (void *privdata, const void *key1, const void *key2);\n\t//销毁键的函数\n\tvoid (*keyDestructor) (void *privdata, void *key);\n\t//销毁值的函数\n\tvoid (*valDestructor) (void *privdata, void *obj);\n} dictType;\n```\n\nht属性是一个包含2个索引的数组，每个位置都是一个dictht哈希表，一般使用ht[0]，ht[1]用于存放对ht[0]哈希表进行rehash的结果。\nrehashidx记录目前rehash进度，当前没有执行rehash，值为-1。\n\n\n1.Redis 字典 Hash算法\n根据key计算hash值\nhash = dict -> type -> hashFunction(key);\n根据sizemask属性和哈希值,计算出索引,ht[x]可以是ht[0]或ht[1]\nindex = hash & dict -> ht[x].sizemask;\nRedis使用MurmurHash2算法计算键的哈希值，优点在于即使输入的键是有规律的，算法仍能给出一个很好的随机分布性。\n\n2.解决Hash冲突\n当2个或多个不同对象的Hash值相同时，会被分配到哈希表的同一个索引上，此时就称之为哈希冲突。\nRedis采用链地址法解决键冲突，每个哈希节点都有一个next指针，由此指针构成一个单向链表，新添加的元素在链表表头。\n\n3.rehash\n负载因子 = 哈希表节点数量/哈希表大小\nload_factor = ht[0].used / ht[0].size\n当哈希表的操作不断进行，需要把哈希表的负载因子保持在一个合理范围内，需要对哈希表进行扩容或缩容操作，2种操作都通过执行再散列操作来执行(rehash)：\na.为字典的ht[1]分配空间，如果是扩容操作，ht[1]的空间为ht[0]的节点数量2倍;如果是缩容,ht[1]的空间为ht[0]节点数量的一半。\nb.将ht[0]中的所有键值对rehash到ht[1]上面：rehash需要重新计算键的哈希值和索引值，然后放在ht[1]的指定位置上。\nc.当ht[0]所有键值对都迁移到ht[1]上之后，释放ht[0]，就是将ht[0]表置为空表，再将ht[1]置为ht[0],并将ht[1]新建一个大小为0的空哈希表。\n\n4.渐进式rehash\n上面讲到rehash过程中，需要将ht[0]上的键值对迁移到ht[1]上，但这个过程并不是一次性操作完成的。如果需要一次性完成，就必须对当前哈希表进行锁表操作，锁表期间会导致服务的不可用，所以rehash操作需要分多次、渐进式的完成。\na.为ht[1]分配空间，字典同时持有ht[0]和ht[1]两个哈希表\nb.将rehashidx值置为0，表示rehash工作开始。\nc.rehash期间，所有对字典执行的读写操作，都会在ht[0]和ht[1]两个表上操作，读操作如果在ht[0]上找到，会把结果rehash到ht[1]上，如果未找到会到ht[1]上去找，保存操作只会存在ht[1]上，当rehash工作完成之后,rehashidx++;\nd.随着字典操作的不断执行，最终ht[0]上所有节点会全部rehash到ht[1]上，这时将rehashidx值置为-1，表示rehash完成。\n","slug":"redis设计与实现/Redis字典的实现","published":1,"updated":"2019-05-17T05:57:58.563Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1j8f2hf000v7h9mma86hvr2","content":"<p>字典就是我们熟悉的map，键值对(key-value pair)的抽象数据结构。Redis数据库就是使用字典来作为底层实现的。<br>先介绍下数据结构：<br>1.哈希表<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typeof struct dictht &#123;</span><br><span class=\"line\">\t//哈希表数组</span><br><span class=\"line\">\tdictEntry   **table;</span><br><span class=\"line\">\t//哈希表大小</span><br><span class=\"line\">\tunsigned long size;</span><br><span class=\"line\">\t//哈希表大小掩码，用于计算索引</span><br><span class=\"line\">\t//总是等于size-1</span><br><span class=\"line\">\tunsigned long sizemask;</span><br><span class=\"line\">\t//已有节点数量</span><br><span class=\"line\">\tunsigned long used;</span><br><span class=\"line\">&#125; dictht;</span><br></pre></td></tr></table></figure></p>\n<p>这种数据结构很好理解，和Java里面HashMap实现差不多。哈希表里面每个节点都是一个entry对象。</p>\n<p>2.哈希表节点<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typeof struct dictEntry &#123;</span><br><span class=\"line\">\t//键</span><br><span class=\"line\">\tvoid *key;</span><br><span class=\"line\">\t//值</span><br><span class=\"line\">\tunion &#123;</span><br><span class=\"line\">\tvoid *val;</span><br><span class=\"line\">\tunit64_t u64;</span><br><span class=\"line\">\tint64_t s64;</span><br><span class=\"line\">&#125; v;</span><br><span class=\"line\"></span><br><span class=\"line\">//指向下个哈希表节点，形成链表</span><br><span class=\"line\">struct dictEntry *next;</span><br><span class=\"line\">&#125; dictEntry;</span><br></pre></td></tr></table></figure></p>\n<p>key属性存着键值对中的键，v属性存值。键可以是一个指针，也可以是一个unit64_t整数，或是一个int^4_t整数。C语言没了解过，这种奇怪的整数也不知道什么意思，姑且理解为Java里面的hashCode吧。<br>next属性指向链表中的下一个节点，这点和Java一样，当多个对象哈希值相同时，就造成hash冲突，多个对象的索引值都落在同一索引下标上，该节点的数据结构为链表，需要遍历该链表才能找到对应元素。</p>\n<p>3.字典数据结构<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typeof struct dict &#123;</span><br><span class=\"line\">\t//类型特定函数</span><br><span class=\"line\">\tdictType *<span class=\"built_in\">type</span>;</span><br><span class=\"line\">\t//私有数据</span><br><span class=\"line\">\tvoid *privdata;</span><br><span class=\"line\">\t//哈希表</span><br><span class=\"line\">\tdictht ht[2];</span><br><span class=\"line\">\t//<span class=\"built_in\">rehash</span>索引</span><br><span class=\"line\">\t//当<span class=\"built_in\">rehash</span>不再进行时，值为-1</span><br><span class=\"line\">\tint rehashidx;</span><br><span class=\"line\">&#125; dict;</span><br></pre></td></tr></table></figure></p>\n<p>type属性和privdata属性针对不同类型的键值对，为创建多态字典设置的。<br>type属性是一个指向dictType结构的指针，每个dictType保存了一簇用于操作特定类型键值对的函数，Redis会为用途不同的字典设置不同的类型特定函数。<br>privdata属性保存了需要传给那些类型特定函数的可选参数。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typeof struct dictType &#123;</span><br><span class=\"line\">\t//计算哈希值的函数</span><br><span class=\"line\">\tunsigned int (*hashFunction) (const void *key);</span><br><span class=\"line\">\t//复制键的函数</span><br><span class=\"line\">\tvoid *(*keyDup) (void *privdata, const void *key);</span><br><span class=\"line\">\t//复制值的函数</span><br><span class=\"line\">\tvoid *(*valDup)(void *privdata, const void *obj);</span><br><span class=\"line\">\t//对比键的函数</span><br><span class=\"line\">\tint (*keyCompare) (void *privdata, const void *key1, const void *key2);</span><br><span class=\"line\">\t//销毁键的函数</span><br><span class=\"line\">\tvoid (*keyDestructor) (void *privdata, void *key);</span><br><span class=\"line\">\t//销毁值的函数</span><br><span class=\"line\">\tvoid (*valDestructor) (void *privdata, void *obj);</span><br><span class=\"line\">&#125; dictType;</span><br></pre></td></tr></table></figure>\n<p>ht属性是一个包含2个索引的数组，每个位置都是一个dictht哈希表，一般使用ht[0]，ht[1]用于存放对ht[0]哈希表进行rehash的结果。<br>rehashidx记录目前rehash进度，当前没有执行rehash，值为-1。</p>\n<p>1.Redis 字典 Hash算法<br>根据key计算hash值<br>hash = dict -&gt; type -&gt; hashFunction(key);<br>根据sizemask属性和哈希值,计算出索引,ht[x]可以是ht[0]或ht[1]<br>index = hash &amp; dict -&gt; ht[x].sizemask;<br>Redis使用MurmurHash2算法计算键的哈希值，优点在于即使输入的键是有规律的，算法仍能给出一个很好的随机分布性。</p>\n<p>2.解决Hash冲突<br>当2个或多个不同对象的Hash值相同时，会被分配到哈希表的同一个索引上，此时就称之为哈希冲突。<br>Redis采用链地址法解决键冲突，每个哈希节点都有一个next指针，由此指针构成一个单向链表，新添加的元素在链表表头。</p>\n<p>3.rehash<br>负载因子 = 哈希表节点数量/哈希表大小<br>load_factor = ht[0].used / ht[0].size<br>当哈希表的操作不断进行，需要把哈希表的负载因子保持在一个合理范围内，需要对哈希表进行扩容或缩容操作，2种操作都通过执行再散列操作来执行(rehash)：<br>a.为字典的ht[1]分配空间，如果是扩容操作，ht[1]的空间为ht[0]的节点数量2倍;如果是缩容,ht[1]的空间为ht[0]节点数量的一半。<br>b.将ht[0]中的所有键值对rehash到ht[1]上面：rehash需要重新计算键的哈希值和索引值，然后放在ht[1]的指定位置上。<br>c.当ht[0]所有键值对都迁移到ht[1]上之后，释放ht[0]，就是将ht[0]表置为空表，再将ht[1]置为ht[0],并将ht[1]新建一个大小为0的空哈希表。</p>\n<p>4.渐进式rehash<br>上面讲到rehash过程中，需要将ht[0]上的键值对迁移到ht[1]上，但这个过程并不是一次性操作完成的。如果需要一次性完成，就必须对当前哈希表进行锁表操作，锁表期间会导致服务的不可用，所以rehash操作需要分多次、渐进式的完成。<br>a.为ht[1]分配空间，字典同时持有ht[0]和ht[1]两个哈希表<br>b.将rehashidx值置为0，表示rehash工作开始。<br>c.rehash期间，所有对字典执行的读写操作，都会在ht[0]和ht[1]两个表上操作，读操作如果在ht[0]上找到，会把结果rehash到ht[1]上，如果未找到会到ht[1]上去找，保存操作只会存在ht[1]上，当rehash工作完成之后,rehashidx++;<br>d.随着字典操作的不断执行，最终ht[0]上所有节点会全部rehash到ht[1]上，这时将rehashidx值置为-1，表示rehash完成。</p>\n","excerpt":"","more":"<p>字典就是我们熟悉的map，键值对(key-value pair)的抽象数据结构。Redis数据库就是使用字典来作为底层实现的。<br>先介绍下数据结构：<br>1.哈希表<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typeof struct dictht &#123;</span><br><span class=\"line\">\t//哈希表数组</span><br><span class=\"line\">\tdictEntry   **table;</span><br><span class=\"line\">\t//哈希表大小</span><br><span class=\"line\">\tunsigned long size;</span><br><span class=\"line\">\t//哈希表大小掩码，用于计算索引</span><br><span class=\"line\">\t//总是等于size-1</span><br><span class=\"line\">\tunsigned long sizemask;</span><br><span class=\"line\">\t//已有节点数量</span><br><span class=\"line\">\tunsigned long used;</span><br><span class=\"line\">&#125; dictht;</span><br></pre></td></tr></table></figure></p>\n<p>这种数据结构很好理解，和Java里面HashMap实现差不多。哈希表里面每个节点都是一个entry对象。</p>\n<p>2.哈希表节点<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typeof struct dictEntry &#123;</span><br><span class=\"line\">\t//键</span><br><span class=\"line\">\tvoid *key;</span><br><span class=\"line\">\t//值</span><br><span class=\"line\">\tunion &#123;</span><br><span class=\"line\">\tvoid *val;</span><br><span class=\"line\">\tunit64_t u64;</span><br><span class=\"line\">\tint64_t s64;</span><br><span class=\"line\">&#125; v;</span><br><span class=\"line\"></span><br><span class=\"line\">//指向下个哈希表节点，形成链表</span><br><span class=\"line\">struct dictEntry *next;</span><br><span class=\"line\">&#125; dictEntry;</span><br></pre></td></tr></table></figure></p>\n<p>key属性存着键值对中的键，v属性存值。键可以是一个指针，也可以是一个unit64_t整数，或是一个int^4_t整数。C语言没了解过，这种奇怪的整数也不知道什么意思，姑且理解为Java里面的hashCode吧。<br>next属性指向链表中的下一个节点，这点和Java一样，当多个对象哈希值相同时，就造成hash冲突，多个对象的索引值都落在同一索引下标上，该节点的数据结构为链表，需要遍历该链表才能找到对应元素。</p>\n<p>3.字典数据结构<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typeof struct dict &#123;</span><br><span class=\"line\">\t//类型特定函数</span><br><span class=\"line\">\tdictType *<span class=\"built_in\">type</span>;</span><br><span class=\"line\">\t//私有数据</span><br><span class=\"line\">\tvoid *privdata;</span><br><span class=\"line\">\t//哈希表</span><br><span class=\"line\">\tdictht ht[2];</span><br><span class=\"line\">\t//<span class=\"built_in\">rehash</span>索引</span><br><span class=\"line\">\t//当<span class=\"built_in\">rehash</span>不再进行时，值为-1</span><br><span class=\"line\">\tint rehashidx;</span><br><span class=\"line\">&#125; dict;</span><br></pre></td></tr></table></figure></p>\n<p>type属性和privdata属性针对不同类型的键值对，为创建多态字典设置的。<br>type属性是一个指向dictType结构的指针，每个dictType保存了一簇用于操作特定类型键值对的函数，Redis会为用途不同的字典设置不同的类型特定函数。<br>privdata属性保存了需要传给那些类型特定函数的可选参数。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typeof struct dictType &#123;</span><br><span class=\"line\">\t//计算哈希值的函数</span><br><span class=\"line\">\tunsigned int (*hashFunction) (const void *key);</span><br><span class=\"line\">\t//复制键的函数</span><br><span class=\"line\">\tvoid *(*keyDup) (void *privdata, const void *key);</span><br><span class=\"line\">\t//复制值的函数</span><br><span class=\"line\">\tvoid *(*valDup)(void *privdata, const void *obj);</span><br><span class=\"line\">\t//对比键的函数</span><br><span class=\"line\">\tint (*keyCompare) (void *privdata, const void *key1, const void *key2);</span><br><span class=\"line\">\t//销毁键的函数</span><br><span class=\"line\">\tvoid (*keyDestructor) (void *privdata, void *key);</span><br><span class=\"line\">\t//销毁值的函数</span><br><span class=\"line\">\tvoid (*valDestructor) (void *privdata, void *obj);</span><br><span class=\"line\">&#125; dictType;</span><br></pre></td></tr></table></figure>\n<p>ht属性是一个包含2个索引的数组，每个位置都是一个dictht哈希表，一般使用ht[0]，ht[1]用于存放对ht[0]哈希表进行rehash的结果。<br>rehashidx记录目前rehash进度，当前没有执行rehash，值为-1。</p>\n<p>1.Redis 字典 Hash算法<br>根据key计算hash值<br>hash = dict -&gt; type -&gt; hashFunction(key);<br>根据sizemask属性和哈希值,计算出索引,ht[x]可以是ht[0]或ht[1]<br>index = hash &amp; dict -&gt; ht[x].sizemask;<br>Redis使用MurmurHash2算法计算键的哈希值，优点在于即使输入的键是有规律的，算法仍能给出一个很好的随机分布性。</p>\n<p>2.解决Hash冲突<br>当2个或多个不同对象的Hash值相同时，会被分配到哈希表的同一个索引上，此时就称之为哈希冲突。<br>Redis采用链地址法解决键冲突，每个哈希节点都有一个next指针，由此指针构成一个单向链表，新添加的元素在链表表头。</p>\n<p>3.rehash<br>负载因子 = 哈希表节点数量/哈希表大小<br>load_factor = ht[0].used / ht[0].size<br>当哈希表的操作不断进行，需要把哈希表的负载因子保持在一个合理范围内，需要对哈希表进行扩容或缩容操作，2种操作都通过执行再散列操作来执行(rehash)：<br>a.为字典的ht[1]分配空间，如果是扩容操作，ht[1]的空间为ht[0]的节点数量2倍;如果是缩容,ht[1]的空间为ht[0]节点数量的一半。<br>b.将ht[0]中的所有键值对rehash到ht[1]上面：rehash需要重新计算键的哈希值和索引值，然后放在ht[1]的指定位置上。<br>c.当ht[0]所有键值对都迁移到ht[1]上之后，释放ht[0]，就是将ht[0]表置为空表，再将ht[1]置为ht[0],并将ht[1]新建一个大小为0的空哈希表。</p>\n<p>4.渐进式rehash<br>上面讲到rehash过程中，需要将ht[0]上的键值对迁移到ht[1]上，但这个过程并不是一次性操作完成的。如果需要一次性完成，就必须对当前哈希表进行锁表操作，锁表期间会导致服务的不可用，所以rehash操作需要分多次、渐进式的完成。<br>a.为ht[1]分配空间，字典同时持有ht[0]和ht[1]两个哈希表<br>b.将rehashidx值置为0，表示rehash工作开始。<br>c.rehash期间，所有对字典执行的读写操作，都会在ht[0]和ht[1]两个表上操作，读操作如果在ht[0]上找到，会把结果rehash到ht[1]上，如果未找到会到ht[1]上去找，保存操作只会存在ht[1]上，当rehash工作完成之后,rehashidx++;<br>d.随着字典操作的不断执行，最终ht[0]上所有节点会全部rehash到ht[1]上，这时将rehashidx值置为-1，表示rehash完成。</p>\n"},{"title":"Redis客户端","date":"2015-07-21T16:00:00.000Z","_content":"\n通过使用由I/O多路复用技术实现的文件事件处理器，Redis服务器使用单线程单进程的方式来处理命令请求，并与多个客户端进行网络通信。\nredisClient结构保存客户端的数据结构：  \n*\t套接字描述符  \n*\t名字  \n* \t标志位  \n* \t正在使用的数据库指针，数据库号码\t\n* \t当前要执行的命令、参数、参数个数，以及指向命令实现函数的指针  \n* \t输入缓冲和输出缓冲  \n* \t复制状态信息和复制所需数据结构  \n* \t执行BRPOP、BLPOP等列表阻塞命令时使用的数据结构  \n* \t事物状态，执行WATCH命令用到的数据结构  \n* \t执行发布和订阅用到的数据结构  \n* \t身份验证标志  \n* \t创建时间、最后一次通信时间，输出缓冲区大小超出软性限制的事件  \n","source":"_posts/redis设计与实现/Redis客户端.md","raw":"---\ntitle: Redis客户端\ndate: 2015-07-22\ncategories: Redis设计与实现\ntags: Redis\n---\n\n通过使用由I/O多路复用技术实现的文件事件处理器，Redis服务器使用单线程单进程的方式来处理命令请求，并与多个客户端进行网络通信。\nredisClient结构保存客户端的数据结构：  \n*\t套接字描述符  \n*\t名字  \n* \t标志位  \n* \t正在使用的数据库指针，数据库号码\t\n* \t当前要执行的命令、参数、参数个数，以及指向命令实现函数的指针  \n* \t输入缓冲和输出缓冲  \n* \t复制状态信息和复制所需数据结构  \n* \t执行BRPOP、BLPOP等列表阻塞命令时使用的数据结构  \n* \t事物状态，执行WATCH命令用到的数据结构  \n* \t执行发布和订阅用到的数据结构  \n* \t身份验证标志  \n* \t创建时间、最后一次通信时间，输出缓冲区大小超出软性限制的事件  \n","slug":"redis设计与实现/Redis客户端","published":1,"updated":"2019-05-17T05:57:58.565Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1j8f2hh000w7h9m2yqq4sxr","content":"<p>通过使用由I/O多路复用技术实现的文件事件处理器，Redis服务器使用单线程单进程的方式来处理命令请求，并与多个客户端进行网络通信。<br>redisClient结构保存客户端的数据结构：  </p>\n<ul>\n<li>套接字描述符  </li>\n<li>名字  </li>\n<li>标志位  </li>\n<li>正在使用的数据库指针，数据库号码    </li>\n<li>当前要执行的命令、参数、参数个数，以及指向命令实现函数的指针  </li>\n<li>输入缓冲和输出缓冲  </li>\n<li>复制状态信息和复制所需数据结构  </li>\n<li>执行BRPOP、BLPOP等列表阻塞命令时使用的数据结构  </li>\n<li>事物状态，执行WATCH命令用到的数据结构  </li>\n<li>执行发布和订阅用到的数据结构  </li>\n<li>身份验证标志  </li>\n<li>创建时间、最后一次通信时间，输出缓冲区大小超出软性限制的事件  </li>\n</ul>\n","excerpt":"","more":"<p>通过使用由I/O多路复用技术实现的文件事件处理器，Redis服务器使用单线程单进程的方式来处理命令请求，并与多个客户端进行网络通信。<br>redisClient结构保存客户端的数据结构：  </p>\n<ul>\n<li>套接字描述符  </li>\n<li>名字  </li>\n<li>标志位  </li>\n<li>正在使用的数据库指针，数据库号码    </li>\n<li>当前要执行的命令、参数、参数个数，以及指向命令实现函数的指针  </li>\n<li>输入缓冲和输出缓冲  </li>\n<li>复制状态信息和复制所需数据结构  </li>\n<li>执行BRPOP、BLPOP等列表阻塞命令时使用的数据结构  </li>\n<li>事物状态，执行WATCH命令用到的数据结构  </li>\n<li>执行发布和订阅用到的数据结构  </li>\n<li>身份验证标志  </li>\n<li>创建时间、最后一次通信时间，输出缓冲区大小超出软性限制的事件  </li>\n</ul>\n"},{"title":"Redis持久化-RDB","date":"2015-06-30T16:00:00.000Z","_content":"\nRDB持久化可以自动，也可以手动，这个功能将某个时间点上的数据库状态保存到一个经过压缩的二进制文件中。\n\nSAVE命令会阻塞服务，执行完成前客户端的所有请求都会拒绝。\nBGSAVE命令会新建一个子进程执行持久化操作，不阻塞服务。\n\n服务器状态维护了一个dirty计数器以及一个lastsave属性，供RDB持久化策略使用。\ndirty计数器记录距离上一次成功执行SAVE或BGSAVE操作后，服务器中所有数据库进行了多少次修改操作（增删改）；\nlastsave属性是一个unix时间戳，记录上一次RDB持久化的时间。\n","source":"_posts/redis设计与实现/Redis持久化-RDB.md","raw":"---\ntitle: Redis持久化-RDB\ndate: 2015-07-01\ncategories: Redis设计与实现\ntags: Redis\n---\n\nRDB持久化可以自动，也可以手动，这个功能将某个时间点上的数据库状态保存到一个经过压缩的二进制文件中。\n\nSAVE命令会阻塞服务，执行完成前客户端的所有请求都会拒绝。\nBGSAVE命令会新建一个子进程执行持久化操作，不阻塞服务。\n\n服务器状态维护了一个dirty计数器以及一个lastsave属性，供RDB持久化策略使用。\ndirty计数器记录距离上一次成功执行SAVE或BGSAVE操作后，服务器中所有数据库进行了多少次修改操作（增删改）；\nlastsave属性是一个unix时间戳，记录上一次RDB持久化的时间。\n","slug":"redis设计与实现/Redis持久化-RDB","published":1,"updated":"2019-05-17T05:57:58.571Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1j8f2ho000x7h9mmyd7ovna","content":"<p>RDB持久化可以自动，也可以手动，这个功能将某个时间点上的数据库状态保存到一个经过压缩的二进制文件中。</p>\n<p>SAVE命令会阻塞服务，执行完成前客户端的所有请求都会拒绝。<br>BGSAVE命令会新建一个子进程执行持久化操作，不阻塞服务。</p>\n<p>服务器状态维护了一个dirty计数器以及一个lastsave属性，供RDB持久化策略使用。<br>dirty计数器记录距离上一次成功执行SAVE或BGSAVE操作后，服务器中所有数据库进行了多少次修改操作（增删改）；<br>lastsave属性是一个unix时间戳，记录上一次RDB持久化的时间。</p>\n","excerpt":"","more":"<p>RDB持久化可以自动，也可以手动，这个功能将某个时间点上的数据库状态保存到一个经过压缩的二进制文件中。</p>\n<p>SAVE命令会阻塞服务，执行完成前客户端的所有请求都会拒绝。<br>BGSAVE命令会新建一个子进程执行持久化操作，不阻塞服务。</p>\n<p>服务器状态维护了一个dirty计数器以及一个lastsave属性，供RDB持久化策略使用。<br>dirty计数器记录距离上一次成功执行SAVE或BGSAVE操作后，服务器中所有数据库进行了多少次修改操作（增删改）；<br>lastsave属性是一个unix时间戳，记录上一次RDB持久化的时间。</p>\n"},{"title":"Redis对象","date":"2015-06-27T16:00:00.000Z","_content":"\nRedis中每个对象都由一个redisObject结构表示：\n\n``` bash\ntypeof struct redisObject {\n\t//类型\n\tunsigned type : 4;\n\t//编码\n\tunsigned encoding : 4;\n\t//指向底层数据结构的指针\n\tvoid *ptr;\n\t// . . .\n} robj;\n```\ntype  对象的类型\nREDIS_STRING 字符串对象\nREDIS_LIST 列表对象\nREDIS_HASH 哈希对象\nREDIS_SET 集合对象\nREDIS_ZSET 有序集合对象\n\n对于Redis保存的键值对来说，键总是一个字符串对象，而值可以是上述对象中的任意对象。使用TYPE命令返回的结果是数据库对应键的值对象类型。\n\nencoding 记录对象底层数据结构的实现。使用OBJECT ENCODING 可查看一个数据库键的值对象编码。\n\nRedis对象的内存回收采用的是类似JVM垃圾回收的方法之一  引用计数法。\n","source":"_posts/redis设计与实现/Redis对象.md","raw":"---\ntitle: Redis对象\ndate: 2015-06-28\ncategories: Redis设计与实现\ntags: Redis\n---\n\nRedis中每个对象都由一个redisObject结构表示：\n\n``` bash\ntypeof struct redisObject {\n\t//类型\n\tunsigned type : 4;\n\t//编码\n\tunsigned encoding : 4;\n\t//指向底层数据结构的指针\n\tvoid *ptr;\n\t// . . .\n} robj;\n```\ntype  对象的类型\nREDIS_STRING 字符串对象\nREDIS_LIST 列表对象\nREDIS_HASH 哈希对象\nREDIS_SET 集合对象\nREDIS_ZSET 有序集合对象\n\n对于Redis保存的键值对来说，键总是一个字符串对象，而值可以是上述对象中的任意对象。使用TYPE命令返回的结果是数据库对应键的值对象类型。\n\nencoding 记录对象底层数据结构的实现。使用OBJECT ENCODING 可查看一个数据库键的值对象编码。\n\nRedis对象的内存回收采用的是类似JVM垃圾回收的方法之一  引用计数法。\n","slug":"redis设计与实现/Redis对象","published":1,"updated":"2019-05-17T05:57:58.567Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1j8f2hq000y7h9mxo9qzqwf","content":"<p>Redis中每个对象都由一个redisObject结构表示：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typeof struct redisObject &#123;</span><br><span class=\"line\">\t//类型</span><br><span class=\"line\">\tunsigned <span class=\"built_in\">type</span> : 4;</span><br><span class=\"line\">\t//编码</span><br><span class=\"line\">\tunsigned encoding : 4;</span><br><span class=\"line\">\t//指向底层数据结构的指针</span><br><span class=\"line\">\tvoid *ptr;</span><br><span class=\"line\">\t// . . .</span><br><span class=\"line\">&#125; robj;</span><br></pre></td></tr></table></figure>\n<p>type  对象的类型<br>REDIS_STRING 字符串对象<br>REDIS_LIST 列表对象<br>REDIS_HASH 哈希对象<br>REDIS_SET 集合对象<br>REDIS_ZSET 有序集合对象</p>\n<p>对于Redis保存的键值对来说，键总是一个字符串对象，而值可以是上述对象中的任意对象。使用TYPE命令返回的结果是数据库对应键的值对象类型。</p>\n<p>encoding 记录对象底层数据结构的实现。使用OBJECT ENCODING 可查看一个数据库键的值对象编码。</p>\n<p>Redis对象的内存回收采用的是类似JVM垃圾回收的方法之一  引用计数法。</p>\n","excerpt":"","more":"<p>Redis中每个对象都由一个redisObject结构表示：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typeof struct redisObject &#123;</span><br><span class=\"line\">\t//类型</span><br><span class=\"line\">\tunsigned <span class=\"built_in\">type</span> : 4;</span><br><span class=\"line\">\t//编码</span><br><span class=\"line\">\tunsigned encoding : 4;</span><br><span class=\"line\">\t//指向底层数据结构的指针</span><br><span class=\"line\">\tvoid *ptr;</span><br><span class=\"line\">\t// . . .</span><br><span class=\"line\">&#125; robj;</span><br></pre></td></tr></table></figure>\n<p>type  对象的类型<br>REDIS_STRING 字符串对象<br>REDIS_LIST 列表对象<br>REDIS_HASH 哈希对象<br>REDIS_SET 集合对象<br>REDIS_ZSET 有序集合对象</p>\n<p>对于Redis保存的键值对来说，键总是一个字符串对象，而值可以是上述对象中的任意对象。使用TYPE命令返回的结果是数据库对应键的值对象类型。</p>\n<p>encoding 记录对象底层数据结构的实现。使用OBJECT ENCODING 可查看一个数据库键的值对象编码。</p>\n<p>Redis对象的内存回收采用的是类似JVM垃圾回收的方法之一  引用计数法。</p>\n"},{"title":"Redis持久化-AOF","date":"2015-07-10T16:00:00.000Z","_content":"\nRedis提供了AOF(Append Only File)持久化功能，AOF通过保存服务器所执行命令来记录数据库状态的，和MySQL记录增删改的log有点像哈。\n\nAOF持久化功能实现分为命令追加(append)、文件写入(write)和文件同步(sync)三个步骤。\n\n1.AOF命令追加  \n当开启AOF持久化功能时，服务器会在执行完一个写命令后，会以协议格式将执行的写命令追加到服务器状态的aof_buf缓冲区末尾。\n\n2.AOF文件写入和同步  \nRedis服务进程就是一个事件循环，循环中的文件事件负责接受客户端的命令请求，以及向客户端发送命令回复，而时间事件则负责执行像serverCron函数这样需要定时运行的函数。\n``` bash\ndef eventLoop():\nwhile True:\n\t//处理文件事件，接收命令以及发送命令\n\t//处理命令时可能会有新内容被追加到aof_buf中\n\tprocessFileEvents()\n\t//处理时间事件\n\tprocessTimeEvents()\n\t//考虑是否将aof_buf中内容写入和保存到aof文件\n\tflushAppendOnlyFile()\n```\n\nflushAppendOnlyFile函数的行为由服务器配置的appendfsync选项值来决定。  \nappendfsync配置：  \nalways : 服务器在每个事件循环都要将aof_buf缓冲区的所有内容写到AOF文件，并同步，效率最慢，但最安全。  \neverysec : 服务器在每个事件循环都将aof_bug缓冲区的所有文件写到AOF文件，并且每隔1s就在子线程中对AOF文件做同步，效率快。  \nno : 服务器在每个事件循环都将aof_bug缓冲区的所有文件写到AOF文件，此模式下的flushAppendOnlyFile无须执行同步操作，同步AOF文件由操作系统决定，写入速度最快。\n\n3.AOF重写  \n随着服务器运行时间的流逝，AOF文件中的内容会越来越多，可能会对Redis服务器和宿主计算机造成影响。  \n虽然Redis将生成新AOF文件替换旧AOF文件功能命名为AOF文件重写，但实际上，AOF文件重写并不需要对现有AOF文件进行任何读取、分析和写入操作，这个功能是通过读取服务器当前数据库状态来实现的。\n实际操作中，Redis依次遍历数据库中所有key，并根据key类型的不同，取出相应值并生成对应类型的写入语句。同时，为了避免在执行命令时造成客户端输入缓冲区溢出，重写程序在处理列表、哈希表、集合、有序集合这4种可能会带有多个元素的键时，会先检查键所包含元素的数量，如果数量超过了redis.h/REDIS_AOF_REWRITE_ITEMS_PER_CMD常量的值，那重写程序会使用多条命令来记录键的值。当前版本中，REDIS_AOF_REWRITE_ITEMS_PER_CMD常量值为64，所以每条语句最多会写入64个元素。\n\n4.AOF后台重写  \n上面介绍的AOF重写可以很好的完成创建一个新AOF文件的任务，但是，这个操作会进行大量的写入操作，所以调用这个函数的线程将被长时间阻塞，因为Redis服务器使用单个线程来处理命令请求，所以如果由服务器调用AOF重写，那么在重写期间，服务器将无法处理客户端发来的请求。\nRedis并不希望AOF的重写操作造成服务器无法处理请求，所以需要将重写放到子进程里执行，这样做可以达到两个目的：  \n1)子进程执行AOF重写期间，服务器可以继续处理客户端的命令请求。  \n2)子进程带有服务器进程的数据副本，使用子进程而不是线程，可以在避免使用锁的情况下，保证数据安全性。\n\n不过这里仍然存在一个问题：在子进程执行AOF重写期间，服务器处理客户端的命令请求时，对现有数据库状态进行修改操作，会使得服务器当前数据库状态和重写后的AOF文件所保存的数据库状态不一致。\n为了解决这个问题，Redis服务器设置了一个AOF重写缓冲区，这个缓冲区在服务器创建子进程之后开始使用，当Redis执行完一个写命令后，它会同时将这个写命令发送给AOF缓冲区和AOF重写缓冲区。\n以上就是AOF后台重写，即BGREWRITEAOF命令的实现原理。\n","source":"_posts/redis设计与实现/Redis持久化-AOF.md","raw":"---\ntitle: Redis持久化-AOF\ndate: 2015-07-11\ncategories: Redis设计与实现\ntags: Redis\n---\n\nRedis提供了AOF(Append Only File)持久化功能，AOF通过保存服务器所执行命令来记录数据库状态的，和MySQL记录增删改的log有点像哈。\n\nAOF持久化功能实现分为命令追加(append)、文件写入(write)和文件同步(sync)三个步骤。\n\n1.AOF命令追加  \n当开启AOF持久化功能时，服务器会在执行完一个写命令后，会以协议格式将执行的写命令追加到服务器状态的aof_buf缓冲区末尾。\n\n2.AOF文件写入和同步  \nRedis服务进程就是一个事件循环，循环中的文件事件负责接受客户端的命令请求，以及向客户端发送命令回复，而时间事件则负责执行像serverCron函数这样需要定时运行的函数。\n``` bash\ndef eventLoop():\nwhile True:\n\t//处理文件事件，接收命令以及发送命令\n\t//处理命令时可能会有新内容被追加到aof_buf中\n\tprocessFileEvents()\n\t//处理时间事件\n\tprocessTimeEvents()\n\t//考虑是否将aof_buf中内容写入和保存到aof文件\n\tflushAppendOnlyFile()\n```\n\nflushAppendOnlyFile函数的行为由服务器配置的appendfsync选项值来决定。  \nappendfsync配置：  \nalways : 服务器在每个事件循环都要将aof_buf缓冲区的所有内容写到AOF文件，并同步，效率最慢，但最安全。  \neverysec : 服务器在每个事件循环都将aof_bug缓冲区的所有文件写到AOF文件，并且每隔1s就在子线程中对AOF文件做同步，效率快。  \nno : 服务器在每个事件循环都将aof_bug缓冲区的所有文件写到AOF文件，此模式下的flushAppendOnlyFile无须执行同步操作，同步AOF文件由操作系统决定，写入速度最快。\n\n3.AOF重写  \n随着服务器运行时间的流逝，AOF文件中的内容会越来越多，可能会对Redis服务器和宿主计算机造成影响。  \n虽然Redis将生成新AOF文件替换旧AOF文件功能命名为AOF文件重写，但实际上，AOF文件重写并不需要对现有AOF文件进行任何读取、分析和写入操作，这个功能是通过读取服务器当前数据库状态来实现的。\n实际操作中，Redis依次遍历数据库中所有key，并根据key类型的不同，取出相应值并生成对应类型的写入语句。同时，为了避免在执行命令时造成客户端输入缓冲区溢出，重写程序在处理列表、哈希表、集合、有序集合这4种可能会带有多个元素的键时，会先检查键所包含元素的数量，如果数量超过了redis.h/REDIS_AOF_REWRITE_ITEMS_PER_CMD常量的值，那重写程序会使用多条命令来记录键的值。当前版本中，REDIS_AOF_REWRITE_ITEMS_PER_CMD常量值为64，所以每条语句最多会写入64个元素。\n\n4.AOF后台重写  \n上面介绍的AOF重写可以很好的完成创建一个新AOF文件的任务，但是，这个操作会进行大量的写入操作，所以调用这个函数的线程将被长时间阻塞，因为Redis服务器使用单个线程来处理命令请求，所以如果由服务器调用AOF重写，那么在重写期间，服务器将无法处理客户端发来的请求。\nRedis并不希望AOF的重写操作造成服务器无法处理请求，所以需要将重写放到子进程里执行，这样做可以达到两个目的：  \n1)子进程执行AOF重写期间，服务器可以继续处理客户端的命令请求。  \n2)子进程带有服务器进程的数据副本，使用子进程而不是线程，可以在避免使用锁的情况下，保证数据安全性。\n\n不过这里仍然存在一个问题：在子进程执行AOF重写期间，服务器处理客户端的命令请求时，对现有数据库状态进行修改操作，会使得服务器当前数据库状态和重写后的AOF文件所保存的数据库状态不一致。\n为了解决这个问题，Redis服务器设置了一个AOF重写缓冲区，这个缓冲区在服务器创建子进程之后开始使用，当Redis执行完一个写命令后，它会同时将这个写命令发送给AOF缓冲区和AOF重写缓冲区。\n以上就是AOF后台重写，即BGREWRITEAOF命令的实现原理。\n","slug":"redis设计与实现/Redis持久化-AOF","published":1,"updated":"2019-05-17T05:57:58.568Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1j8f2hr000z7h9msnbr6qi3","content":"<p>Redis提供了AOF(Append Only File)持久化功能，AOF通过保存服务器所执行命令来记录数据库状态的，和MySQL记录增删改的log有点像哈。</p>\n<p>AOF持久化功能实现分为命令追加(append)、文件写入(write)和文件同步(sync)三个步骤。</p>\n<p>1.AOF命令追加<br>当开启AOF持久化功能时，服务器会在执行完一个写命令后，会以协议格式将执行的写命令追加到服务器状态的aof_buf缓冲区末尾。</p>\n<p>2.AOF文件写入和同步<br>Redis服务进程就是一个事件循环，循环中的文件事件负责接受客户端的命令请求，以及向客户端发送命令回复，而时间事件则负责执行像serverCron函数这样需要定时运行的函数。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def eventLoop():</span><br><span class=\"line\"><span class=\"keyword\">while</span> True:</span><br><span class=\"line\">\t//处理文件事件，接收命令以及发送命令</span><br><span class=\"line\">\t//处理命令时可能会有新内容被追加到aof_buf中</span><br><span class=\"line\">\tprocessFileEvents()</span><br><span class=\"line\">\t//处理时间事件</span><br><span class=\"line\">\tprocessTimeEvents()</span><br><span class=\"line\">\t//考虑是否将aof_buf中内容写入和保存到aof文件</span><br><span class=\"line\">\tflushAppendOnlyFile()</span><br></pre></td></tr></table></figure></p>\n<p>flushAppendOnlyFile函数的行为由服务器配置的appendfsync选项值来决定。<br>appendfsync配置：<br>always : 服务器在每个事件循环都要将aof_buf缓冲区的所有内容写到AOF文件，并同步，效率最慢，但最安全。<br>everysec : 服务器在每个事件循环都将aof_bug缓冲区的所有文件写到AOF文件，并且每隔1s就在子线程中对AOF文件做同步，效率快。<br>no : 服务器在每个事件循环都将aof_bug缓冲区的所有文件写到AOF文件，此模式下的flushAppendOnlyFile无须执行同步操作，同步AOF文件由操作系统决定，写入速度最快。</p>\n<p>3.AOF重写<br>随着服务器运行时间的流逝，AOF文件中的内容会越来越多，可能会对Redis服务器和宿主计算机造成影响。<br>虽然Redis将生成新AOF文件替换旧AOF文件功能命名为AOF文件重写，但实际上，AOF文件重写并不需要对现有AOF文件进行任何读取、分析和写入操作，这个功能是通过读取服务器当前数据库状态来实现的。<br>实际操作中，Redis依次遍历数据库中所有key，并根据key类型的不同，取出相应值并生成对应类型的写入语句。同时，为了避免在执行命令时造成客户端输入缓冲区溢出，重写程序在处理列表、哈希表、集合、有序集合这4种可能会带有多个元素的键时，会先检查键所包含元素的数量，如果数量超过了redis.h/REDIS_AOF_REWRITE_ITEMS_PER_CMD常量的值，那重写程序会使用多条命令来记录键的值。当前版本中，REDIS_AOF_REWRITE_ITEMS_PER_CMD常量值为64，所以每条语句最多会写入64个元素。</p>\n<p>4.AOF后台重写<br>上面介绍的AOF重写可以很好的完成创建一个新AOF文件的任务，但是，这个操作会进行大量的写入操作，所以调用这个函数的线程将被长时间阻塞，因为Redis服务器使用单个线程来处理命令请求，所以如果由服务器调用AOF重写，那么在重写期间，服务器将无法处理客户端发来的请求。<br>Redis并不希望AOF的重写操作造成服务器无法处理请求，所以需要将重写放到子进程里执行，这样做可以达到两个目的：<br>1)子进程执行AOF重写期间，服务器可以继续处理客户端的命令请求。<br>2)子进程带有服务器进程的数据副本，使用子进程而不是线程，可以在避免使用锁的情况下，保证数据安全性。</p>\n<p>不过这里仍然存在一个问题：在子进程执行AOF重写期间，服务器处理客户端的命令请求时，对现有数据库状态进行修改操作，会使得服务器当前数据库状态和重写后的AOF文件所保存的数据库状态不一致。<br>为了解决这个问题，Redis服务器设置了一个AOF重写缓冲区，这个缓冲区在服务器创建子进程之后开始使用，当Redis执行完一个写命令后，它会同时将这个写命令发送给AOF缓冲区和AOF重写缓冲区。<br>以上就是AOF后台重写，即BGREWRITEAOF命令的实现原理。</p>\n","excerpt":"","more":"<p>Redis提供了AOF(Append Only File)持久化功能，AOF通过保存服务器所执行命令来记录数据库状态的，和MySQL记录增删改的log有点像哈。</p>\n<p>AOF持久化功能实现分为命令追加(append)、文件写入(write)和文件同步(sync)三个步骤。</p>\n<p>1.AOF命令追加<br>当开启AOF持久化功能时，服务器会在执行完一个写命令后，会以协议格式将执行的写命令追加到服务器状态的aof_buf缓冲区末尾。</p>\n<p>2.AOF文件写入和同步<br>Redis服务进程就是一个事件循环，循环中的文件事件负责接受客户端的命令请求，以及向客户端发送命令回复，而时间事件则负责执行像serverCron函数这样需要定时运行的函数。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def eventLoop():</span><br><span class=\"line\"><span class=\"keyword\">while</span> True:</span><br><span class=\"line\">\t//处理文件事件，接收命令以及发送命令</span><br><span class=\"line\">\t//处理命令时可能会有新内容被追加到aof_buf中</span><br><span class=\"line\">\tprocessFileEvents()</span><br><span class=\"line\">\t//处理时间事件</span><br><span class=\"line\">\tprocessTimeEvents()</span><br><span class=\"line\">\t//考虑是否将aof_buf中内容写入和保存到aof文件</span><br><span class=\"line\">\tflushAppendOnlyFile()</span><br></pre></td></tr></table></figure></p>\n<p>flushAppendOnlyFile函数的行为由服务器配置的appendfsync选项值来决定。<br>appendfsync配置：<br>always : 服务器在每个事件循环都要将aof_buf缓冲区的所有内容写到AOF文件，并同步，效率最慢，但最安全。<br>everysec : 服务器在每个事件循环都将aof_bug缓冲区的所有文件写到AOF文件，并且每隔1s就在子线程中对AOF文件做同步，效率快。<br>no : 服务器在每个事件循环都将aof_bug缓冲区的所有文件写到AOF文件，此模式下的flushAppendOnlyFile无须执行同步操作，同步AOF文件由操作系统决定，写入速度最快。</p>\n<p>3.AOF重写<br>随着服务器运行时间的流逝，AOF文件中的内容会越来越多，可能会对Redis服务器和宿主计算机造成影响。<br>虽然Redis将生成新AOF文件替换旧AOF文件功能命名为AOF文件重写，但实际上，AOF文件重写并不需要对现有AOF文件进行任何读取、分析和写入操作，这个功能是通过读取服务器当前数据库状态来实现的。<br>实际操作中，Redis依次遍历数据库中所有key，并根据key类型的不同，取出相应值并生成对应类型的写入语句。同时，为了避免在执行命令时造成客户端输入缓冲区溢出，重写程序在处理列表、哈希表、集合、有序集合这4种可能会带有多个元素的键时，会先检查键所包含元素的数量，如果数量超过了redis.h/REDIS_AOF_REWRITE_ITEMS_PER_CMD常量的值，那重写程序会使用多条命令来记录键的值。当前版本中，REDIS_AOF_REWRITE_ITEMS_PER_CMD常量值为64，所以每条语句最多会写入64个元素。</p>\n<p>4.AOF后台重写<br>上面介绍的AOF重写可以很好的完成创建一个新AOF文件的任务，但是，这个操作会进行大量的写入操作，所以调用这个函数的线程将被长时间阻塞，因为Redis服务器使用单个线程来处理命令请求，所以如果由服务器调用AOF重写，那么在重写期间，服务器将无法处理客户端发来的请求。<br>Redis并不希望AOF的重写操作造成服务器无法处理请求，所以需要将重写放到子进程里执行，这样做可以达到两个目的：<br>1)子进程执行AOF重写期间，服务器可以继续处理客户端的命令请求。<br>2)子进程带有服务器进程的数据副本，使用子进程而不是线程，可以在避免使用锁的情况下，保证数据安全性。</p>\n<p>不过这里仍然存在一个问题：在子进程执行AOF重写期间，服务器处理客户端的命令请求时，对现有数据库状态进行修改操作，会使得服务器当前数据库状态和重写后的AOF文件所保存的数据库状态不一致。<br>为了解决这个问题，Redis服务器设置了一个AOF重写缓冲区，这个缓冲区在服务器创建子进程之后开始使用，当Redis执行完一个写命令后，它会同时将这个写命令发送给AOF缓冲区和AOF重写缓冲区。<br>以上就是AOF后台重写，即BGREWRITEAOF命令的实现原理。</p>\n"},{"title":"Redis文件事件","date":"2015-07-10T16:00:00.000Z","_content":"\nRedis 服务器是一个事件驱动程序，服务器需要处理以下两类事件：  \n1）文件事件  \nRedis服务器通过套接字与客户端（或其他Redis服务器）进行连接，而文件事件就是服务器对套接字操作的抽象。服务器与客户端（或其他服务器）的通信会产生相应的文件事件，而服务器则通过监听并处理这些时间来完成一系列网络通信操作。  \n2）时间事件  \nRedis服务器中的一些操作（比如serverCron函数）需要在给定的时间点执行，而时间事件就是服务器对这类定时操作的抽象。  \n1.文件事件  \nRedis基于Reactor模式开发了自己的网络事件处理器：这个处理器被称为文件事件处理器：  \na,文件事件处理器使用I/O多路复用程序来同时监听多个套接字，并根据套接字目前执行的任务来为套接字关联不同的事件处理器。  \nb.当被监听的套接字准备好执行连接应答、读取、写入、关闭等操作时，与操作相对应的文件事件就会产生，调用套接字之前关联好的事件处理器来处理这些事件。  \n虽然文件事件处理器以单线程方式运行，但通过I/O多路复用程序来监听多个套接字，文件事件处理器既实现了高性能的网络通信模型，又可以很好地与Redis服务器中其他同样以单线程方式运行的模块进行对接。  \n\n2.文件事件处理器  \n4部分：套接字、 I/O多路复用程序 、 文件事件分派器 和 事件处理器。  \n文件事件是对套接字操作的抽象，每当一个套接字准备好执行连接应答、写入、读取、关闭等操作时，就会产生一个文件事件。服务器通常会连接多个套接字，所以多个文件事件可能并发出现。  \nI/O多路复用程序负责监听多个套接字，并向文件事件分派器传送那些产生了事件的套接字。  \n尽管多个文件事件会有并发，但IO复用程序会将所有产生事件的套接字都放到一个队列里面，然后通过这个队列，以有序、同步、每次一个套接字的方式向文件事件分派器传送套接字。当上一个套接字产生的事件被处理完之后（该套接字为事件所关联的事件处理器执行完毕）。IO多路复用程序才会继续向文件事件分派器传送下一个套接字。  \n文件事件分派器接受IO多路复用程序传来的套接字，并根据套接字所产生的事件类型条用相应的事件处理器。  \n服务器会为执行不同任务的套接字关联不同的事件处理器，这些处理器是一个个函数，它们定义了某个事件发生时，服务器应执行的动作。  \n\n3.IO多路复用程序的实现  \nRedis的IO多路复用程序的所有功能都是通过包装常见的select、epoll、evport和kqueue这些IO多路复用函数库来实现的，每个IO多路复用函数库在Redis源码中都对应一个单独的文件。  \n\n4.事件的类型  \nIO多路复用程序会监听多个套接字的ae,h/AE_READABLE事件和ae.h/AE_WRITEABLE事件，对应关系如下：  \na.当套接字变得可读时（客户端对套接字执行write操作，或执行close操作），或者有新的可应答套接字出现时，套接字产生AE_READABLE事件。  \nb.当套接字变得可写时（客户端对套接字执行read操作），套接字产生AE_WRITEABLE事件。\n如果同时产生2种事件，文件事件分派器会优先处理AE_READABLE事件，完成之后再处理AE_WRITEABLE事件。  \n\n5.文件事件处理器  \na.连接应答处理器  \nb.命令请求处理器  \nc.命令回复处理器  \n\n下面通过一个例子来说明各个处理器的作用：  \n假设一个Redis服务器正在运作，那么这个服务器的监听套接字的AE_READABLE事件应该正处于监听状态之下，而该事件所对应的处理器为连接应答处理器。  \n如果这是有一个Redis客户端向服务器发起连接，那么监听套接字将产生AE_READABLE事件，触发连接应答处理器执行。处理器会对客户端的连接请求进行应答，然后创建客户端套接字，以及客户端状态，并将客户端套接字的AE_READABLE事件与命令请求处理器进行关联，使得客户端可以向主服务器发送命令请求。  \n之后，假设客户端向主服务器发送一个命令请求，客户端套接字将产生AE_READABLE事件，引发命令请求处理器执行，处理器读取客户端的命令内容，然后传给相关程序去执行。  \n执行命令产生的命令回复，需要传送回客户端，服务器会将客户端套接字的AE_WRITEABLE事件与命令回复处理器进行关联。当客户端尝试读取命令回复的时候，客户端套接字将产生AE_WRITEABLE事件，触发命令回复处理器执行，当命令回复处理器将命令回复全部写入到套接字之后，服务器就会接触客户端套接字的AE_WRITEABLE事件与命令回复处理器之间的关联。\n","source":"_posts/redis设计与实现/Redis文件事件.md","raw":"---\ntitle: Redis文件事件\ndate: 2015-07-11\ncategories: Redis设计与实现\ntags: Redis\n---\n\nRedis 服务器是一个事件驱动程序，服务器需要处理以下两类事件：  \n1）文件事件  \nRedis服务器通过套接字与客户端（或其他Redis服务器）进行连接，而文件事件就是服务器对套接字操作的抽象。服务器与客户端（或其他服务器）的通信会产生相应的文件事件，而服务器则通过监听并处理这些时间来完成一系列网络通信操作。  \n2）时间事件  \nRedis服务器中的一些操作（比如serverCron函数）需要在给定的时间点执行，而时间事件就是服务器对这类定时操作的抽象。  \n1.文件事件  \nRedis基于Reactor模式开发了自己的网络事件处理器：这个处理器被称为文件事件处理器：  \na,文件事件处理器使用I/O多路复用程序来同时监听多个套接字，并根据套接字目前执行的任务来为套接字关联不同的事件处理器。  \nb.当被监听的套接字准备好执行连接应答、读取、写入、关闭等操作时，与操作相对应的文件事件就会产生，调用套接字之前关联好的事件处理器来处理这些事件。  \n虽然文件事件处理器以单线程方式运行，但通过I/O多路复用程序来监听多个套接字，文件事件处理器既实现了高性能的网络通信模型，又可以很好地与Redis服务器中其他同样以单线程方式运行的模块进行对接。  \n\n2.文件事件处理器  \n4部分：套接字、 I/O多路复用程序 、 文件事件分派器 和 事件处理器。  \n文件事件是对套接字操作的抽象，每当一个套接字准备好执行连接应答、写入、读取、关闭等操作时，就会产生一个文件事件。服务器通常会连接多个套接字，所以多个文件事件可能并发出现。  \nI/O多路复用程序负责监听多个套接字，并向文件事件分派器传送那些产生了事件的套接字。  \n尽管多个文件事件会有并发，但IO复用程序会将所有产生事件的套接字都放到一个队列里面，然后通过这个队列，以有序、同步、每次一个套接字的方式向文件事件分派器传送套接字。当上一个套接字产生的事件被处理完之后（该套接字为事件所关联的事件处理器执行完毕）。IO多路复用程序才会继续向文件事件分派器传送下一个套接字。  \n文件事件分派器接受IO多路复用程序传来的套接字，并根据套接字所产生的事件类型条用相应的事件处理器。  \n服务器会为执行不同任务的套接字关联不同的事件处理器，这些处理器是一个个函数，它们定义了某个事件发生时，服务器应执行的动作。  \n\n3.IO多路复用程序的实现  \nRedis的IO多路复用程序的所有功能都是通过包装常见的select、epoll、evport和kqueue这些IO多路复用函数库来实现的，每个IO多路复用函数库在Redis源码中都对应一个单独的文件。  \n\n4.事件的类型  \nIO多路复用程序会监听多个套接字的ae,h/AE_READABLE事件和ae.h/AE_WRITEABLE事件，对应关系如下：  \na.当套接字变得可读时（客户端对套接字执行write操作，或执行close操作），或者有新的可应答套接字出现时，套接字产生AE_READABLE事件。  \nb.当套接字变得可写时（客户端对套接字执行read操作），套接字产生AE_WRITEABLE事件。\n如果同时产生2种事件，文件事件分派器会优先处理AE_READABLE事件，完成之后再处理AE_WRITEABLE事件。  \n\n5.文件事件处理器  \na.连接应答处理器  \nb.命令请求处理器  \nc.命令回复处理器  \n\n下面通过一个例子来说明各个处理器的作用：  \n假设一个Redis服务器正在运作，那么这个服务器的监听套接字的AE_READABLE事件应该正处于监听状态之下，而该事件所对应的处理器为连接应答处理器。  \n如果这是有一个Redis客户端向服务器发起连接，那么监听套接字将产生AE_READABLE事件，触发连接应答处理器执行。处理器会对客户端的连接请求进行应答，然后创建客户端套接字，以及客户端状态，并将客户端套接字的AE_READABLE事件与命令请求处理器进行关联，使得客户端可以向主服务器发送命令请求。  \n之后，假设客户端向主服务器发送一个命令请求，客户端套接字将产生AE_READABLE事件，引发命令请求处理器执行，处理器读取客户端的命令内容，然后传给相关程序去执行。  \n执行命令产生的命令回复，需要传送回客户端，服务器会将客户端套接字的AE_WRITEABLE事件与命令回复处理器进行关联。当客户端尝试读取命令回复的时候，客户端套接字将产生AE_WRITEABLE事件，触发命令回复处理器执行，当命令回复处理器将命令回复全部写入到套接字之后，服务器就会接触客户端套接字的AE_WRITEABLE事件与命令回复处理器之间的关联。\n","slug":"redis设计与实现/Redis文件事件","published":1,"updated":"2019-05-17T05:57:58.572Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1j8f2hs00107h9m1jlxpdmz","content":"<p>Redis 服务器是一个事件驱动程序，服务器需要处理以下两类事件：<br>1）文件事件<br>Redis服务器通过套接字与客户端（或其他Redis服务器）进行连接，而文件事件就是服务器对套接字操作的抽象。服务器与客户端（或其他服务器）的通信会产生相应的文件事件，而服务器则通过监听并处理这些时间来完成一系列网络通信操作。<br>2）时间事件<br>Redis服务器中的一些操作（比如serverCron函数）需要在给定的时间点执行，而时间事件就是服务器对这类定时操作的抽象。<br>1.文件事件<br>Redis基于Reactor模式开发了自己的网络事件处理器：这个处理器被称为文件事件处理器：<br>a,文件事件处理器使用I/O多路复用程序来同时监听多个套接字，并根据套接字目前执行的任务来为套接字关联不同的事件处理器。<br>b.当被监听的套接字准备好执行连接应答、读取、写入、关闭等操作时，与操作相对应的文件事件就会产生，调用套接字之前关联好的事件处理器来处理这些事件。<br>虽然文件事件处理器以单线程方式运行，但通过I/O多路复用程序来监听多个套接字，文件事件处理器既实现了高性能的网络通信模型，又可以很好地与Redis服务器中其他同样以单线程方式运行的模块进行对接。  </p>\n<p>2.文件事件处理器<br>4部分：套接字、 I/O多路复用程序 、 文件事件分派器 和 事件处理器。<br>文件事件是对套接字操作的抽象，每当一个套接字准备好执行连接应答、写入、读取、关闭等操作时，就会产生一个文件事件。服务器通常会连接多个套接字，所以多个文件事件可能并发出现。<br>I/O多路复用程序负责监听多个套接字，并向文件事件分派器传送那些产生了事件的套接字。<br>尽管多个文件事件会有并发，但IO复用程序会将所有产生事件的套接字都放到一个队列里面，然后通过这个队列，以有序、同步、每次一个套接字的方式向文件事件分派器传送套接字。当上一个套接字产生的事件被处理完之后（该套接字为事件所关联的事件处理器执行完毕）。IO多路复用程序才会继续向文件事件分派器传送下一个套接字。<br>文件事件分派器接受IO多路复用程序传来的套接字，并根据套接字所产生的事件类型条用相应的事件处理器。<br>服务器会为执行不同任务的套接字关联不同的事件处理器，这些处理器是一个个函数，它们定义了某个事件发生时，服务器应执行的动作。  </p>\n<p>3.IO多路复用程序的实现<br>Redis的IO多路复用程序的所有功能都是通过包装常见的select、epoll、evport和kqueue这些IO多路复用函数库来实现的，每个IO多路复用函数库在Redis源码中都对应一个单独的文件。  </p>\n<p>4.事件的类型<br>IO多路复用程序会监听多个套接字的ae,h/AE_READABLE事件和ae.h/AE_WRITEABLE事件，对应关系如下：<br>a.当套接字变得可读时（客户端对套接字执行write操作，或执行close操作），或者有新的可应答套接字出现时，套接字产生AE_READABLE事件。<br>b.当套接字变得可写时（客户端对套接字执行read操作），套接字产生AE_WRITEABLE事件。<br>如果同时产生2种事件，文件事件分派器会优先处理AE_READABLE事件，完成之后再处理AE_WRITEABLE事件。  </p>\n<p>5.文件事件处理器<br>a.连接应答处理器<br>b.命令请求处理器<br>c.命令回复处理器  </p>\n<p>下面通过一个例子来说明各个处理器的作用：<br>假设一个Redis服务器正在运作，那么这个服务器的监听套接字的AE_READABLE事件应该正处于监听状态之下，而该事件所对应的处理器为连接应答处理器。<br>如果这是有一个Redis客户端向服务器发起连接，那么监听套接字将产生AE_READABLE事件，触发连接应答处理器执行。处理器会对客户端的连接请求进行应答，然后创建客户端套接字，以及客户端状态，并将客户端套接字的AE_READABLE事件与命令请求处理器进行关联，使得客户端可以向主服务器发送命令请求。<br>之后，假设客户端向主服务器发送一个命令请求，客户端套接字将产生AE_READABLE事件，引发命令请求处理器执行，处理器读取客户端的命令内容，然后传给相关程序去执行。<br>执行命令产生的命令回复，需要传送回客户端，服务器会将客户端套接字的AE_WRITEABLE事件与命令回复处理器进行关联。当客户端尝试读取命令回复的时候，客户端套接字将产生AE_WRITEABLE事件，触发命令回复处理器执行，当命令回复处理器将命令回复全部写入到套接字之后，服务器就会接触客户端套接字的AE_WRITEABLE事件与命令回复处理器之间的关联。</p>\n","excerpt":"","more":"<p>Redis 服务器是一个事件驱动程序，服务器需要处理以下两类事件：<br>1）文件事件<br>Redis服务器通过套接字与客户端（或其他Redis服务器）进行连接，而文件事件就是服务器对套接字操作的抽象。服务器与客户端（或其他服务器）的通信会产生相应的文件事件，而服务器则通过监听并处理这些时间来完成一系列网络通信操作。<br>2）时间事件<br>Redis服务器中的一些操作（比如serverCron函数）需要在给定的时间点执行，而时间事件就是服务器对这类定时操作的抽象。<br>1.文件事件<br>Redis基于Reactor模式开发了自己的网络事件处理器：这个处理器被称为文件事件处理器：<br>a,文件事件处理器使用I/O多路复用程序来同时监听多个套接字，并根据套接字目前执行的任务来为套接字关联不同的事件处理器。<br>b.当被监听的套接字准备好执行连接应答、读取、写入、关闭等操作时，与操作相对应的文件事件就会产生，调用套接字之前关联好的事件处理器来处理这些事件。<br>虽然文件事件处理器以单线程方式运行，但通过I/O多路复用程序来监听多个套接字，文件事件处理器既实现了高性能的网络通信模型，又可以很好地与Redis服务器中其他同样以单线程方式运行的模块进行对接。  </p>\n<p>2.文件事件处理器<br>4部分：套接字、 I/O多路复用程序 、 文件事件分派器 和 事件处理器。<br>文件事件是对套接字操作的抽象，每当一个套接字准备好执行连接应答、写入、读取、关闭等操作时，就会产生一个文件事件。服务器通常会连接多个套接字，所以多个文件事件可能并发出现。<br>I/O多路复用程序负责监听多个套接字，并向文件事件分派器传送那些产生了事件的套接字。<br>尽管多个文件事件会有并发，但IO复用程序会将所有产生事件的套接字都放到一个队列里面，然后通过这个队列，以有序、同步、每次一个套接字的方式向文件事件分派器传送套接字。当上一个套接字产生的事件被处理完之后（该套接字为事件所关联的事件处理器执行完毕）。IO多路复用程序才会继续向文件事件分派器传送下一个套接字。<br>文件事件分派器接受IO多路复用程序传来的套接字，并根据套接字所产生的事件类型条用相应的事件处理器。<br>服务器会为执行不同任务的套接字关联不同的事件处理器，这些处理器是一个个函数，它们定义了某个事件发生时，服务器应执行的动作。  </p>\n<p>3.IO多路复用程序的实现<br>Redis的IO多路复用程序的所有功能都是通过包装常见的select、epoll、evport和kqueue这些IO多路复用函数库来实现的，每个IO多路复用函数库在Redis源码中都对应一个单独的文件。  </p>\n<p>4.事件的类型<br>IO多路复用程序会监听多个套接字的ae,h/AE_READABLE事件和ae.h/AE_WRITEABLE事件，对应关系如下：<br>a.当套接字变得可读时（客户端对套接字执行write操作，或执行close操作），或者有新的可应答套接字出现时，套接字产生AE_READABLE事件。<br>b.当套接字变得可写时（客户端对套接字执行read操作），套接字产生AE_WRITEABLE事件。<br>如果同时产生2种事件，文件事件分派器会优先处理AE_READABLE事件，完成之后再处理AE_WRITEABLE事件。  </p>\n<p>5.文件事件处理器<br>a.连接应答处理器<br>b.命令请求处理器<br>c.命令回复处理器  </p>\n<p>下面通过一个例子来说明各个处理器的作用：<br>假设一个Redis服务器正在运作，那么这个服务器的监听套接字的AE_READABLE事件应该正处于监听状态之下，而该事件所对应的处理器为连接应答处理器。<br>如果这是有一个Redis客户端向服务器发起连接，那么监听套接字将产生AE_READABLE事件，触发连接应答处理器执行。处理器会对客户端的连接请求进行应答，然后创建客户端套接字，以及客户端状态，并将客户端套接字的AE_READABLE事件与命令请求处理器进行关联，使得客户端可以向主服务器发送命令请求。<br>之后，假设客户端向主服务器发送一个命令请求，客户端套接字将产生AE_READABLE事件，引发命令请求处理器执行，处理器读取客户端的命令内容，然后传给相关程序去执行。<br>执行命令产生的命令回复，需要传送回客户端，服务器会将客户端套接字的AE_WRITEABLE事件与命令回复处理器进行关联。当客户端尝试读取命令回复的时候，客户端套接字将产生AE_WRITEABLE事件，触发命令回复处理器执行，当命令回复处理器将命令回复全部写入到套接字之后，服务器就会接触客户端套接字的AE_WRITEABLE事件与命令回复处理器之间的关联。</p>\n"},{"title":"Redis时间事件","date":"2015-07-11T16:00:00.000Z","_content":"\nRedis时间事件分为以下两类：  \n1.定时事件：程序在指定时间执行一次。  \n2.周期性事件：程序每隔指定时间执行一次。  \n\n时间事件的属性：  \n1.id：服务器为时间事件创建的全局唯一ID，ID号从小到大递增。  \n2.when：毫秒精度的unix时间戳，记录时间事件的到达时间。  \n3.timeProc：时间事件处理器，一个函数。当时间事件到达时，执行此函数。  \n\n时间事件的返回值决定了时间事件类型，如返回ae.h/AE_NOMORE，表示事件为定时事件，到达一次后则删除；如返回一个非AE_NOMORE的整数，表示事件为周期性事件，当事件到达之后，服务器会根据返回值更新时间事件的when属性，并以这种方式一直更新下去。当前Redis版本中只有周期性事件，没有使用定时事件。  \n\n实现：  \n服务器将所有时间事件都存放在一个无序列表中，每当时间事件执行器执行时，它就遍历整个链表，找到所有已到达的时间事件并调用相应事件处理器。这里的的无序链表，指的是不按when属性大小排序，其实是按ID排序了，新的时间事件总是插入链表的表头。当前Redis版本中，服务器只使用serverCron一个时间事件，而在benchmark模式下，服务器也只使用2个时间事件，所以使用无序链表来保存时间事情，并不影响性能。  \n\n事件调度伪代码：  \n``` bash\ndef aeProcessEvents():\n//获取到达时间离当前时间最接近的时间事件\ntime_event = aeSearchNearestTimer()\n//计算最接近的时间事件距离到达还有多少毫秒\nremain_ms = time_event.when - unix_ts_now()\n//如果事件已到达，那么remain_ms 值可能为负数，置为0\nif remain_ms < 0:\nremain_ms = 0\n//根据remain_ms值，创建timeval结构\ntimeval = create_timeval_with_ms(remain_ms)\n//阻塞并等待文件事件产生，最大阻塞时间由传入的timeval结构决定\n//如果remaind_ms值为0，那么aeApiPoll调用之后马上返回，不阻塞\naeApiPoll(timeval)\n//处理所有已产生的文件事件\nprocessFileEvents()\n//处理所有已到达的时间事件\nprocessTimeEvents()\n```\n\n","source":"_posts/redis设计与实现/Redis时间事件.md","raw":"---\ntitle: Redis时间事件\ndate: 2015-07-12\ncategories: Redis设计与实现\ntags: Redis\n---\n\nRedis时间事件分为以下两类：  \n1.定时事件：程序在指定时间执行一次。  \n2.周期性事件：程序每隔指定时间执行一次。  \n\n时间事件的属性：  \n1.id：服务器为时间事件创建的全局唯一ID，ID号从小到大递增。  \n2.when：毫秒精度的unix时间戳，记录时间事件的到达时间。  \n3.timeProc：时间事件处理器，一个函数。当时间事件到达时，执行此函数。  \n\n时间事件的返回值决定了时间事件类型，如返回ae.h/AE_NOMORE，表示事件为定时事件，到达一次后则删除；如返回一个非AE_NOMORE的整数，表示事件为周期性事件，当事件到达之后，服务器会根据返回值更新时间事件的when属性，并以这种方式一直更新下去。当前Redis版本中只有周期性事件，没有使用定时事件。  \n\n实现：  \n服务器将所有时间事件都存放在一个无序列表中，每当时间事件执行器执行时，它就遍历整个链表，找到所有已到达的时间事件并调用相应事件处理器。这里的的无序链表，指的是不按when属性大小排序，其实是按ID排序了，新的时间事件总是插入链表的表头。当前Redis版本中，服务器只使用serverCron一个时间事件，而在benchmark模式下，服务器也只使用2个时间事件，所以使用无序链表来保存时间事情，并不影响性能。  \n\n事件调度伪代码：  \n``` bash\ndef aeProcessEvents():\n//获取到达时间离当前时间最接近的时间事件\ntime_event = aeSearchNearestTimer()\n//计算最接近的时间事件距离到达还有多少毫秒\nremain_ms = time_event.when - unix_ts_now()\n//如果事件已到达，那么remain_ms 值可能为负数，置为0\nif remain_ms < 0:\nremain_ms = 0\n//根据remain_ms值，创建timeval结构\ntimeval = create_timeval_with_ms(remain_ms)\n//阻塞并等待文件事件产生，最大阻塞时间由传入的timeval结构决定\n//如果remaind_ms值为0，那么aeApiPoll调用之后马上返回，不阻塞\naeApiPoll(timeval)\n//处理所有已产生的文件事件\nprocessFileEvents()\n//处理所有已到达的时间事件\nprocessTimeEvents()\n```\n\n","slug":"redis设计与实现/Redis时间事件","published":1,"updated":"2019-05-17T05:57:58.573Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1j8f2hu00117h9mnno1sinq","content":"<p>Redis时间事件分为以下两类：<br>1.定时事件：程序在指定时间执行一次。<br>2.周期性事件：程序每隔指定时间执行一次。  </p>\n<p>时间事件的属性：<br>1.id：服务器为时间事件创建的全局唯一ID，ID号从小到大递增。<br>2.when：毫秒精度的unix时间戳，记录时间事件的到达时间。<br>3.timeProc：时间事件处理器，一个函数。当时间事件到达时，执行此函数。  </p>\n<p>时间事件的返回值决定了时间事件类型，如返回ae.h/AE_NOMORE，表示事件为定时事件，到达一次后则删除；如返回一个非AE_NOMORE的整数，表示事件为周期性事件，当事件到达之后，服务器会根据返回值更新时间事件的when属性，并以这种方式一直更新下去。当前Redis版本中只有周期性事件，没有使用定时事件。  </p>\n<p>实现：<br>服务器将所有时间事件都存放在一个无序列表中，每当时间事件执行器执行时，它就遍历整个链表，找到所有已到达的时间事件并调用相应事件处理器。这里的的无序链表，指的是不按when属性大小排序，其实是按ID排序了，新的时间事件总是插入链表的表头。当前Redis版本中，服务器只使用serverCron一个时间事件，而在benchmark模式下，服务器也只使用2个时间事件，所以使用无序链表来保存时间事情，并不影响性能。  </p>\n<p>事件调度伪代码：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def aeProcessEvents():</span><br><span class=\"line\">//获取到达时间离当前时间最接近的时间事件</span><br><span class=\"line\">time_event = aeSearchNearestTimer()</span><br><span class=\"line\">//计算最接近的时间事件距离到达还有多少毫秒</span><br><span class=\"line\">remain_ms = time_event.when - unix_ts_now()</span><br><span class=\"line\">//如果事件已到达，那么remain_ms 值可能为负数，置为0</span><br><span class=\"line\"><span class=\"keyword\">if</span> remain_ms &lt; 0:</span><br><span class=\"line\">remain_ms = 0</span><br><span class=\"line\">//根据remain_ms值，创建timeval结构</span><br><span class=\"line\">timeval = create_timeval_with_ms(remain_ms)</span><br><span class=\"line\">//阻塞并等待文件事件产生，最大阻塞时间由传入的timeval结构决定</span><br><span class=\"line\">//如果remaind_ms值为0，那么aeApiPoll调用之后马上返回，不阻塞</span><br><span class=\"line\">aeApiPoll(timeval)</span><br><span class=\"line\">//处理所有已产生的文件事件</span><br><span class=\"line\">processFileEvents()</span><br><span class=\"line\">//处理所有已到达的时间事件</span><br><span class=\"line\">processTimeEvents()</span><br></pre></td></tr></table></figure></p>\n","excerpt":"","more":"<p>Redis时间事件分为以下两类：<br>1.定时事件：程序在指定时间执行一次。<br>2.周期性事件：程序每隔指定时间执行一次。  </p>\n<p>时间事件的属性：<br>1.id：服务器为时间事件创建的全局唯一ID，ID号从小到大递增。<br>2.when：毫秒精度的unix时间戳，记录时间事件的到达时间。<br>3.timeProc：时间事件处理器，一个函数。当时间事件到达时，执行此函数。  </p>\n<p>时间事件的返回值决定了时间事件类型，如返回ae.h/AE_NOMORE，表示事件为定时事件，到达一次后则删除；如返回一个非AE_NOMORE的整数，表示事件为周期性事件，当事件到达之后，服务器会根据返回值更新时间事件的when属性，并以这种方式一直更新下去。当前Redis版本中只有周期性事件，没有使用定时事件。  </p>\n<p>实现：<br>服务器将所有时间事件都存放在一个无序列表中，每当时间事件执行器执行时，它就遍历整个链表，找到所有已到达的时间事件并调用相应事件处理器。这里的的无序链表，指的是不按when属性大小排序，其实是按ID排序了，新的时间事件总是插入链表的表头。当前Redis版本中，服务器只使用serverCron一个时间事件，而在benchmark模式下，服务器也只使用2个时间事件，所以使用无序链表来保存时间事情，并不影响性能。  </p>\n<p>事件调度伪代码：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def aeProcessEvents():</span><br><span class=\"line\">//获取到达时间离当前时间最接近的时间事件</span><br><span class=\"line\">time_event = aeSearchNearestTimer()</span><br><span class=\"line\">//计算最接近的时间事件距离到达还有多少毫秒</span><br><span class=\"line\">remain_ms = time_event.when - unix_ts_now()</span><br><span class=\"line\">//如果事件已到达，那么remain_ms 值可能为负数，置为0</span><br><span class=\"line\"><span class=\"keyword\">if</span> remain_ms &lt; 0:</span><br><span class=\"line\">remain_ms = 0</span><br><span class=\"line\">//根据remain_ms值，创建timeval结构</span><br><span class=\"line\">timeval = create_timeval_with_ms(remain_ms)</span><br><span class=\"line\">//阻塞并等待文件事件产生，最大阻塞时间由传入的timeval结构决定</span><br><span class=\"line\">//如果remaind_ms值为0，那么aeApiPoll调用之后马上返回，不阻塞</span><br><span class=\"line\">aeApiPoll(timeval)</span><br><span class=\"line\">//处理所有已产生的文件事件</span><br><span class=\"line\">processFileEvents()</span><br><span class=\"line\">//处理所有已到达的时间事件</span><br><span class=\"line\">processTimeEvents()</span><br></pre></td></tr></table></figure></p>\n"},{"title":"Redis服务器单机数据库的实现","date":"2015-07-21T16:00:00.000Z","_content":"\nRedis命令请求的执行过程：\n\n1.发送命令请求  \n客户端将命令请求转换成协议格式，通过连接到服务器的套接字发送给服务器。\n\n2.读取命令请求  \n1）读取套接字协议格式的请求，保存到客户端状态的缓冲输入区。  \n2）分析缓冲区命令，提取命令参数及个数，分别保存到客户端状态的argv属性和argc属性。  \n3）调用命令执行器。\n\n3.命令执行器\n\n1）查找实现命令：根据客户端状态的argv[0]参数，查找参数指定的命令，保存到客户端状态的cmd属性。  \n2）执行预备操作：检查客户端cmd属性指向、参数个数、身份验证是否合法等等一系列服务器和客户端状态的校验。  \n3）调用命令的实现函数：函数调用产生setCommand(client)将产生一个 \"+OK\\r\\n\" 回复，保存到客户端的buf属性。  \n4）执行后续工作：根据配置执行相应操作，例如慢查询日志、AOF持久化、主从服务。\n\n4.将命令回复发送给客户端：将协议格式的命令回复 +“OK\\r\\n”发送给客户端。  \n5.客户端接收并打印命令回复：将协议回复的 “OK\\r\\n” 转换成 “OK\\n” 打印给用户。\n\nRedis服务器中serverCron函数每隔100ms执行一次，该函数负责管理服务器资源并保持服务器良好运转。  \n*\t更新服务器时间缓存  \n*\t更新LRU时钟  \n*\t更新服务器每秒执行命令次数  \n*\t更新服务器内存峰值记录  \n*\t处理SIGTERM信号  \n*\t管理客户端资源  \n*\t管理数据库资源  \n*\t执行被延迟的BGREWRITEAOF  \n*\t检查持久化操作的运行状态  \n*\t将AOP缓冲区内容写入AOF文件  \n*\t关闭异步客户端  \n*\t增加cronloops计数器的值  \n","source":"_posts/redis设计与实现/Redis服务器单机数据库的实现.md","raw":"---\ntitle: Redis服务器单机数据库的实现\ndate: 2015-07-22\ncategories: Redis设计与实现\ntags: Redis\n---\n\nRedis命令请求的执行过程：\n\n1.发送命令请求  \n客户端将命令请求转换成协议格式，通过连接到服务器的套接字发送给服务器。\n\n2.读取命令请求  \n1）读取套接字协议格式的请求，保存到客户端状态的缓冲输入区。  \n2）分析缓冲区命令，提取命令参数及个数，分别保存到客户端状态的argv属性和argc属性。  \n3）调用命令执行器。\n\n3.命令执行器\n\n1）查找实现命令：根据客户端状态的argv[0]参数，查找参数指定的命令，保存到客户端状态的cmd属性。  \n2）执行预备操作：检查客户端cmd属性指向、参数个数、身份验证是否合法等等一系列服务器和客户端状态的校验。  \n3）调用命令的实现函数：函数调用产生setCommand(client)将产生一个 \"+OK\\r\\n\" 回复，保存到客户端的buf属性。  \n4）执行后续工作：根据配置执行相应操作，例如慢查询日志、AOF持久化、主从服务。\n\n4.将命令回复发送给客户端：将协议格式的命令回复 +“OK\\r\\n”发送给客户端。  \n5.客户端接收并打印命令回复：将协议回复的 “OK\\r\\n” 转换成 “OK\\n” 打印给用户。\n\nRedis服务器中serverCron函数每隔100ms执行一次，该函数负责管理服务器资源并保持服务器良好运转。  \n*\t更新服务器时间缓存  \n*\t更新LRU时钟  \n*\t更新服务器每秒执行命令次数  \n*\t更新服务器内存峰值记录  \n*\t处理SIGTERM信号  \n*\t管理客户端资源  \n*\t管理数据库资源  \n*\t执行被延迟的BGREWRITEAOF  \n*\t检查持久化操作的运行状态  \n*\t将AOP缓冲区内容写入AOF文件  \n*\t关闭异步客户端  \n*\t增加cronloops计数器的值  \n","slug":"redis设计与实现/Redis服务器单机数据库的实现","published":1,"updated":"2019-05-17T05:57:58.575Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1j8f2hv00127h9mxpupf43c","content":"<p>Redis命令请求的执行过程：</p>\n<p>1.发送命令请求<br>客户端将命令请求转换成协议格式，通过连接到服务器的套接字发送给服务器。</p>\n<p>2.读取命令请求<br>1）读取套接字协议格式的请求，保存到客户端状态的缓冲输入区。<br>2）分析缓冲区命令，提取命令参数及个数，分别保存到客户端状态的argv属性和argc属性。<br>3）调用命令执行器。</p>\n<p>3.命令执行器</p>\n<p>1）查找实现命令：根据客户端状态的argv[0]参数，查找参数指定的命令，保存到客户端状态的cmd属性。<br>2）执行预备操作：检查客户端cmd属性指向、参数个数、身份验证是否合法等等一系列服务器和客户端状态的校验。<br>3）调用命令的实现函数：函数调用产生setCommand(client)将产生一个 “+OK\\r\\n” 回复，保存到客户端的buf属性。<br>4）执行后续工作：根据配置执行相应操作，例如慢查询日志、AOF持久化、主从服务。</p>\n<p>4.将命令回复发送给客户端：将协议格式的命令回复 +“OK\\r\\n”发送给客户端。<br>5.客户端接收并打印命令回复：将协议回复的 “OK\\r\\n” 转换成 “OK\\n” 打印给用户。</p>\n<p>Redis服务器中serverCron函数每隔100ms执行一次，该函数负责管理服务器资源并保持服务器良好运转。  </p>\n<ul>\n<li>更新服务器时间缓存  </li>\n<li>更新LRU时钟  </li>\n<li>更新服务器每秒执行命令次数  </li>\n<li>更新服务器内存峰值记录  </li>\n<li>处理SIGTERM信号  </li>\n<li>管理客户端资源  </li>\n<li>管理数据库资源  </li>\n<li>执行被延迟的BGREWRITEAOF  </li>\n<li>检查持久化操作的运行状态  </li>\n<li>将AOP缓冲区内容写入AOF文件  </li>\n<li>关闭异步客户端  </li>\n<li>增加cronloops计数器的值  </li>\n</ul>\n","excerpt":"","more":"<p>Redis命令请求的执行过程：</p>\n<p>1.发送命令请求<br>客户端将命令请求转换成协议格式，通过连接到服务器的套接字发送给服务器。</p>\n<p>2.读取命令请求<br>1）读取套接字协议格式的请求，保存到客户端状态的缓冲输入区。<br>2）分析缓冲区命令，提取命令参数及个数，分别保存到客户端状态的argv属性和argc属性。<br>3）调用命令执行器。</p>\n<p>3.命令执行器</p>\n<p>1）查找实现命令：根据客户端状态的argv[0]参数，查找参数指定的命令，保存到客户端状态的cmd属性。<br>2）执行预备操作：检查客户端cmd属性指向、参数个数、身份验证是否合法等等一系列服务器和客户端状态的校验。<br>3）调用命令的实现函数：函数调用产生setCommand(client)将产生一个 “+OK\\r\\n” 回复，保存到客户端的buf属性。<br>4）执行后续工作：根据配置执行相应操作，例如慢查询日志、AOF持久化、主从服务。</p>\n<p>4.将命令回复发送给客户端：将协议格式的命令回复 +“OK\\r\\n”发送给客户端。<br>5.客户端接收并打印命令回复：将协议回复的 “OK\\r\\n” 转换成 “OK\\n” 打印给用户。</p>\n<p>Redis服务器中serverCron函数每隔100ms执行一次，该函数负责管理服务器资源并保持服务器良好运转。  </p>\n<ul>\n<li>更新服务器时间缓存  </li>\n<li>更新LRU时钟  </li>\n<li>更新服务器每秒执行命令次数  </li>\n<li>更新服务器内存峰值记录  </li>\n<li>处理SIGTERM信号  </li>\n<li>管理客户端资源  </li>\n<li>管理数据库资源  </li>\n<li>执行被延迟的BGREWRITEAOF  </li>\n<li>检查持久化操作的运行状态  </li>\n<li>将AOP缓冲区内容写入AOF文件  </li>\n<li>关闭异步客户端  </li>\n<li>增加cronloops计数器的值  </li>\n</ul>\n"},{"title":"Redis简单动态字符串","date":"2015-06-22T16:00:00.000Z","_content":"\nRedis使用SDS(simple dynamic string)用作字符串默认实现。\n\n``` bash\nstruct sdshdr{\n\t//已使用buf数组的字节数量，也就是字符串长度\n\tint len;\n\t//未使用的长度\n\tint free;\n\t//保存字符串\n\tchar buf[];\n}\n```\n\n*\tSDS遵循C语言字符串以空字符串结尾，保留1个字节的空字符串'\\0'，该空串不记入len中。\n\n*\tC语言中，获取字符串长度需要遍历整个字符串，时间复杂度为O(n)，SDS中有len属性维护长度，时间复杂度为O(1)，Java里面String不可变，初始化的时候就记录了长度，时间复杂度啊也是O(n)。\n\n*\tSDS空间分配策略杜绝缓冲区溢出的可能。当需要对SDS进行修改时，API会先检查SDS剩余空间是否满足需求，如不满足会自动扩容。\n\n*\tSDS内存分配策略：  \n\n1.\t空间预分配:  当SDS长度(len)小于1MB，程序会分配和len同样大小的未使用空间，这是len===free。例如修改后字符串长度为13字节，就会分配13字节的未使用空间，此时buf=len+free+1=13+13+1=27字节，其中1是'\\0'。当SDS被修改后长度大于1MB，程序会分配1MB的未使用空间。即使len=50MB，也还是分配1MB的未使用空间。通过空间预分配策略，Redis可以有效减少连续修改字符串操作引起的内存分配次数。\n\n2.\t惰性空间释放:\t当SDS字符串进行缩短操作时，程序不会立即重新分配内存来回收多的字节，而是用free记录，等待将来使用。例如SDS：abcxyz，修改成abc，SDS并不会释放多余出来的3个字节，而是将free=free+3，以备将来字符串增长操作时使用。\n\n*\tSDS是二进制安全的。\n","source":"_posts/redis设计与实现/Redis简单动态字符串.md","raw":"---\ntitle: Redis简单动态字符串\ndate: 2015-06-23\ncategories: Redis设计与实现\ntags: Redis\n---\n\nRedis使用SDS(simple dynamic string)用作字符串默认实现。\n\n``` bash\nstruct sdshdr{\n\t//已使用buf数组的字节数量，也就是字符串长度\n\tint len;\n\t//未使用的长度\n\tint free;\n\t//保存字符串\n\tchar buf[];\n}\n```\n\n*\tSDS遵循C语言字符串以空字符串结尾，保留1个字节的空字符串'\\0'，该空串不记入len中。\n\n*\tC语言中，获取字符串长度需要遍历整个字符串，时间复杂度为O(n)，SDS中有len属性维护长度，时间复杂度为O(1)，Java里面String不可变，初始化的时候就记录了长度，时间复杂度啊也是O(n)。\n\n*\tSDS空间分配策略杜绝缓冲区溢出的可能。当需要对SDS进行修改时，API会先检查SDS剩余空间是否满足需求，如不满足会自动扩容。\n\n*\tSDS内存分配策略：  \n\n1.\t空间预分配:  当SDS长度(len)小于1MB，程序会分配和len同样大小的未使用空间，这是len===free。例如修改后字符串长度为13字节，就会分配13字节的未使用空间，此时buf=len+free+1=13+13+1=27字节，其中1是'\\0'。当SDS被修改后长度大于1MB，程序会分配1MB的未使用空间。即使len=50MB，也还是分配1MB的未使用空间。通过空间预分配策略，Redis可以有效减少连续修改字符串操作引起的内存分配次数。\n\n2.\t惰性空间释放:\t当SDS字符串进行缩短操作时，程序不会立即重新分配内存来回收多的字节，而是用free记录，等待将来使用。例如SDS：abcxyz，修改成abc，SDS并不会释放多余出来的3个字节，而是将free=free+3，以备将来字符串增长操作时使用。\n\n*\tSDS是二进制安全的。\n","slug":"redis设计与实现/Redis简单动态字符串","published":1,"updated":"2019-05-17T05:57:58.576Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1j8f2hw00137h9m4neqz99l","content":"<p>Redis使用SDS(simple dynamic string)用作字符串默认实现。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct sdshdr&#123;</span><br><span class=\"line\">\t//已使用buf数组的字节数量，也就是字符串长度</span><br><span class=\"line\">\tint len;</span><br><span class=\"line\">\t//未使用的长度</span><br><span class=\"line\">\tint free;</span><br><span class=\"line\">\t//保存字符串</span><br><span class=\"line\">\tchar buf[];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>SDS遵循C语言字符串以空字符串结尾，保留1个字节的空字符串’\\0’，该空串不记入len中。</p>\n</li>\n<li><p>C语言中，获取字符串长度需要遍历整个字符串，时间复杂度为O(n)，SDS中有len属性维护长度，时间复杂度为O(1)，Java里面String不可变，初始化的时候就记录了长度，时间复杂度啊也是O(n)。</p>\n</li>\n<li><p>SDS空间分配策略杜绝缓冲区溢出的可能。当需要对SDS进行修改时，API会先检查SDS剩余空间是否满足需求，如不满足会自动扩容。</p>\n</li>\n<li><p>SDS内存分配策略：  </p>\n</li>\n</ul>\n<ol>\n<li><p>空间预分配:  当SDS长度(len)小于1MB，程序会分配和len同样大小的未使用空间，这是len===free。例如修改后字符串长度为13字节，就会分配13字节的未使用空间，此时buf=len+free+1=13+13+1=27字节，其中1是’\\0’。当SDS被修改后长度大于1MB，程序会分配1MB的未使用空间。即使len=50MB，也还是分配1MB的未使用空间。通过空间预分配策略，Redis可以有效减少连续修改字符串操作引起的内存分配次数。</p>\n</li>\n<li><p>惰性空间释放:    当SDS字符串进行缩短操作时，程序不会立即重新分配内存来回收多的字节，而是用free记录，等待将来使用。例如SDS：abcxyz，修改成abc，SDS并不会释放多余出来的3个字节，而是将free=free+3，以备将来字符串增长操作时使用。</p>\n</li>\n</ol>\n<ul>\n<li>SDS是二进制安全的。</li>\n</ul>\n","excerpt":"","more":"<p>Redis使用SDS(simple dynamic string)用作字符串默认实现。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct sdshdr&#123;</span><br><span class=\"line\">\t//已使用buf数组的字节数量，也就是字符串长度</span><br><span class=\"line\">\tint len;</span><br><span class=\"line\">\t//未使用的长度</span><br><span class=\"line\">\tint free;</span><br><span class=\"line\">\t//保存字符串</span><br><span class=\"line\">\tchar buf[];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>SDS遵循C语言字符串以空字符串结尾，保留1个字节的空字符串’\\0’，该空串不记入len中。</p>\n</li>\n<li><p>C语言中，获取字符串长度需要遍历整个字符串，时间复杂度为O(n)，SDS中有len属性维护长度，时间复杂度为O(1)，Java里面String不可变，初始化的时候就记录了长度，时间复杂度啊也是O(n)。</p>\n</li>\n<li><p>SDS空间分配策略杜绝缓冲区溢出的可能。当需要对SDS进行修改时，API会先检查SDS剩余空间是否满足需求，如不满足会自动扩容。</p>\n</li>\n<li><p>SDS内存分配策略：  </p>\n</li>\n</ul>\n<ol>\n<li><p>空间预分配:  当SDS长度(len)小于1MB，程序会分配和len同样大小的未使用空间，这是len===free。例如修改后字符串长度为13字节，就会分配13字节的未使用空间，此时buf=len+free+1=13+13+1=27字节，其中1是’\\0’。当SDS被修改后长度大于1MB，程序会分配1MB的未使用空间。即使len=50MB，也还是分配1MB的未使用空间。通过空间预分配策略，Redis可以有效减少连续修改字符串操作引起的内存分配次数。</p>\n</li>\n<li><p>惰性空间释放:    当SDS字符串进行缩短操作时，程序不会立即重新分配内存来回收多的字节，而是用free记录，等待将来使用。例如SDS：abcxyz，修改成abc，SDS并不会释放多余出来的3个字节，而是将free=free+3，以备将来字符串增长操作时使用。</p>\n</li>\n</ol>\n<ul>\n<li>SDS是二进制安全的。</li>\n</ul>\n"},{"title":"Redis类型检查和命令多态","date":"2015-06-30T16:00:00.000Z","_content":"\nRedis中用于操作键的命令基本可以分为2类。\n\n其中一种是可以对任何类型的键执行，比如DEL,EXPIRE,RENAME,TYPE,OBJECT,TTL等命令。\n\n另一种只能对特定的键执行，比如：\nSET,GET,APPEND,STRLEN 等仅限用于字符串的键类型；\nHDEL,HSET,HGET,HLEN 等仅限用于哈希键类型；\nRPUSH,LPOP,LINSERT,LLEN 等仅限用于列表键类型；\nSADD,SPOP,SINTER,SCARD 等仅限用于集合键类型；\nZADD,ZCARD,ZRANK,ZSCORE 等仅限用于有序集合键类型；\n\n在执行一个类型特定命令之前，Redis会先检查输入键类型是否正确，然后再决定是否执行命令。\n如果键名称正确，再检查键对象是否是执行命令所需的类型，不是的话就返回一个类型错误。\n\n多态命令的实现除了检查键类型和命令是否匹配外，还会检查键的至对象所使用的编码。例如，LLEN命令。\n如果列表对象编码为ziplist,，说明对象为压缩列表，程序使用ziplistlen作为底层实现返回列表长度。\n如果列表对象编码为linkedlist，说明对象为双端链表，程序使用listLength作为底层实现返回链表长度。\n","source":"_posts/redis设计与实现/Redis类型检查和命令多态.md","raw":"---\ntitle: Redis类型检查和命令多态\ndate: 2015-07-01\ncategories: Redis设计与实现\ntags: Redis\n---\n\nRedis中用于操作键的命令基本可以分为2类。\n\n其中一种是可以对任何类型的键执行，比如DEL,EXPIRE,RENAME,TYPE,OBJECT,TTL等命令。\n\n另一种只能对特定的键执行，比如：\nSET,GET,APPEND,STRLEN 等仅限用于字符串的键类型；\nHDEL,HSET,HGET,HLEN 等仅限用于哈希键类型；\nRPUSH,LPOP,LINSERT,LLEN 等仅限用于列表键类型；\nSADD,SPOP,SINTER,SCARD 等仅限用于集合键类型；\nZADD,ZCARD,ZRANK,ZSCORE 等仅限用于有序集合键类型；\n\n在执行一个类型特定命令之前，Redis会先检查输入键类型是否正确，然后再决定是否执行命令。\n如果键名称正确，再检查键对象是否是执行命令所需的类型，不是的话就返回一个类型错误。\n\n多态命令的实现除了检查键类型和命令是否匹配外，还会检查键的至对象所使用的编码。例如，LLEN命令。\n如果列表对象编码为ziplist,，说明对象为压缩列表，程序使用ziplistlen作为底层实现返回列表长度。\n如果列表对象编码为linkedlist，说明对象为双端链表，程序使用listLength作为底层实现返回链表长度。\n","slug":"redis设计与实现/Redis类型检查和命令多态","published":1,"updated":"2019-05-17T05:57:58.577Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1j8f2hz00147h9muacpuqhs","content":"<p>Redis中用于操作键的命令基本可以分为2类。</p>\n<p>其中一种是可以对任何类型的键执行，比如DEL,EXPIRE,RENAME,TYPE,OBJECT,TTL等命令。</p>\n<p>另一种只能对特定的键执行，比如：<br>SET,GET,APPEND,STRLEN 等仅限用于字符串的键类型；<br>HDEL,HSET,HGET,HLEN 等仅限用于哈希键类型；<br>RPUSH,LPOP,LINSERT,LLEN 等仅限用于列表键类型；<br>SADD,SPOP,SINTER,SCARD 等仅限用于集合键类型；<br>ZADD,ZCARD,ZRANK,ZSCORE 等仅限用于有序集合键类型；</p>\n<p>在执行一个类型特定命令之前，Redis会先检查输入键类型是否正确，然后再决定是否执行命令。<br>如果键名称正确，再检查键对象是否是执行命令所需的类型，不是的话就返回一个类型错误。</p>\n<p>多态命令的实现除了检查键类型和命令是否匹配外，还会检查键的至对象所使用的编码。例如，LLEN命令。<br>如果列表对象编码为ziplist,，说明对象为压缩列表，程序使用ziplistlen作为底层实现返回列表长度。<br>如果列表对象编码为linkedlist，说明对象为双端链表，程序使用listLength作为底层实现返回链表长度。</p>\n","excerpt":"","more":"<p>Redis中用于操作键的命令基本可以分为2类。</p>\n<p>其中一种是可以对任何类型的键执行，比如DEL,EXPIRE,RENAME,TYPE,OBJECT,TTL等命令。</p>\n<p>另一种只能对特定的键执行，比如：<br>SET,GET,APPEND,STRLEN 等仅限用于字符串的键类型；<br>HDEL,HSET,HGET,HLEN 等仅限用于哈希键类型；<br>RPUSH,LPOP,LINSERT,LLEN 等仅限用于列表键类型；<br>SADD,SPOP,SINTER,SCARD 等仅限用于集合键类型；<br>ZADD,ZCARD,ZRANK,ZSCORE 等仅限用于有序集合键类型；</p>\n<p>在执行一个类型特定命令之前，Redis会先检查输入键类型是否正确，然后再决定是否执行命令。<br>如果键名称正确，再检查键对象是否是执行命令所需的类型，不是的话就返回一个类型错误。</p>\n<p>多态命令的实现除了检查键类型和命令是否匹配外，还会检查键的至对象所使用的编码。例如，LLEN命令。<br>如果列表对象编码为ziplist,，说明对象为压缩列表，程序使用ziplistlen作为底层实现返回列表长度。<br>如果列表对象编码为linkedlist，说明对象为双端链表，程序使用listLength作为底层实现返回链表长度。</p>\n"},{"title":"Redis链表数据结构","date":"2015-06-23T16:00:00.000Z","_content":"\n``` bash\ntypeof struct listNode {\n\t//前置节点\n\tstruct listNode *prev;\n\t//后置节点\n\tstruct listNode *next;\n\t//节点的值\n\tvoid *value；\n\t} listNode;\n\t链接的数据结构：\n\ttypeof struct list {\n\t//表头节点\n\tlistNode *head;\n\t//表尾节点\n\tlistNode *tail;\n\t//节点数量\n\tunsiged long len;\n\t//节点复制函数\n\tvoid *(*dup) (void *ptr);\n\t//节点释放函数\n\tvoid (*free) (void *ptr);\n\t//节点对比函数\n\tint (*match) (void *ptr, void *key);\n} list;\n```\n","source":"_posts/redis设计与实现/Redis链表数据结构.md","raw":"---\ntitle: Redis链表数据结构\ndate: 2015-06-24\ncategories: Redis设计与实现\ntags: Redis\n---\n\n``` bash\ntypeof struct listNode {\n\t//前置节点\n\tstruct listNode *prev;\n\t//后置节点\n\tstruct listNode *next;\n\t//节点的值\n\tvoid *value；\n\t} listNode;\n\t链接的数据结构：\n\ttypeof struct list {\n\t//表头节点\n\tlistNode *head;\n\t//表尾节点\n\tlistNode *tail;\n\t//节点数量\n\tunsiged long len;\n\t//节点复制函数\n\tvoid *(*dup) (void *ptr);\n\t//节点释放函数\n\tvoid (*free) (void *ptr);\n\t//节点对比函数\n\tint (*match) (void *ptr, void *key);\n} list;\n```\n","slug":"redis设计与实现/Redis链表数据结构","published":1,"updated":"2019-05-17T05:57:58.578Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1j8f2i100157h9macdfsgye","content":"<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typeof struct listNode &#123;</span><br><span class=\"line\">\t//前置节点</span><br><span class=\"line\">\tstruct listNode *prev;</span><br><span class=\"line\">\t//后置节点</span><br><span class=\"line\">\tstruct listNode *next;</span><br><span class=\"line\">\t//节点的值</span><br><span class=\"line\">\tvoid *value；</span><br><span class=\"line\">\t&#125; listNode;</span><br><span class=\"line\">\t链接的数据结构：</span><br><span class=\"line\">\ttypeof struct list &#123;</span><br><span class=\"line\">\t//表头节点</span><br><span class=\"line\">\tlistNode *head;</span><br><span class=\"line\">\t//表尾节点</span><br><span class=\"line\">\tlistNode *tail;</span><br><span class=\"line\">\t//节点数量</span><br><span class=\"line\">\tunsiged long len;</span><br><span class=\"line\">\t//节点复制函数</span><br><span class=\"line\">\tvoid *(*dup) (void *ptr);</span><br><span class=\"line\">\t//节点释放函数</span><br><span class=\"line\">\tvoid (*free) (void *ptr);</span><br><span class=\"line\">\t//节点对比函数</span><br><span class=\"line\">\tint (*match) (void *ptr, void *key);</span><br><span class=\"line\">&#125; list;</span><br></pre></td></tr></table></figure>\n","excerpt":"","more":"<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typeof struct listNode &#123;</span><br><span class=\"line\">\t//前置节点</span><br><span class=\"line\">\tstruct listNode *prev;</span><br><span class=\"line\">\t//后置节点</span><br><span class=\"line\">\tstruct listNode *next;</span><br><span class=\"line\">\t//节点的值</span><br><span class=\"line\">\tvoid *value；</span><br><span class=\"line\">\t&#125; listNode;</span><br><span class=\"line\">\t链接的数据结构：</span><br><span class=\"line\">\ttypeof struct list &#123;</span><br><span class=\"line\">\t//表头节点</span><br><span class=\"line\">\tlistNode *head;</span><br><span class=\"line\">\t//表尾节点</span><br><span class=\"line\">\tlistNode *tail;</span><br><span class=\"line\">\t//节点数量</span><br><span class=\"line\">\tunsiged long len;</span><br><span class=\"line\">\t//节点复制函数</span><br><span class=\"line\">\tvoid *(*dup) (void *ptr);</span><br><span class=\"line\">\t//节点释放函数</span><br><span class=\"line\">\tvoid (*free) (void *ptr);</span><br><span class=\"line\">\t//节点对比函数</span><br><span class=\"line\">\tint (*match) (void *ptr, void *key);</span><br><span class=\"line\">&#125; list;</span><br></pre></td></tr></table></figure>\n"},{"title":"垃圾收集器算法","date":"2016-05-14T16:00:00.000Z","_content":"\n#\t引用计数算法\n给对象添加引用计数器，每增加一个地方引用时，计数器加1，引用失效时，计数器减1。\n\n主流的JVM里面并没有选用引用计数法来管理内存，原因是它很难解决对象之间相互循环引用的问题。\n微软的COM技术、使用ActionScript的FlashPlayer、Python语言和游戏脚本领域被广泛应用的Squirrel中都使用了引用计数法管理内存。\n\n#\t可达性分析算法\n\n通过一系列称为\"GC Roots\"的对象作为起始点，从这些节点向下搜索，搜索走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连时，则证明对象不可用。  \n在Java语言中，可作为GC Roots对象包括下面几种：  \n*\t虚拟机栈（栈帧中的本地变量表）中引用的对象。  \n*\t方法区中类静态属性引用的对象。  \n*\t方法区中常量引用的对象。  \n* \t本地方法栈中JNI（Native方法）引用的对象。\n\n#\t引用\nJDK1.2后，Java对引用概念进行扩充，将引用分为强引用、软引用、弱引用、虚引用4种。  \n*\t强引用是指在程序代码中普遍存在的，类似“Object object = new Object()”这类的引用，只要强引用存在，垃圾收集器永远不会回收被引用的对象。  \n* \t软引用用来描述一些还有用但并非必须的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收还没有足够内存，才会抛出内存溢出异常。JDK1.2后，提供SoftReference类实现软引用。  \n*  弱引用也是描述非必须对象，它的强度较软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉被弱引用关联的对象。JDK1.2后，提供WeakReference类实现弱引用。  \n*  虚引用也称为幽灵引用或幻影引用，是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。JDK1.2后，提供PhantomReference类实现虚引用。\n\n#\t回收方法区\nJVM规范中说过可以不要求虚拟机在方法区实现垃圾收集，而且在方法区中进行垃圾收集的“性价比”一般比较低：在堆中，尤其在新生代中，常规应用进行一次垃圾收集一般可以回收70%-95%的空间，而永久代的垃圾搜集效率远低于此。  \n永久代的垃圾收集主要回收两部分内容：废弃常量和无用的类。  \n判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用的类”的条件则相对苛刻许多。类要同时满足下面3个条件才能算是“无用的类”：  \n1.\t该类所有的实例都已经被回收，也就是说Java堆中不存在该类的任何实例。\n2.\t加载该类的ClassLoader已经被回收。  \n3. \t该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。  \n\nJVM可以对满足上述3各条件的无用类进行回收，这里说的是“可以”，并不是和对象一样，不使用了必然回收。是否对类进行回收，HotSpot虚拟机提供了 -Xnoclassgc 参数进行控制，还可以使用 -verbose:class 以及 -XX:+TraceClassLoading、 -XX:+TraceClassUnLaoding查看类加载和卸载信息，其中 -verboss:class 和 -XX:+TraceClassLoading 可以在Product版的虚拟机中使用。 -XX:+TraceClassUnLoading参数需要FastDebug版的虚拟机支持。  \n在大量使用反射、动态代理、CGLib等ByteCode框架、动态生成JSP以及OSGi这类频繁自定义ClassLoader的场景都需要虚拟机具备类卸载的功能，以保证永久代不会溢出。\n\n#\t垃圾收集算法\n##\t标记-清除算法\n算法分为“标记”和“清除”两个阶段：首先标记处所有需要回收的对象，在标记完成后统一回收所有被标记的对象。主要不足有2处：一个是效率问题，标记和清除两个过程效率都不高；另一个是空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能导致以后程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前出发另一次垃圾收集动作。\n\n##\t复制算法\n为了解决效率问题，复制收集算法出现了。它将可用内存按容量分为大小相等的两块，每次只使用其中一块。当这一块内存用完了，就将还存活着的对象复制到另一块上面，然后再把已经使用过的内存空间一次清理掉。\n\n现在的商业虚拟机都采用这种收集算法来回收新生代，IBM公司专门研究表明，新生代的对象95%是“朝生夕死”的，所以并不需要1:1的比例来划分内存空间，而是将内存分为一块较大的Eden空间和两块较小的Survior空间，每次使用Eden和其中一块Survior。当回收时，将Eden和Survior中还存活着的对象一次性地复制到另一块Survior空间上，最后清理掉Eden和刚才用过的Survior空间。HotSpot默认Eden和Survior的大小比例是8:1，也就是每次新生代中可用内存空间为整个新生代容量的90%（80%+10%）。我们没有办法保证每次回收都只有不多于10%的对象存活，当Survior空间不够用时，需要依赖其他内存（这里指老年代）进行分配担保。\n\n如果另外一块Survior空间没有足够空间存放上一次新生代收集下来的存活对象时，这些对象将直接通过分配担保机制进入老年代。\n\n##\t标记-整理算法\n复制收集算法在对象存活率较高时就要进行较多的复制操作，效率将会变低。根据老年代的特点，有人提出了“标记-整理”算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。\n\n##\t分代收集算法\n当前商业虚拟机的垃圾手机都采用“分代收集”算法，一般把Java堆分为新生代和老年代。新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记-清理”或者“标记-整理”算法来进行回收。","source":"_posts/深入理解Java虚拟机/垃圾收集器算法.md","raw":"---\ntitle: 垃圾收集器算法\ndate: 2016-05-15\ncategories: 深入理解Java虚拟机\ntags: JVM\n---\n\n#\t引用计数算法\n给对象添加引用计数器，每增加一个地方引用时，计数器加1，引用失效时，计数器减1。\n\n主流的JVM里面并没有选用引用计数法来管理内存，原因是它很难解决对象之间相互循环引用的问题。\n微软的COM技术、使用ActionScript的FlashPlayer、Python语言和游戏脚本领域被广泛应用的Squirrel中都使用了引用计数法管理内存。\n\n#\t可达性分析算法\n\n通过一系列称为\"GC Roots\"的对象作为起始点，从这些节点向下搜索，搜索走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连时，则证明对象不可用。  \n在Java语言中，可作为GC Roots对象包括下面几种：  \n*\t虚拟机栈（栈帧中的本地变量表）中引用的对象。  \n*\t方法区中类静态属性引用的对象。  \n*\t方法区中常量引用的对象。  \n* \t本地方法栈中JNI（Native方法）引用的对象。\n\n#\t引用\nJDK1.2后，Java对引用概念进行扩充，将引用分为强引用、软引用、弱引用、虚引用4种。  \n*\t强引用是指在程序代码中普遍存在的，类似“Object object = new Object()”这类的引用，只要强引用存在，垃圾收集器永远不会回收被引用的对象。  \n* \t软引用用来描述一些还有用但并非必须的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收还没有足够内存，才会抛出内存溢出异常。JDK1.2后，提供SoftReference类实现软引用。  \n*  弱引用也是描述非必须对象，它的强度较软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉被弱引用关联的对象。JDK1.2后，提供WeakReference类实现弱引用。  \n*  虚引用也称为幽灵引用或幻影引用，是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。JDK1.2后，提供PhantomReference类实现虚引用。\n\n#\t回收方法区\nJVM规范中说过可以不要求虚拟机在方法区实现垃圾收集，而且在方法区中进行垃圾收集的“性价比”一般比较低：在堆中，尤其在新生代中，常规应用进行一次垃圾收集一般可以回收70%-95%的空间，而永久代的垃圾搜集效率远低于此。  \n永久代的垃圾收集主要回收两部分内容：废弃常量和无用的类。  \n判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用的类”的条件则相对苛刻许多。类要同时满足下面3个条件才能算是“无用的类”：  \n1.\t该类所有的实例都已经被回收，也就是说Java堆中不存在该类的任何实例。\n2.\t加载该类的ClassLoader已经被回收。  \n3. \t该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。  \n\nJVM可以对满足上述3各条件的无用类进行回收，这里说的是“可以”，并不是和对象一样，不使用了必然回收。是否对类进行回收，HotSpot虚拟机提供了 -Xnoclassgc 参数进行控制，还可以使用 -verbose:class 以及 -XX:+TraceClassLoading、 -XX:+TraceClassUnLaoding查看类加载和卸载信息，其中 -verboss:class 和 -XX:+TraceClassLoading 可以在Product版的虚拟机中使用。 -XX:+TraceClassUnLoading参数需要FastDebug版的虚拟机支持。  \n在大量使用反射、动态代理、CGLib等ByteCode框架、动态生成JSP以及OSGi这类频繁自定义ClassLoader的场景都需要虚拟机具备类卸载的功能，以保证永久代不会溢出。\n\n#\t垃圾收集算法\n##\t标记-清除算法\n算法分为“标记”和“清除”两个阶段：首先标记处所有需要回收的对象，在标记完成后统一回收所有被标记的对象。主要不足有2处：一个是效率问题，标记和清除两个过程效率都不高；另一个是空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能导致以后程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前出发另一次垃圾收集动作。\n\n##\t复制算法\n为了解决效率问题，复制收集算法出现了。它将可用内存按容量分为大小相等的两块，每次只使用其中一块。当这一块内存用完了，就将还存活着的对象复制到另一块上面，然后再把已经使用过的内存空间一次清理掉。\n\n现在的商业虚拟机都采用这种收集算法来回收新生代，IBM公司专门研究表明，新生代的对象95%是“朝生夕死”的，所以并不需要1:1的比例来划分内存空间，而是将内存分为一块较大的Eden空间和两块较小的Survior空间，每次使用Eden和其中一块Survior。当回收时，将Eden和Survior中还存活着的对象一次性地复制到另一块Survior空间上，最后清理掉Eden和刚才用过的Survior空间。HotSpot默认Eden和Survior的大小比例是8:1，也就是每次新生代中可用内存空间为整个新生代容量的90%（80%+10%）。我们没有办法保证每次回收都只有不多于10%的对象存活，当Survior空间不够用时，需要依赖其他内存（这里指老年代）进行分配担保。\n\n如果另外一块Survior空间没有足够空间存放上一次新生代收集下来的存活对象时，这些对象将直接通过分配担保机制进入老年代。\n\n##\t标记-整理算法\n复制收集算法在对象存活率较高时就要进行较多的复制操作，效率将会变低。根据老年代的特点，有人提出了“标记-整理”算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。\n\n##\t分代收集算法\n当前商业虚拟机的垃圾手机都采用“分代收集”算法，一般把Java堆分为新生代和老年代。新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记-清理”或者“标记-整理”算法来进行回收。","slug":"深入理解Java虚拟机/垃圾收集器算法","published":1,"updated":"2019-05-17T05:57:58.580Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1j8f2i200167h9mvk262j36","content":"<h1 id=\"引用计数算法\"><a href=\"#引用计数算法\" class=\"headerlink\" title=\"引用计数算法\"></a>引用计数算法</h1><p>给对象添加引用计数器，每增加一个地方引用时，计数器加1，引用失效时，计数器减1。</p>\n<p>主流的JVM里面并没有选用引用计数法来管理内存，原因是它很难解决对象之间相互循环引用的问题。<br>微软的COM技术、使用ActionScript的FlashPlayer、Python语言和游戏脚本领域被广泛应用的Squirrel中都使用了引用计数法管理内存。</p>\n<h1 id=\"可达性分析算法\"><a href=\"#可达性分析算法\" class=\"headerlink\" title=\"可达性分析算法\"></a>可达性分析算法</h1><p>通过一系列称为”GC Roots”的对象作为起始点，从这些节点向下搜索，搜索走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连时，则证明对象不可用。<br>在Java语言中，可作为GC Roots对象包括下面几种：  </p>\n<ul>\n<li>虚拟机栈（栈帧中的本地变量表）中引用的对象。  </li>\n<li>方法区中类静态属性引用的对象。  </li>\n<li>方法区中常量引用的对象。  </li>\n<li>本地方法栈中JNI（Native方法）引用的对象。</li>\n</ul>\n<h1 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h1><p>JDK1.2后，Java对引用概念进行扩充，将引用分为强引用、软引用、弱引用、虚引用4种。  </p>\n<ul>\n<li>强引用是指在程序代码中普遍存在的，类似“Object object = new Object()”这类的引用，只要强引用存在，垃圾收集器永远不会回收被引用的对象。  </li>\n<li>软引用用来描述一些还有用但并非必须的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收还没有足够内存，才会抛出内存溢出异常。JDK1.2后，提供SoftReference类实现软引用。  </li>\n<li>弱引用也是描述非必须对象，它的强度较软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉被弱引用关联的对象。JDK1.2后，提供WeakReference类实现弱引用。  </li>\n<li>虚引用也称为幽灵引用或幻影引用，是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。JDK1.2后，提供PhantomReference类实现虚引用。</li>\n</ul>\n<h1 id=\"回收方法区\"><a href=\"#回收方法区\" class=\"headerlink\" title=\"回收方法区\"></a>回收方法区</h1><p>JVM规范中说过可以不要求虚拟机在方法区实现垃圾收集，而且在方法区中进行垃圾收集的“性价比”一般比较低：在堆中，尤其在新生代中，常规应用进行一次垃圾收集一般可以回收70%-95%的空间，而永久代的垃圾搜集效率远低于此。<br>永久代的垃圾收集主要回收两部分内容：废弃常量和无用的类。<br>判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用的类”的条件则相对苛刻许多。类要同时满足下面3个条件才能算是“无用的类”：  </p>\n<ol>\n<li>该类所有的实例都已经被回收，也就是说Java堆中不存在该类的任何实例。</li>\n<li>加载该类的ClassLoader已经被回收。  </li>\n<li>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。  </li>\n</ol>\n<p>JVM可以对满足上述3各条件的无用类进行回收，这里说的是“可以”，并不是和对象一样，不使用了必然回收。是否对类进行回收，HotSpot虚拟机提供了 -Xnoclassgc 参数进行控制，还可以使用 -verbose:class 以及 -XX:+TraceClassLoading、 -XX:+TraceClassUnLaoding查看类加载和卸载信息，其中 -verboss:class 和 -XX:+TraceClassLoading 可以在Product版的虚拟机中使用。 -XX:+TraceClassUnLoading参数需要FastDebug版的虚拟机支持。<br>在大量使用反射、动态代理、CGLib等ByteCode框架、动态生成JSP以及OSGi这类频繁自定义ClassLoader的场景都需要虚拟机具备类卸载的功能，以保证永久代不会溢出。</p>\n<h1 id=\"垃圾收集算法\"><a href=\"#垃圾收集算法\" class=\"headerlink\" title=\"垃圾收集算法\"></a>垃圾收集算法</h1><h2 id=\"标记-清除算法\"><a href=\"#标记-清除算法\" class=\"headerlink\" title=\"标记-清除算法\"></a>标记-清除算法</h2><p>算法分为“标记”和“清除”两个阶段：首先标记处所有需要回收的对象，在标记完成后统一回收所有被标记的对象。主要不足有2处：一个是效率问题，标记和清除两个过程效率都不高；另一个是空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能导致以后程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前出发另一次垃圾收集动作。</p>\n<h2 id=\"复制算法\"><a href=\"#复制算法\" class=\"headerlink\" title=\"复制算法\"></a>复制算法</h2><p>为了解决效率问题，复制收集算法出现了。它将可用内存按容量分为大小相等的两块，每次只使用其中一块。当这一块内存用完了，就将还存活着的对象复制到另一块上面，然后再把已经使用过的内存空间一次清理掉。</p>\n<p>现在的商业虚拟机都采用这种收集算法来回收新生代，IBM公司专门研究表明，新生代的对象95%是“朝生夕死”的，所以并不需要1:1的比例来划分内存空间，而是将内存分为一块较大的Eden空间和两块较小的Survior空间，每次使用Eden和其中一块Survior。当回收时，将Eden和Survior中还存活着的对象一次性地复制到另一块Survior空间上，最后清理掉Eden和刚才用过的Survior空间。HotSpot默认Eden和Survior的大小比例是8:1，也就是每次新生代中可用内存空间为整个新生代容量的90%（80%+10%）。我们没有办法保证每次回收都只有不多于10%的对象存活，当Survior空间不够用时，需要依赖其他内存（这里指老年代）进行分配担保。</p>\n<p>如果另外一块Survior空间没有足够空间存放上一次新生代收集下来的存活对象时，这些对象将直接通过分配担保机制进入老年代。</p>\n<h2 id=\"标记-整理算法\"><a href=\"#标记-整理算法\" class=\"headerlink\" title=\"标记-整理算法\"></a>标记-整理算法</h2><p>复制收集算法在对象存活率较高时就要进行较多的复制操作，效率将会变低。根据老年代的特点，有人提出了“标记-整理”算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。</p>\n<h2 id=\"分代收集算法\"><a href=\"#分代收集算法\" class=\"headerlink\" title=\"分代收集算法\"></a>分代收集算法</h2><p>当前商业虚拟机的垃圾手机都采用“分代收集”算法，一般把Java堆分为新生代和老年代。新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记-清理”或者“标记-整理”算法来进行回收。</p>\n","excerpt":"","more":"<h1 id=\"引用计数算法\"><a href=\"#引用计数算法\" class=\"headerlink\" title=\"引用计数算法\"></a>引用计数算法</h1><p>给对象添加引用计数器，每增加一个地方引用时，计数器加1，引用失效时，计数器减1。</p>\n<p>主流的JVM里面并没有选用引用计数法来管理内存，原因是它很难解决对象之间相互循环引用的问题。<br>微软的COM技术、使用ActionScript的FlashPlayer、Python语言和游戏脚本领域被广泛应用的Squirrel中都使用了引用计数法管理内存。</p>\n<h1 id=\"可达性分析算法\"><a href=\"#可达性分析算法\" class=\"headerlink\" title=\"可达性分析算法\"></a>可达性分析算法</h1><p>通过一系列称为”GC Roots”的对象作为起始点，从这些节点向下搜索，搜索走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连时，则证明对象不可用。<br>在Java语言中，可作为GC Roots对象包括下面几种：  </p>\n<ul>\n<li>虚拟机栈（栈帧中的本地变量表）中引用的对象。  </li>\n<li>方法区中类静态属性引用的对象。  </li>\n<li>方法区中常量引用的对象。  </li>\n<li>本地方法栈中JNI（Native方法）引用的对象。</li>\n</ul>\n<h1 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h1><p>JDK1.2后，Java对引用概念进行扩充，将引用分为强引用、软引用、弱引用、虚引用4种。  </p>\n<ul>\n<li>强引用是指在程序代码中普遍存在的，类似“Object object = new Object()”这类的引用，只要强引用存在，垃圾收集器永远不会回收被引用的对象。  </li>\n<li>软引用用来描述一些还有用但并非必须的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收还没有足够内存，才会抛出内存溢出异常。JDK1.2后，提供SoftReference类实现软引用。  </li>\n<li>弱引用也是描述非必须对象，它的强度较软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉被弱引用关联的对象。JDK1.2后，提供WeakReference类实现弱引用。  </li>\n<li>虚引用也称为幽灵引用或幻影引用，是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。JDK1.2后，提供PhantomReference类实现虚引用。</li>\n</ul>\n<h1 id=\"回收方法区\"><a href=\"#回收方法区\" class=\"headerlink\" title=\"回收方法区\"></a>回收方法区</h1><p>JVM规范中说过可以不要求虚拟机在方法区实现垃圾收集，而且在方法区中进行垃圾收集的“性价比”一般比较低：在堆中，尤其在新生代中，常规应用进行一次垃圾收集一般可以回收70%-95%的空间，而永久代的垃圾搜集效率远低于此。<br>永久代的垃圾收集主要回收两部分内容：废弃常量和无用的类。<br>判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用的类”的条件则相对苛刻许多。类要同时满足下面3个条件才能算是“无用的类”：  </p>\n<ol>\n<li>该类所有的实例都已经被回收，也就是说Java堆中不存在该类的任何实例。</li>\n<li>加载该类的ClassLoader已经被回收。  </li>\n<li>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。  </li>\n</ol>\n<p>JVM可以对满足上述3各条件的无用类进行回收，这里说的是“可以”，并不是和对象一样，不使用了必然回收。是否对类进行回收，HotSpot虚拟机提供了 -Xnoclassgc 参数进行控制，还可以使用 -verbose:class 以及 -XX:+TraceClassLoading、 -XX:+TraceClassUnLaoding查看类加载和卸载信息，其中 -verboss:class 和 -XX:+TraceClassLoading 可以在Product版的虚拟机中使用。 -XX:+TraceClassUnLoading参数需要FastDebug版的虚拟机支持。<br>在大量使用反射、动态代理、CGLib等ByteCode框架、动态生成JSP以及OSGi这类频繁自定义ClassLoader的场景都需要虚拟机具备类卸载的功能，以保证永久代不会溢出。</p>\n<h1 id=\"垃圾收集算法\"><a href=\"#垃圾收集算法\" class=\"headerlink\" title=\"垃圾收集算法\"></a>垃圾收集算法</h1><h2 id=\"标记-清除算法\"><a href=\"#标记-清除算法\" class=\"headerlink\" title=\"标记-清除算法\"></a>标记-清除算法</h2><p>算法分为“标记”和“清除”两个阶段：首先标记处所有需要回收的对象，在标记完成后统一回收所有被标记的对象。主要不足有2处：一个是效率问题，标记和清除两个过程效率都不高；另一个是空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能导致以后程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前出发另一次垃圾收集动作。</p>\n<h2 id=\"复制算法\"><a href=\"#复制算法\" class=\"headerlink\" title=\"复制算法\"></a>复制算法</h2><p>为了解决效率问题，复制收集算法出现了。它将可用内存按容量分为大小相等的两块，每次只使用其中一块。当这一块内存用完了，就将还存活着的对象复制到另一块上面，然后再把已经使用过的内存空间一次清理掉。</p>\n<p>现在的商业虚拟机都采用这种收集算法来回收新生代，IBM公司专门研究表明，新生代的对象95%是“朝生夕死”的，所以并不需要1:1的比例来划分内存空间，而是将内存分为一块较大的Eden空间和两块较小的Survior空间，每次使用Eden和其中一块Survior。当回收时，将Eden和Survior中还存活着的对象一次性地复制到另一块Survior空间上，最后清理掉Eden和刚才用过的Survior空间。HotSpot默认Eden和Survior的大小比例是8:1，也就是每次新生代中可用内存空间为整个新生代容量的90%（80%+10%）。我们没有办法保证每次回收都只有不多于10%的对象存活，当Survior空间不够用时，需要依赖其他内存（这里指老年代）进行分配担保。</p>\n<p>如果另外一块Survior空间没有足够空间存放上一次新生代收集下来的存活对象时，这些对象将直接通过分配担保机制进入老年代。</p>\n<h2 id=\"标记-整理算法\"><a href=\"#标记-整理算法\" class=\"headerlink\" title=\"标记-整理算法\"></a>标记-整理算法</h2><p>复制收集算法在对象存活率较高时就要进行较多的复制操作，效率将会变低。根据老年代的特点，有人提出了“标记-整理”算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。</p>\n<h2 id=\"分代收集算法\"><a href=\"#分代收集算法\" class=\"headerlink\" title=\"分代收集算法\"></a>分代收集算法</h2><p>当前商业虚拟机的垃圾手机都采用“分代收集”算法，一般把Java堆分为新生代和老年代。新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记-清理”或者“标记-整理”算法来进行回收。</p>\n"},{"title":"Redis跳跃表","date":"2015-06-26T16:00:00.000Z","_content":"\nRedis使用跳跃表作为有序集合键的底层实现之一，如果一个有序集合包含的元素数量较多，或者有序集合中成员是较长的字符串时，Redis就会使用跳跃表来作为有序集合键的底层实现。\n和链表、字典等数据结构在Redis内部的广泛应用不同，Redis只在实现有序集合键和集群节点中用到跳跃表。\n\n跳跃表节点 zskiplistNode\n``` bash\ntypeof struct zskiplistNode {\n\t//层\n\tstruct zskipzlistLevel{\n\t//前进指针\n\tstruct zskiplistNode *forward;\n\t//跨度\n\tunsigned int span;\n\t} level[];\n\t\n\t//后退指针\n\tstruct zskiplistNode *backward;\n\t//分值\n\tdouble score;\n\t//成员对象\n\trojb *obj;\n} zskiplistNode;\n\n```\n\n\n跳跃表 zskiplist\n``` bash\ntypeof struct zskiplist {\n\t//表头节点和表尾节点\n\tstructz skiplistNode *header, *tail;\n\t//表中节点数量\n\tunsigned long length;\n\t//表中层数最大节点的层数\n\tint level;\n} zskiplist;\n```\n","source":"_posts/redis设计与实现/Redis跳跃表.md","raw":"---\ntitle: Redis跳跃表\ndate: 2015-06-27\ncategories: Redis设计与实现\ntags: Redis\n---\n\nRedis使用跳跃表作为有序集合键的底层实现之一，如果一个有序集合包含的元素数量较多，或者有序集合中成员是较长的字符串时，Redis就会使用跳跃表来作为有序集合键的底层实现。\n和链表、字典等数据结构在Redis内部的广泛应用不同，Redis只在实现有序集合键和集群节点中用到跳跃表。\n\n跳跃表节点 zskiplistNode\n``` bash\ntypeof struct zskiplistNode {\n\t//层\n\tstruct zskipzlistLevel{\n\t//前进指针\n\tstruct zskiplistNode *forward;\n\t//跨度\n\tunsigned int span;\n\t} level[];\n\t\n\t//后退指针\n\tstruct zskiplistNode *backward;\n\t//分值\n\tdouble score;\n\t//成员对象\n\trojb *obj;\n} zskiplistNode;\n\n```\n\n\n跳跃表 zskiplist\n``` bash\ntypeof struct zskiplist {\n\t//表头节点和表尾节点\n\tstructz skiplistNode *header, *tail;\n\t//表中节点数量\n\tunsigned long length;\n\t//表中层数最大节点的层数\n\tint level;\n} zskiplist;\n```\n","slug":"redis设计与实现/Redis跳跃表","published":1,"updated":"2019-05-17T05:57:58.577Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1j8f2i300177h9mn12aa2u0","content":"<p>Redis使用跳跃表作为有序集合键的底层实现之一，如果一个有序集合包含的元素数量较多，或者有序集合中成员是较长的字符串时，Redis就会使用跳跃表来作为有序集合键的底层实现。<br>和链表、字典等数据结构在Redis内部的广泛应用不同，Redis只在实现有序集合键和集群节点中用到跳跃表。</p>\n<p>跳跃表节点 zskiplistNode<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typeof struct zskiplistNode &#123;</span><br><span class=\"line\">\t//层</span><br><span class=\"line\">\tstruct zskipzlistLevel&#123;</span><br><span class=\"line\">\t//前进指针</span><br><span class=\"line\">\tstruct zskiplistNode *forward;</span><br><span class=\"line\">\t//跨度</span><br><span class=\"line\">\tunsigned int span;</span><br><span class=\"line\">\t&#125; level[];</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t//后退指针</span><br><span class=\"line\">\tstruct zskiplistNode *backward;</span><br><span class=\"line\">\t//分值</span><br><span class=\"line\">\tdouble score;</span><br><span class=\"line\">\t//成员对象</span><br><span class=\"line\">\trojb *obj;</span><br><span class=\"line\">&#125; zskiplistNode;</span><br></pre></td></tr></table></figure></p>\n<p>跳跃表 zskiplist<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typeof struct zskiplist &#123;</span><br><span class=\"line\">\t//表头节点和表尾节点</span><br><span class=\"line\">\tstructz skiplistNode *header, *tail;</span><br><span class=\"line\">\t//表中节点数量</span><br><span class=\"line\">\tunsigned long length;</span><br><span class=\"line\">\t//表中层数最大节点的层数</span><br><span class=\"line\">\tint level;</span><br><span class=\"line\">&#125; zskiplist;</span><br></pre></td></tr></table></figure></p>\n","excerpt":"","more":"<p>Redis使用跳跃表作为有序集合键的底层实现之一，如果一个有序集合包含的元素数量较多，或者有序集合中成员是较长的字符串时，Redis就会使用跳跃表来作为有序集合键的底层实现。<br>和链表、字典等数据结构在Redis内部的广泛应用不同，Redis只在实现有序集合键和集群节点中用到跳跃表。</p>\n<p>跳跃表节点 zskiplistNode<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typeof struct zskiplistNode &#123;</span><br><span class=\"line\">\t//层</span><br><span class=\"line\">\tstruct zskipzlistLevel&#123;</span><br><span class=\"line\">\t//前进指针</span><br><span class=\"line\">\tstruct zskiplistNode *forward;</span><br><span class=\"line\">\t//跨度</span><br><span class=\"line\">\tunsigned int span;</span><br><span class=\"line\">\t&#125; level[];</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t//后退指针</span><br><span class=\"line\">\tstruct zskiplistNode *backward;</span><br><span class=\"line\">\t//分值</span><br><span class=\"line\">\tdouble score;</span><br><span class=\"line\">\t//成员对象</span><br><span class=\"line\">\trojb *obj;</span><br><span class=\"line\">&#125; zskiplistNode;</span><br></pre></td></tr></table></figure></p>\n<p>跳跃表 zskiplist<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typeof struct zskiplist &#123;</span><br><span class=\"line\">\t//表头节点和表尾节点</span><br><span class=\"line\">\tstructz skiplistNode *header, *tail;</span><br><span class=\"line\">\t//表中节点数量</span><br><span class=\"line\">\tunsigned long length;</span><br><span class=\"line\">\t//表中层数最大节点的层数</span><br><span class=\"line\">\tint level;</span><br><span class=\"line\">&#125; zskiplist;</span><br></pre></td></tr></table></figure></p>\n"},{"title":"基本类型","date":"2016-08-08T16:00:00.000Z","_content":"\n*\t[用偶判断，不用奇判断](#用偶判断，不用奇判断)\n*\t[用整型处理货币](#用整型处理货币)\n* \t[不要让类型默默转换](#不要让类型默默转换)\n*  \t[边界](#边界)\n\n###\t用偶判断，不用奇判断\n\n这是判断奇偶数的代码，能被2整除就是偶数，否则是奇数。\n\n```Java\n    public static void main(String[] args) {\n        Scanner input = new Scanner(System.in);\n        System.out.println(\"输入数字判断奇偶\");\n        while (input.hasNextInt()) {\n            int i = input.nextInt();\n            String str = i + \" --> \" + (i % 2 == 1 ? \"奇数\" : \"偶数\");\n            System.out.println(str);\n        }\n    }\n```\n\n我们看下运行结果：\n\n```\n输入数字判断奇偶\n1\n1 --> 奇数\n-1\n-1 --> 偶数\n2\n2 --> 偶数\n-2\n-2 --> 偶数\n-3\n-3 --> 偶数\n```\n\n-1被认作偶数了，O.M.G，Java真菜。慢着，看下Java取余的代码：\n\n```Java\n\t//模拟取余，divident 被除数，divisor 除数\n    public static int remainder(int dividend, int divisor) {\n        return dividend - dividend / divisor * divisor;\n    }\n```\n\n输入-1的时候，运算结果是-1，所以被判定为偶数。so，把判断修改成判断偶数即可：\n\n```java\ni % 2 == 0 ? \"偶数\" : \"奇数\"\n```\n\n---\n###\t用整型处理货币\n\n```Java\npublic class T {\n\n    public static void main(String[] args) {\n        System.out.println(10.00 - 9.60);\n    }\n}\n\n```\n\n期望结果是0.4，但打印出来的却是0.40000000000000036。\n\n在计算机浮点数可能不准确，只能无限接近准确值。这是由浮点数的存储规则决定的，0.4不能用二进制准确的表示，在二进制数世界中它是一个无限循环的小数。\n\n解决办法：\t\n1.\tBigDecimal\t\n2. \t使用整型\n\n---\n###\t不要让类型默默转换\n\n光速每秒30万公里，根据光速计算距离，月光照射到地球需1s，阳光照射到地球需8m。\n\n```Java\npublic class Sample3 {\n\n    public static final int LIGHT_SPEED = 30 * 10000 * 1000;\n\n    public static void main(String[] args) {\n        long dis1 = LIGHT_SPEED * 1;\n\n        System.out.println(\"光1秒的距离:\" + dis1);\n\n        long dis2 = LIGHT_SPEED * 60 * 8;\n\n        System.out.println(\"光8分钟的距离:\" + dis2);\n    }\n}\n```\n\n输出结果\n\n```\n光1秒的距离:300000000\n光8分钟的距离:-2028888064\n```\n\nJava是先运算再进行类型转换，dis2的三个运算参数都是int类型，结果也是int类型，已经超越int最大值，变成负值，转换成long型仍是负值。\n\n解决办法：\n\n```Java\nlong dis2 = LIGHT_SPEED * 60 * 8l;\n```\n\n```Java\nLong dis2 = LIGHT_SPEED * 60 * 8L;\n```\n---\n\n###\t边界\n\n产品预定场景，cur表示当前会员已拥有产品数，LIMIT是最多拥有预定数。\n\n```Java\npublic class Sample4 {\n\n    public final static int LIMIT = 2000;\n\n    public static void main(String[] args) {\n        int cur = 1000;\n        Scanner input = new Scanner(System.in);\n        System.out.println(\"请输入需要预定的数量:\");\n        while (input.hasNextInt()) {\n            int order = input.nextInt();\n            if (order > 0 && order + cur <= LIMIT) {\n                System.out.println(\"成功预定:\" + order + \"个产品\");\n            } else {\n                System.out.println(\"超额，预定失败\");\n            }\n        }\n    }\n}\n```\n\n输出结果\n\n```\n请输入需要预定的数量:\n800\n成功预定:800个产品\n2147483647\n成功预定:2147483647个产品\n\n```","source":"_posts/编写高质量代码/基本类型.md","raw":"---\ntitle: 基本类型\ndate: 2016-08-09\ncategories: 编写高质量代码\ntags: \n- Java\n---\n\n*\t[用偶判断，不用奇判断](#用偶判断，不用奇判断)\n*\t[用整型处理货币](#用整型处理货币)\n* \t[不要让类型默默转换](#不要让类型默默转换)\n*  \t[边界](#边界)\n\n###\t用偶判断，不用奇判断\n\n这是判断奇偶数的代码，能被2整除就是偶数，否则是奇数。\n\n```Java\n    public static void main(String[] args) {\n        Scanner input = new Scanner(System.in);\n        System.out.println(\"输入数字判断奇偶\");\n        while (input.hasNextInt()) {\n            int i = input.nextInt();\n            String str = i + \" --> \" + (i % 2 == 1 ? \"奇数\" : \"偶数\");\n            System.out.println(str);\n        }\n    }\n```\n\n我们看下运行结果：\n\n```\n输入数字判断奇偶\n1\n1 --> 奇数\n-1\n-1 --> 偶数\n2\n2 --> 偶数\n-2\n-2 --> 偶数\n-3\n-3 --> 偶数\n```\n\n-1被认作偶数了，O.M.G，Java真菜。慢着，看下Java取余的代码：\n\n```Java\n\t//模拟取余，divident 被除数，divisor 除数\n    public static int remainder(int dividend, int divisor) {\n        return dividend - dividend / divisor * divisor;\n    }\n```\n\n输入-1的时候，运算结果是-1，所以被判定为偶数。so，把判断修改成判断偶数即可：\n\n```java\ni % 2 == 0 ? \"偶数\" : \"奇数\"\n```\n\n---\n###\t用整型处理货币\n\n```Java\npublic class T {\n\n    public static void main(String[] args) {\n        System.out.println(10.00 - 9.60);\n    }\n}\n\n```\n\n期望结果是0.4，但打印出来的却是0.40000000000000036。\n\n在计算机浮点数可能不准确，只能无限接近准确值。这是由浮点数的存储规则决定的，0.4不能用二进制准确的表示，在二进制数世界中它是一个无限循环的小数。\n\n解决办法：\t\n1.\tBigDecimal\t\n2. \t使用整型\n\n---\n###\t不要让类型默默转换\n\n光速每秒30万公里，根据光速计算距离，月光照射到地球需1s，阳光照射到地球需8m。\n\n```Java\npublic class Sample3 {\n\n    public static final int LIGHT_SPEED = 30 * 10000 * 1000;\n\n    public static void main(String[] args) {\n        long dis1 = LIGHT_SPEED * 1;\n\n        System.out.println(\"光1秒的距离:\" + dis1);\n\n        long dis2 = LIGHT_SPEED * 60 * 8;\n\n        System.out.println(\"光8分钟的距离:\" + dis2);\n    }\n}\n```\n\n输出结果\n\n```\n光1秒的距离:300000000\n光8分钟的距离:-2028888064\n```\n\nJava是先运算再进行类型转换，dis2的三个运算参数都是int类型，结果也是int类型，已经超越int最大值，变成负值，转换成long型仍是负值。\n\n解决办法：\n\n```Java\nlong dis2 = LIGHT_SPEED * 60 * 8l;\n```\n\n```Java\nLong dis2 = LIGHT_SPEED * 60 * 8L;\n```\n---\n\n###\t边界\n\n产品预定场景，cur表示当前会员已拥有产品数，LIMIT是最多拥有预定数。\n\n```Java\npublic class Sample4 {\n\n    public final static int LIMIT = 2000;\n\n    public static void main(String[] args) {\n        int cur = 1000;\n        Scanner input = new Scanner(System.in);\n        System.out.println(\"请输入需要预定的数量:\");\n        while (input.hasNextInt()) {\n            int order = input.nextInt();\n            if (order > 0 && order + cur <= LIMIT) {\n                System.out.println(\"成功预定:\" + order + \"个产品\");\n            } else {\n                System.out.println(\"超额，预定失败\");\n            }\n        }\n    }\n}\n```\n\n输出结果\n\n```\n请输入需要预定的数量:\n800\n成功预定:800个产品\n2147483647\n成功预定:2147483647个产品\n\n```","slug":"编写高质量代码/基本类型","published":1,"updated":"2019-05-17T05:57:58.585Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1j8f2i400187h9mrthcz6i7","content":"<ul>\n<li><a href=\"#用偶判断，不用奇判断\">用偶判断，不用奇判断</a></li>\n<li><a href=\"#用整型处理货币\">用整型处理货币</a></li>\n<li><a href=\"#不要让类型默默转换\">不要让类型默默转换</a></li>\n<li><a href=\"#边界\">边界</a></li>\n</ul>\n<h3 id=\"用偶判断，不用奇判断\"><a href=\"#用偶判断，不用奇判断\" class=\"headerlink\" title=\"用偶判断，不用奇判断\"></a>用偶判断，不用奇判断</h3><p>这是判断奇偶数的代码，能被2整除就是偶数，否则是奇数。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    Scanner input = <span class=\"keyword\">new</span> Scanner(System.in);</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"输入数字判断奇偶\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (input.hasNextInt()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = input.nextInt();</span><br><span class=\"line\">        String str = i + <span class=\"string\">\" --&gt; \"</span> + (i % <span class=\"number\">2</span> == <span class=\"number\">1</span> ? <span class=\"string\">\"奇数\"</span> : <span class=\"string\">\"偶数\"</span>);</span><br><span class=\"line\">        System.out.println(str);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们看下运行结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入数字判断奇偶</span><br><span class=\"line\">1</span><br><span class=\"line\">1 --&gt; 奇数</span><br><span class=\"line\">-1</span><br><span class=\"line\">-1 --&gt; 偶数</span><br><span class=\"line\">2</span><br><span class=\"line\">2 --&gt; 偶数</span><br><span class=\"line\">-2</span><br><span class=\"line\">-2 --&gt; 偶数</span><br><span class=\"line\">-3</span><br><span class=\"line\">-3 --&gt; 偶数</span><br></pre></td></tr></table></figure>\n<p>-1被认作偶数了，O.M.G，Java真菜。慢着，看下Java取余的代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//模拟取余，divident 被除数，divisor 除数</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">remainder</span><span class=\"params\">(<span class=\"keyword\">int</span> dividend, <span class=\"keyword\">int</span> divisor)</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> dividend - dividend / divisor * divisor;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<p>输入-1的时候，运算结果是-1，所以被判定为偶数。so，把判断修改成判断偶数即可：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">i % <span class=\"number\">2</span> == <span class=\"number\">0</span> ? <span class=\"string\">\"偶数\"</span> : <span class=\"string\">\"奇数\"</span></span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"用整型处理货币\"><a href=\"#用整型处理货币\" class=\"headerlink\" title=\"用整型处理货币\"></a>用整型处理货币</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"number\">10.00</span> - <span class=\"number\">9.60</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>期望结果是0.4，但打印出来的却是0.40000000000000036。</p>\n<p>在计算机浮点数可能不准确，只能无限接近准确值。这是由浮点数的存储规则决定的，0.4不能用二进制准确的表示，在二进制数世界中它是一个无限循环的小数。</p>\n<p>解决办法：    </p>\n<ol>\n<li>BigDecimal    </li>\n<li>使用整型</li>\n</ol>\n<hr>\n<h3 id=\"不要让类型默默转换\"><a href=\"#不要让类型默默转换\" class=\"headerlink\" title=\"不要让类型默默转换\"></a>不要让类型默默转换</h3><p>光速每秒30万公里，根据光速计算距离，月光照射到地球需1s，阳光照射到地球需8m。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sample3</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> LIGHT_SPEED = <span class=\"number\">30</span> * <span class=\"number\">10000</span> * <span class=\"number\">1000</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> dis1 = LIGHT_SPEED * <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"光1秒的距离:\"</span> + dis1);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">long</span> dis2 = LIGHT_SPEED * <span class=\"number\">60</span> * <span class=\"number\">8</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"光8分钟的距离:\"</span> + dis2);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出结果</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">光1秒的距离:300000000</span><br><span class=\"line\">光8分钟的距离:-2028888064</span><br></pre></td></tr></table></figure>\n<p>Java是先运算再进行类型转换，dis2的三个运算参数都是int类型，结果也是int类型，已经超越int最大值，变成负值，转换成long型仍是负值。</p>\n<p>解决办法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">long</span> dis2 = LIGHT_SPEED * <span class=\"number\">60</span> * <span class=\"number\">8l</span>;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Long dis2 = LIGHT_SPEED * <span class=\"number\">60</span> * <span class=\"number\">8L</span>;</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"边界\"><a href=\"#边界\" class=\"headerlink\" title=\"边界\"></a>边界</h3><p>产品预定场景，cur表示当前会员已拥有产品数，LIMIT是最多拥有预定数。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sample4</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> LIMIT = <span class=\"number\">2000</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> cur = <span class=\"number\">1000</span>;</span><br><span class=\"line\">        Scanner input = <span class=\"keyword\">new</span> Scanner(System.in);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"请输入需要预定的数量:\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (input.hasNextInt()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> order = input.nextInt();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (order &gt; <span class=\"number\">0</span> &amp;&amp; order + cur &lt;= LIMIT) &#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">\"成功预定:\"</span> + order + <span class=\"string\">\"个产品\"</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">\"超额，预定失败\"</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出结果</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">请输入需要预定的数量:</span><br><span class=\"line\">800</span><br><span class=\"line\">成功预定:800个产品</span><br><span class=\"line\">2147483647</span><br><span class=\"line\">成功预定:2147483647个产品</span><br></pre></td></tr></table></figure>","excerpt":"","more":"<ul>\n<li><a href=\"#用偶判断，不用奇判断\">用偶判断，不用奇判断</a></li>\n<li><a href=\"#用整型处理货币\">用整型处理货币</a></li>\n<li><a href=\"#不要让类型默默转换\">不要让类型默默转换</a></li>\n<li><a href=\"#边界\">边界</a></li>\n</ul>\n<h3 id=\"用偶判断，不用奇判断\"><a href=\"#用偶判断，不用奇判断\" class=\"headerlink\" title=\"用偶判断，不用奇判断\"></a>用偶判断，不用奇判断</h3><p>这是判断奇偶数的代码，能被2整除就是偶数，否则是奇数。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    Scanner input = <span class=\"keyword\">new</span> Scanner(System.in);</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"输入数字判断奇偶\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (input.hasNextInt()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = input.nextInt();</span><br><span class=\"line\">        String str = i + <span class=\"string\">\" --&gt; \"</span> + (i % <span class=\"number\">2</span> == <span class=\"number\">1</span> ? <span class=\"string\">\"奇数\"</span> : <span class=\"string\">\"偶数\"</span>);</span><br><span class=\"line\">        System.out.println(str);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们看下运行结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入数字判断奇偶</span><br><span class=\"line\">1</span><br><span class=\"line\">1 --&gt; 奇数</span><br><span class=\"line\">-1</span><br><span class=\"line\">-1 --&gt; 偶数</span><br><span class=\"line\">2</span><br><span class=\"line\">2 --&gt; 偶数</span><br><span class=\"line\">-2</span><br><span class=\"line\">-2 --&gt; 偶数</span><br><span class=\"line\">-3</span><br><span class=\"line\">-3 --&gt; 偶数</span><br></pre></td></tr></table></figure>\n<p>-1被认作偶数了，O.M.G，Java真菜。慢着，看下Java取余的代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//模拟取余，divident 被除数，divisor 除数</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">remainder</span><span class=\"params\">(<span class=\"keyword\">int</span> dividend, <span class=\"keyword\">int</span> divisor)</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> dividend - dividend / divisor * divisor;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<p>输入-1的时候，运算结果是-1，所以被判定为偶数。so，把判断修改成判断偶数即可：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">i % <span class=\"number\">2</span> == <span class=\"number\">0</span> ? <span class=\"string\">\"偶数\"</span> : <span class=\"string\">\"奇数\"</span></span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"用整型处理货币\"><a href=\"#用整型处理货币\" class=\"headerlink\" title=\"用整型处理货币\"></a>用整型处理货币</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"number\">10.00</span> - <span class=\"number\">9.60</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>期望结果是0.4，但打印出来的却是0.40000000000000036。</p>\n<p>在计算机浮点数可能不准确，只能无限接近准确值。这是由浮点数的存储规则决定的，0.4不能用二进制准确的表示，在二进制数世界中它是一个无限循环的小数。</p>\n<p>解决办法：    </p>\n<ol>\n<li>BigDecimal    </li>\n<li>使用整型</li>\n</ol>\n<hr>\n<h3 id=\"不要让类型默默转换\"><a href=\"#不要让类型默默转换\" class=\"headerlink\" title=\"不要让类型默默转换\"></a>不要让类型默默转换</h3><p>光速每秒30万公里，根据光速计算距离，月光照射到地球需1s，阳光照射到地球需8m。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sample3</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> LIGHT_SPEED = <span class=\"number\">30</span> * <span class=\"number\">10000</span> * <span class=\"number\">1000</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> dis1 = LIGHT_SPEED * <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"光1秒的距离:\"</span> + dis1);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">long</span> dis2 = LIGHT_SPEED * <span class=\"number\">60</span> * <span class=\"number\">8</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"光8分钟的距离:\"</span> + dis2);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出结果</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">光1秒的距离:300000000</span><br><span class=\"line\">光8分钟的距离:-2028888064</span><br></pre></td></tr></table></figure>\n<p>Java是先运算再进行类型转换，dis2的三个运算参数都是int类型，结果也是int类型，已经超越int最大值，变成负值，转换成long型仍是负值。</p>\n<p>解决办法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">long</span> dis2 = LIGHT_SPEED * <span class=\"number\">60</span> * <span class=\"number\">8l</span>;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Long dis2 = LIGHT_SPEED * <span class=\"number\">60</span> * <span class=\"number\">8L</span>;</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"边界\"><a href=\"#边界\" class=\"headerlink\" title=\"边界\"></a>边界</h3><p>产品预定场景，cur表示当前会员已拥有产品数，LIMIT是最多拥有预定数。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sample4</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> LIMIT = <span class=\"number\">2000</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> cur = <span class=\"number\">1000</span>;</span><br><span class=\"line\">        Scanner input = <span class=\"keyword\">new</span> Scanner(System.in);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"请输入需要预定的数量:\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (input.hasNextInt()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> order = input.nextInt();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (order &gt; <span class=\"number\">0</span> &amp;&amp; order + cur &lt;= LIMIT) &#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">\"成功预定:\"</span> + order + <span class=\"string\">\"个产品\"</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">\"超额，预定失败\"</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出结果</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">请输入需要预定的数量:</span><br><span class=\"line\">800</span><br><span class=\"line\">成功预定:800个产品</span><br><span class=\"line\">2147483647</span><br><span class=\"line\">成功预定:2147483647个产品</span><br></pre></td></tr></table></figure>"},{"title":"字符串","date":"2017-06-02T16:00:00.000Z","_content":"\n*\t[字符串拼接方法](#字符串拼接方法)\n\n### 字符串拼接方法\n\n对一个字符串进行拼接有三种方法：加号、concat 及 StringBuilder （或 StringBuffer）的 append 方法，这三者之间有什么区别吗？\n\n```Java\nstr += “c”;\nstr = str.concat(\"c\");\n```\n\n上面两种不同字符串拼接方式、循环5万次后检查执行时间，加号方式执行时间为 2000ms，而 concat 方法执行时间为 685ms，时间相差一倍，如果使用 StringBuilder，执行时间 7ms。从这个试验中可以看出 append 方法最快，concat 其次，加号最慢。\n\n##### 加号方法\n\n编译器对字符串的加号做了优化，它会使用 StringBuilder 的 append 方法追加，讲道理它的执行时间也应该在 10ms 以内，不过它最终是通过 toString 方法转换成 String 字符串的，例子中的代码与如下代码相同：\n\n```Java\n  str = new StringBuilder(str).append(\"c\").toString();\n```\n\n这与纯粹使用 StringBuilder 的 append 方法是不同的：\n\n1.  每次循环都会创建一个 StringBuilder 对象\n2.  每次执行完毕都要调用 toString 方法将其转换为字符串\n\n##### concat 方法\n\n我们看一下 concat 源码实现：\n\n```Java\npublic String concat(String str) {\n        int otherLen = str.length();\n        if (otherLen == 0) {\n            return this;\n        }\n        int len = value.length;\n        char buf[] = Arrays.copyOf(value, len + otherLen);\n        str.getChars(buf, len);\n        return new String(buf, true);\n}\n```\n\n整体看上去是一个数组拷贝，虽然在内存中处理都是原子性操作，速度非常快。不过最后的 return 语句，每次 concat 操作都会新创建一个 String 对象，这就是 concat 速度慢下来的真正原因。\n\n#####\tappend 方法\n\nStringBuilder 的 append 方法直接由父类 AbstractStringBuilder 实现，代码如下：\n\n```Java\npublic AbstractStringBuilder append(String str) {\n    if (str == null)\n        return appendNull();\n    int len = str.length();\n    ensureCapacityInternal(count + len);\n    str.getChars(0, len, value, count);\n    count += len;\n    return this;\n}\n```\n\n整个 append 方法都在做字符数组处理，加上后数组拷贝，这些都是基本的数据处理，没有新建任何对象，所以速度也就最快了。\n","source":"_posts/编写高质量代码/字符串.md","raw":"---\ntitle: 字符串\ndate: 2017-06-03\ncategories: 编写高质量代码\ntags:\n- Java\n---\n\n*\t[字符串拼接方法](#字符串拼接方法)\n\n### 字符串拼接方法\n\n对一个字符串进行拼接有三种方法：加号、concat 及 StringBuilder （或 StringBuffer）的 append 方法，这三者之间有什么区别吗？\n\n```Java\nstr += “c”;\nstr = str.concat(\"c\");\n```\n\n上面两种不同字符串拼接方式、循环5万次后检查执行时间，加号方式执行时间为 2000ms，而 concat 方法执行时间为 685ms，时间相差一倍，如果使用 StringBuilder，执行时间 7ms。从这个试验中可以看出 append 方法最快，concat 其次，加号最慢。\n\n##### 加号方法\n\n编译器对字符串的加号做了优化，它会使用 StringBuilder 的 append 方法追加，讲道理它的执行时间也应该在 10ms 以内，不过它最终是通过 toString 方法转换成 String 字符串的，例子中的代码与如下代码相同：\n\n```Java\n  str = new StringBuilder(str).append(\"c\").toString();\n```\n\n这与纯粹使用 StringBuilder 的 append 方法是不同的：\n\n1.  每次循环都会创建一个 StringBuilder 对象\n2.  每次执行完毕都要调用 toString 方法将其转换为字符串\n\n##### concat 方法\n\n我们看一下 concat 源码实现：\n\n```Java\npublic String concat(String str) {\n        int otherLen = str.length();\n        if (otherLen == 0) {\n            return this;\n        }\n        int len = value.length;\n        char buf[] = Arrays.copyOf(value, len + otherLen);\n        str.getChars(buf, len);\n        return new String(buf, true);\n}\n```\n\n整体看上去是一个数组拷贝，虽然在内存中处理都是原子性操作，速度非常快。不过最后的 return 语句，每次 concat 操作都会新创建一个 String 对象，这就是 concat 速度慢下来的真正原因。\n\n#####\tappend 方法\n\nStringBuilder 的 append 方法直接由父类 AbstractStringBuilder 实现，代码如下：\n\n```Java\npublic AbstractStringBuilder append(String str) {\n    if (str == null)\n        return appendNull();\n    int len = str.length();\n    ensureCapacityInternal(count + len);\n    str.getChars(0, len, value, count);\n    count += len;\n    return this;\n}\n```\n\n整个 append 方法都在做字符数组处理，加上后数组拷贝，这些都是基本的数据处理，没有新建任何对象，所以速度也就最快了。\n","slug":"编写高质量代码/字符串","published":1,"updated":"2019-05-17T05:57:58.585Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1j8f2i500197h9me5krusu9","content":"<ul>\n<li><a href=\"#字符串拼接方法\">字符串拼接方法</a></li>\n</ul>\n<h3 id=\"字符串拼接方法\"><a href=\"#字符串拼接方法\" class=\"headerlink\" title=\"字符串拼接方法\"></a>字符串拼接方法</h3><p>对一个字符串进行拼接有三种方法：加号、concat 及 StringBuilder （或 StringBuffer）的 append 方法，这三者之间有什么区别吗？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">str += “c”;</span><br><span class=\"line\">str = str.concat(<span class=\"string\">\"c\"</span>);</span><br></pre></td></tr></table></figure>\n<p>上面两种不同字符串拼接方式、循环5万次后检查执行时间，加号方式执行时间为 2000ms，而 concat 方法执行时间为 685ms，时间相差一倍，如果使用 StringBuilder，执行时间 7ms。从这个试验中可以看出 append 方法最快，concat 其次，加号最慢。</p>\n<h5 id=\"加号方法\"><a href=\"#加号方法\" class=\"headerlink\" title=\"加号方法\"></a>加号方法</h5><p>编译器对字符串的加号做了优化，它会使用 StringBuilder 的 append 方法追加，讲道理它的执行时间也应该在 10ms 以内，不过它最终是通过 toString 方法转换成 String 字符串的，例子中的代码与如下代码相同：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">str = <span class=\"keyword\">new</span> StringBuilder(str).append(<span class=\"string\">\"c\"</span>).toString();</span><br></pre></td></tr></table></figure>\n<p>这与纯粹使用 StringBuilder 的 append 方法是不同的：</p>\n<ol>\n<li>每次循环都会创建一个 StringBuilder 对象</li>\n<li>每次执行完毕都要调用 toString 方法将其转换为字符串</li>\n</ol>\n<h5 id=\"concat-方法\"><a href=\"#concat-方法\" class=\"headerlink\" title=\"concat 方法\"></a>concat 方法</h5><p>我们看一下 concat 源码实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">concat</span><span class=\"params\">(String str)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> otherLen = str.length();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (otherLen == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> len = value.length;</span><br><span class=\"line\">        <span class=\"keyword\">char</span> buf[] = Arrays.copyOf(value, len + otherLen);</span><br><span class=\"line\">        str.getChars(buf, len);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> String(buf, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>整体看上去是一个数组拷贝，虽然在内存中处理都是原子性操作，速度非常快。不过最后的 return 语句，每次 concat 操作都会新创建一个 String 对象，这就是 concat 速度慢下来的真正原因。</p>\n<h5 id=\"append-方法\"><a href=\"#append-方法\" class=\"headerlink\" title=\"append 方法\"></a>append 方法</h5><p>StringBuilder 的 append 方法直接由父类 AbstractStringBuilder 实现，代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> AbstractStringBuilder <span class=\"title\">append</span><span class=\"params\">(String str)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (str == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> appendNull();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> len = str.length();</span><br><span class=\"line\">    ensureCapacityInternal(count + len);</span><br><span class=\"line\">    str.getChars(<span class=\"number\">0</span>, len, value, count);</span><br><span class=\"line\">    count += len;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>整个 append 方法都在做字符数组处理，加上后数组拷贝，这些都是基本的数据处理，没有新建任何对象，所以速度也就最快了。</p>\n","excerpt":"","more":"<ul>\n<li><a href=\"#字符串拼接方法\">字符串拼接方法</a></li>\n</ul>\n<h3 id=\"字符串拼接方法\"><a href=\"#字符串拼接方法\" class=\"headerlink\" title=\"字符串拼接方法\"></a>字符串拼接方法</h3><p>对一个字符串进行拼接有三种方法：加号、concat 及 StringBuilder （或 StringBuffer）的 append 方法，这三者之间有什么区别吗？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">str += “c”;</span><br><span class=\"line\">str = str.concat(<span class=\"string\">\"c\"</span>);</span><br></pre></td></tr></table></figure>\n<p>上面两种不同字符串拼接方式、循环5万次后检查执行时间，加号方式执行时间为 2000ms，而 concat 方法执行时间为 685ms，时间相差一倍，如果使用 StringBuilder，执行时间 7ms。从这个试验中可以看出 append 方法最快，concat 其次，加号最慢。</p>\n<h5 id=\"加号方法\"><a href=\"#加号方法\" class=\"headerlink\" title=\"加号方法\"></a>加号方法</h5><p>编译器对字符串的加号做了优化，它会使用 StringBuilder 的 append 方法追加，讲道理它的执行时间也应该在 10ms 以内，不过它最终是通过 toString 方法转换成 String 字符串的，例子中的代码与如下代码相同：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">str = <span class=\"keyword\">new</span> StringBuilder(str).append(<span class=\"string\">\"c\"</span>).toString();</span><br></pre></td></tr></table></figure>\n<p>这与纯粹使用 StringBuilder 的 append 方法是不同的：</p>\n<ol>\n<li>每次循环都会创建一个 StringBuilder 对象</li>\n<li>每次执行完毕都要调用 toString 方法将其转换为字符串</li>\n</ol>\n<h5 id=\"concat-方法\"><a href=\"#concat-方法\" class=\"headerlink\" title=\"concat 方法\"></a>concat 方法</h5><p>我们看一下 concat 源码实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">concat</span><span class=\"params\">(String str)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> otherLen = str.length();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (otherLen == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> len = value.length;</span><br><span class=\"line\">        <span class=\"keyword\">char</span> buf[] = Arrays.copyOf(value, len + otherLen);</span><br><span class=\"line\">        str.getChars(buf, len);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> String(buf, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>整体看上去是一个数组拷贝，虽然在内存中处理都是原子性操作，速度非常快。不过最后的 return 语句，每次 concat 操作都会新创建一个 String 对象，这就是 concat 速度慢下来的真正原因。</p>\n<h5 id=\"append-方法\"><a href=\"#append-方法\" class=\"headerlink\" title=\"append 方法\"></a>append 方法</h5><p>StringBuilder 的 append 方法直接由父类 AbstractStringBuilder 实现，代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> AbstractStringBuilder <span class=\"title\">append</span><span class=\"params\">(String str)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (str == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> appendNull();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> len = str.length();</span><br><span class=\"line\">    ensureCapacityInternal(count + len);</span><br><span class=\"line\">    str.getChars(<span class=\"number\">0</span>, len, value, count);</span><br><span class=\"line\">    count += len;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>整个 append 方法都在做字符数组处理，加上后数组拷贝，这些都是基本的数据处理，没有新建任何对象，所以速度也就最快了。</p>\n"},{"title":"工程质量","date":"2017-06-11T16:00:00.000Z","_content":"\n#\t开源工具的选择\n\n* 普适性原则\n\n  确保大部分项目成员对工具都比较熟悉。\n\n* 唯一性原则\n\n  相同的工具只选择一个或一种，不让多种相同或相似职能的工具共存。例如集合工具 Apache Commons 的 collections 包和 Google Guava 的 collections 工具包，在开发前就应该确认下来，不能让两者共存。\n\n* “大树纳凉”\n\n  选择比较有名的开源组织，比如 Apache、Spring、Google 等。这些开源组织一则具有固定的开发运作风格，二则具有广阔的使用人群。\n\n* 精而专\n\n  我们选择的工具包应该是精而专的，而不是广而多。比如 Spring 框架提供了 Utils 工具包，但在一般情况下不要使用它，因为它不专，Utils 包只是 Spring 中的一个附加功能而已，要用就用 Apache Commons 的 BeanUtils、Long 等工具包。\n\n* 高热度\n\n  热度越高，更新越频繁，使用人群越光，BUG 曝光率越快，修复效率越高，对醒目的稳定性越好。\n\n# 良好的代码风格\n\n* 整洁、统一、流行\n\n  推荐 Google 的 Java 编码规范，《代码整洁之道》。\n\n  1.  好的变量命名，类的命名，方法命名。比如 Spring 源码里面命名老长老长的，但很好懂。\n  2.  方法入参超过 3 个就该考虑封装成对象。\n\n\n* 便捷\n\n  推荐 IDE code format。\n\n# 错误的编码习惯\n\n1.  自由格式的代码\n\n  不同项目，甚至同一个项目不同开发人员的风格也不同。\n\n2.  不使用抽象的代码\n\n  抽象的意义不在于编码，而是在于对业务的理解，接口是对业务宏观的描述，而不是实现代码。\n\n3.  彰显个性的代码\n\n  新技术只能作为技术的一个方向，不适合立刻投入生产中。项目的运行质量远远高于代码质量。“最小惊诧原则”，意思是说使用最常见的，而不是最新颖的功能。编码时，应寻找最常用的方法来实现。\n\n4.  死代码\n\n  可能是忘记删除的代码，也可能是故意保留的类似“到此一游”的签名代码，这些代码按照正常的执行逻辑不可能被执行到。\n\n5.  冗余代码\n\n  写了一个实现类，N 天后被废弃了，之后这个类就永久的保留下去了，没人知道它为什么没被删除掉。\n\n6.  自以为是的代码\n\n  相信自己编写的工具类，而不是开源工具。宁愿自己写序列化工具，也不选择 kryo 或 protostuff；宁愿自己写日期处理工具，也不选择 Joda 或 date4j。\n\n# 技术自律\n\n1.  熟悉工具\n\n  常见工具类，例如 Apache Common， Google Guava。\n\n2.  坚持重构\n\n  不要相信一次就能写出优秀的代码，这不现实，任何优秀的代码、算法都是经过多次重构磨炼的。\n\n3.  多写文档\n\n  不仅仅是为了后续的参与人员，同时也为了整理自己的思维。\n\n4.  保持程序简单\n\n  一个项目不要保持多个版本，即使有分支也必须定义出项目合并的条件，或时间约束或目标约束，不可任由版本扩散。\n\n5.  不重复造轮子\n\n  在项目中使用已经成熟的工具或框架，而不是自己编写。但如果想共享一个新的框架，尽管去重复发明轮子，它不是以交付为目的，耳塞以技术研究为目的。\n\n6.  “剽窃”不可耻\n\n  多看开源代码，学习一下人家的编码方式。\n\n7.  分享\n\n  把自己的代码分享出去收获的不仅仅是赞许，还有自己能力的提升。\n\n8.  刨根问底\n\n  ”哦，这个问题加上这个参数就可以解决了”----这不是解决问题的办法，在答案之后加上“是因为。。。”，这才是解决了问题。\n","source":"_posts/编写高质量代码/工程质量.md","raw":"---\ntitle: 工程质量\ndate: 2017-06-12\ncategories: 编写高质量代码\ntags:\n- Java\n---\n\n#\t开源工具的选择\n\n* 普适性原则\n\n  确保大部分项目成员对工具都比较熟悉。\n\n* 唯一性原则\n\n  相同的工具只选择一个或一种，不让多种相同或相似职能的工具共存。例如集合工具 Apache Commons 的 collections 包和 Google Guava 的 collections 工具包，在开发前就应该确认下来，不能让两者共存。\n\n* “大树纳凉”\n\n  选择比较有名的开源组织，比如 Apache、Spring、Google 等。这些开源组织一则具有固定的开发运作风格，二则具有广阔的使用人群。\n\n* 精而专\n\n  我们选择的工具包应该是精而专的，而不是广而多。比如 Spring 框架提供了 Utils 工具包，但在一般情况下不要使用它，因为它不专，Utils 包只是 Spring 中的一个附加功能而已，要用就用 Apache Commons 的 BeanUtils、Long 等工具包。\n\n* 高热度\n\n  热度越高，更新越频繁，使用人群越光，BUG 曝光率越快，修复效率越高，对醒目的稳定性越好。\n\n# 良好的代码风格\n\n* 整洁、统一、流行\n\n  推荐 Google 的 Java 编码规范，《代码整洁之道》。\n\n  1.  好的变量命名，类的命名，方法命名。比如 Spring 源码里面命名老长老长的，但很好懂。\n  2.  方法入参超过 3 个就该考虑封装成对象。\n\n\n* 便捷\n\n  推荐 IDE code format。\n\n# 错误的编码习惯\n\n1.  自由格式的代码\n\n  不同项目，甚至同一个项目不同开发人员的风格也不同。\n\n2.  不使用抽象的代码\n\n  抽象的意义不在于编码，而是在于对业务的理解，接口是对业务宏观的描述，而不是实现代码。\n\n3.  彰显个性的代码\n\n  新技术只能作为技术的一个方向，不适合立刻投入生产中。项目的运行质量远远高于代码质量。“最小惊诧原则”，意思是说使用最常见的，而不是最新颖的功能。编码时，应寻找最常用的方法来实现。\n\n4.  死代码\n\n  可能是忘记删除的代码，也可能是故意保留的类似“到此一游”的签名代码，这些代码按照正常的执行逻辑不可能被执行到。\n\n5.  冗余代码\n\n  写了一个实现类，N 天后被废弃了，之后这个类就永久的保留下去了，没人知道它为什么没被删除掉。\n\n6.  自以为是的代码\n\n  相信自己编写的工具类，而不是开源工具。宁愿自己写序列化工具，也不选择 kryo 或 protostuff；宁愿自己写日期处理工具，也不选择 Joda 或 date4j。\n\n# 技术自律\n\n1.  熟悉工具\n\n  常见工具类，例如 Apache Common， Google Guava。\n\n2.  坚持重构\n\n  不要相信一次就能写出优秀的代码，这不现实，任何优秀的代码、算法都是经过多次重构磨炼的。\n\n3.  多写文档\n\n  不仅仅是为了后续的参与人员，同时也为了整理自己的思维。\n\n4.  保持程序简单\n\n  一个项目不要保持多个版本，即使有分支也必须定义出项目合并的条件，或时间约束或目标约束，不可任由版本扩散。\n\n5.  不重复造轮子\n\n  在项目中使用已经成熟的工具或框架，而不是自己编写。但如果想共享一个新的框架，尽管去重复发明轮子，它不是以交付为目的，耳塞以技术研究为目的。\n\n6.  “剽窃”不可耻\n\n  多看开源代码，学习一下人家的编码方式。\n\n7.  分享\n\n  把自己的代码分享出去收获的不仅仅是赞许，还有自己能力的提升。\n\n8.  刨根问底\n\n  ”哦，这个问题加上这个参数就可以解决了”----这不是解决问题的办法，在答案之后加上“是因为。。。”，这才是解决了问题。\n","slug":"编写高质量代码/工程质量","published":1,"updated":"2019-05-17T05:57:58.586Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1j8f2i6001a7h9mc6qs2jhr","content":"<h1 id=\"开源工具的选择\"><a href=\"#开源工具的选择\" class=\"headerlink\" title=\"开源工具的选择\"></a>开源工具的选择</h1><ul>\n<li><p>普适性原则</p>\n<p>确保大部分项目成员对工具都比较熟悉。</p>\n</li>\n<li><p>唯一性原则</p>\n<p>相同的工具只选择一个或一种，不让多种相同或相似职能的工具共存。例如集合工具 Apache Commons 的 collections 包和 Google Guava 的 collections 工具包，在开发前就应该确认下来，不能让两者共存。</p>\n</li>\n<li><p>“大树纳凉”</p>\n<p>选择比较有名的开源组织，比如 Apache、Spring、Google 等。这些开源组织一则具有固定的开发运作风格，二则具有广阔的使用人群。</p>\n</li>\n<li><p>精而专</p>\n<p>我们选择的工具包应该是精而专的，而不是广而多。比如 Spring 框架提供了 Utils 工具包，但在一般情况下不要使用它，因为它不专，Utils 包只是 Spring 中的一个附加功能而已，要用就用 Apache Commons 的 BeanUtils、Long 等工具包。</p>\n</li>\n<li><p>高热度</p>\n<p>热度越高，更新越频繁，使用人群越光，BUG 曝光率越快，修复效率越高，对醒目的稳定性越好。</p>\n</li>\n</ul>\n<h1 id=\"良好的代码风格\"><a href=\"#良好的代码风格\" class=\"headerlink\" title=\"良好的代码风格\"></a>良好的代码风格</h1><ul>\n<li><p>整洁、统一、流行</p>\n<p>推荐 Google 的 Java 编码规范，《代码整洁之道》。</p>\n<ol>\n<li>好的变量命名，类的命名，方法命名。比如 Spring 源码里面命名老长老长的，但很好懂。</li>\n<li>方法入参超过 3 个就该考虑封装成对象。</li>\n</ol>\n</li>\n</ul>\n<ul>\n<li><p>便捷</p>\n<p>推荐 IDE code format。</p>\n</li>\n</ul>\n<h1 id=\"错误的编码习惯\"><a href=\"#错误的编码习惯\" class=\"headerlink\" title=\"错误的编码习惯\"></a>错误的编码习惯</h1><ol>\n<li><p>自由格式的代码</p>\n<p>不同项目，甚至同一个项目不同开发人员的风格也不同。</p>\n</li>\n<li><p>不使用抽象的代码</p>\n<p>抽象的意义不在于编码，而是在于对业务的理解，接口是对业务宏观的描述，而不是实现代码。</p>\n</li>\n<li><p>彰显个性的代码</p>\n<p>新技术只能作为技术的一个方向，不适合立刻投入生产中。项目的运行质量远远高于代码质量。“最小惊诧原则”，意思是说使用最常见的，而不是最新颖的功能。编码时，应寻找最常用的方法来实现。</p>\n</li>\n<li><p>死代码</p>\n<p>可能是忘记删除的代码，也可能是故意保留的类似“到此一游”的签名代码，这些代码按照正常的执行逻辑不可能被执行到。</p>\n</li>\n<li><p>冗余代码</p>\n<p>写了一个实现类，N 天后被废弃了，之后这个类就永久的保留下去了，没人知道它为什么没被删除掉。</p>\n</li>\n<li><p>自以为是的代码</p>\n<p>相信自己编写的工具类，而不是开源工具。宁愿自己写序列化工具，也不选择 kryo 或 protostuff；宁愿自己写日期处理工具，也不选择 Joda 或 date4j。</p>\n</li>\n</ol>\n<h1 id=\"技术自律\"><a href=\"#技术自律\" class=\"headerlink\" title=\"技术自律\"></a>技术自律</h1><ol>\n<li><p>熟悉工具</p>\n<p>常见工具类，例如 Apache Common， Google Guava。</p>\n</li>\n<li><p>坚持重构</p>\n<p>不要相信一次就能写出优秀的代码，这不现实，任何优秀的代码、算法都是经过多次重构磨炼的。</p>\n</li>\n<li><p>多写文档</p>\n<p>不仅仅是为了后续的参与人员，同时也为了整理自己的思维。</p>\n</li>\n<li><p>保持程序简单</p>\n<p>一个项目不要保持多个版本，即使有分支也必须定义出项目合并的条件，或时间约束或目标约束，不可任由版本扩散。</p>\n</li>\n<li><p>不重复造轮子</p>\n<p>在项目中使用已经成熟的工具或框架，而不是自己编写。但如果想共享一个新的框架，尽管去重复发明轮子，它不是以交付为目的，耳塞以技术研究为目的。</p>\n</li>\n<li><p>“剽窃”不可耻</p>\n<p>多看开源代码，学习一下人家的编码方式。</p>\n</li>\n<li><p>分享</p>\n<p>把自己的代码分享出去收获的不仅仅是赞许，还有自己能力的提升。</p>\n</li>\n<li><p>刨根问底</p>\n<p>”哦，这个问题加上这个参数就可以解决了”—-这不是解决问题的办法，在答案之后加上“是因为。。。”，这才是解决了问题。</p>\n</li>\n</ol>\n","excerpt":"","more":"<h1 id=\"开源工具的选择\"><a href=\"#开源工具的选择\" class=\"headerlink\" title=\"开源工具的选择\"></a>开源工具的选择</h1><ul>\n<li><p>普适性原则</p>\n<p>确保大部分项目成员对工具都比较熟悉。</p>\n</li>\n<li><p>唯一性原则</p>\n<p>相同的工具只选择一个或一种，不让多种相同或相似职能的工具共存。例如集合工具 Apache Commons 的 collections 包和 Google Guava 的 collections 工具包，在开发前就应该确认下来，不能让两者共存。</p>\n</li>\n<li><p>“大树纳凉”</p>\n<p>选择比较有名的开源组织，比如 Apache、Spring、Google 等。这些开源组织一则具有固定的开发运作风格，二则具有广阔的使用人群。</p>\n</li>\n<li><p>精而专</p>\n<p>我们选择的工具包应该是精而专的，而不是广而多。比如 Spring 框架提供了 Utils 工具包，但在一般情况下不要使用它，因为它不专，Utils 包只是 Spring 中的一个附加功能而已，要用就用 Apache Commons 的 BeanUtils、Long 等工具包。</p>\n</li>\n<li><p>高热度</p>\n<p>热度越高，更新越频繁，使用人群越光，BUG 曝光率越快，修复效率越高，对醒目的稳定性越好。</p>\n</li>\n</ul>\n<h1 id=\"良好的代码风格\"><a href=\"#良好的代码风格\" class=\"headerlink\" title=\"良好的代码风格\"></a>良好的代码风格</h1><ul>\n<li><p>整洁、统一、流行</p>\n<p>推荐 Google 的 Java 编码规范，《代码整洁之道》。</p>\n<ol>\n<li>好的变量命名，类的命名，方法命名。比如 Spring 源码里面命名老长老长的，但很好懂。</li>\n<li>方法入参超过 3 个就该考虑封装成对象。</li>\n</ol>\n</li>\n</ul>\n<ul>\n<li><p>便捷</p>\n<p>推荐 IDE code format。</p>\n</li>\n</ul>\n<h1 id=\"错误的编码习惯\"><a href=\"#错误的编码习惯\" class=\"headerlink\" title=\"错误的编码习惯\"></a>错误的编码习惯</h1><ol>\n<li><p>自由格式的代码</p>\n<p>不同项目，甚至同一个项目不同开发人员的风格也不同。</p>\n</li>\n<li><p>不使用抽象的代码</p>\n<p>抽象的意义不在于编码，而是在于对业务的理解，接口是对业务宏观的描述，而不是实现代码。</p>\n</li>\n<li><p>彰显个性的代码</p>\n<p>新技术只能作为技术的一个方向，不适合立刻投入生产中。项目的运行质量远远高于代码质量。“最小惊诧原则”，意思是说使用最常见的，而不是最新颖的功能。编码时，应寻找最常用的方法来实现。</p>\n</li>\n<li><p>死代码</p>\n<p>可能是忘记删除的代码，也可能是故意保留的类似“到此一游”的签名代码，这些代码按照正常的执行逻辑不可能被执行到。</p>\n</li>\n<li><p>冗余代码</p>\n<p>写了一个实现类，N 天后被废弃了，之后这个类就永久的保留下去了，没人知道它为什么没被删除掉。</p>\n</li>\n<li><p>自以为是的代码</p>\n<p>相信自己编写的工具类，而不是开源工具。宁愿自己写序列化工具，也不选择 kryo 或 protostuff；宁愿自己写日期处理工具，也不选择 Joda 或 date4j。</p>\n</li>\n</ol>\n<h1 id=\"技术自律\"><a href=\"#技术自律\" class=\"headerlink\" title=\"技术自律\"></a>技术自律</h1><ol>\n<li><p>熟悉工具</p>\n<p>常见工具类，例如 Apache Common， Google Guava。</p>\n</li>\n<li><p>坚持重构</p>\n<p>不要相信一次就能写出优秀的代码，这不现实，任何优秀的代码、算法都是经过多次重构磨炼的。</p>\n</li>\n<li><p>多写文档</p>\n<p>不仅仅是为了后续的参与人员，同时也为了整理自己的思维。</p>\n</li>\n<li><p>保持程序简单</p>\n<p>一个项目不要保持多个版本，即使有分支也必须定义出项目合并的条件，或时间约束或目标约束，不可任由版本扩散。</p>\n</li>\n<li><p>不重复造轮子</p>\n<p>在项目中使用已经成熟的工具或框架，而不是自己编写。但如果想共享一个新的框架，尽管去重复发明轮子，它不是以交付为目的，耳塞以技术研究为目的。</p>\n</li>\n<li><p>“剽窃”不可耻</p>\n<p>多看开源代码，学习一下人家的编码方式。</p>\n</li>\n<li><p>分享</p>\n<p>把自己的代码分享出去收获的不仅仅是赞许，还有自己能力的提升。</p>\n</li>\n<li><p>刨根问底</p>\n<p>”哦，这个问题加上这个参数就可以解决了”—-这不是解决问题的办法，在答案之后加上“是因为。。。”，这才是解决了问题。</p>\n</li>\n</ol>\n"},{"title":"类、对象及方法","date":"2017-01-22T16:00:00.000Z","_content":"\n*\t[构造函数尽量简化](#构造函数尽量简化)\n*\t[使用匿名类的构造函数](#使用匿名类的构造函数)\n\n###\t构造函数尽量简化\n\n看一段代码\n\n```Java\npublic class Sample2 {\n\n    public static void main(String[] args) {\n        Server s = new SimpleServer(1000);\n    }\n}\n\nabstract class Server {\n\n    public static final int DEFAULT_PORT = 40000;\n\n    public Server() {\n        int port = getPort();\n        System.out.println(\"端口号:\" + port);\n    }\n\n    protected abstract int getPort();\n}\n\nclass SimpleServer extends Server {\n\n    private int port = 100;\n\n    public SimpleServer(int _port) {\n        port = _port;\n    }\n\n    @Override\n    protected int getPort() {\n        return Math.random() > 0.5 ? port : DEFAULT_PORT;\n    }\n}\n```\n\n多次执行，结果只有2种，永远不会出现“端口号:100”或是\"端口号:1000\"\n\n```\n端口号:40000\n```\n\n```\n端口号:0\n```\n\n子类实例化时，会先初始化父类（这里只是初始化不是生成父类对象），也就是初始化父类的变量，调用父类的构造函数，然后再初始化子类的变量，调用子类构造函数。\n\n接着分析上面的程序，执行过程如下：\n\n1.\t子类SimpleServer的构造函数接收int类型参数：1000。\n2. \t父类初始化常变量，DEFAULT_PORT初始化为40000。\n3. \t执行父类午餐构造函数，即子类的有参构造默认包含了super()方法。\n4. \t父类构造函数执行到getPort，调用子类实现。\n5. \t子类的getPort返回port值（注意，此时port变量还未赋值，是0）或DEFAULT_PORT（此时是40000）了。\n6. \t父类初始化完毕，开始初始化子类实例变量，port赋值100。\n7. \t执行子类构造函数，port被重新赋值为1000.\n8. \t子类SimpleServer实例化结束，对象创建完毕。\n\n---\n###\t使用匿名类的构造函数\n\n看一段代码\n\n```Java\npublic static void main(String[] args) {\n    List l1 = new ArrayList();\n    List l2 = new ArrayList() {};\n    List l3 = new ArrayList() {{}};\n\n    System.out.println(l1.getClass() == l2.getClass());\n    System.out.println(l2.getClass() == l3.getClass());\n    System.out.println(l1.getClass() == l3.getClass());\n}\n```\n执行结果\n\n```\nfalse\nfalse\nfalse\n```\n\nl1 很容易理解，只是声明了 ArrayList 实例对象，l2 代表的是一个匿名类的生命和赋值，它定义了一个继承于 ArrayList 的匿名类，只是没有覆写任何方法。\n\nl3 也是一个匿名类的定义，它的代码类似于：\n\n```Java\nclass Sub extends ArrayList {\n\t(\n\t\t//初始化块\n\t)\n}\n//声明赋值\nList l3 = new Sub();\n```\n匿名类虽然没有名字，但也是可以有构造函数的，它用构造函数块来代替。\n","source":"_posts/编写高质量代码/类、对象及方法.md","raw":"---\ntitle: 类、对象及方法\ndate: 2017-01-23\ncategories: 编写高质量代码\ntags: \n- Java\n---\n\n*\t[构造函数尽量简化](#构造函数尽量简化)\n*\t[使用匿名类的构造函数](#使用匿名类的构造函数)\n\n###\t构造函数尽量简化\n\n看一段代码\n\n```Java\npublic class Sample2 {\n\n    public static void main(String[] args) {\n        Server s = new SimpleServer(1000);\n    }\n}\n\nabstract class Server {\n\n    public static final int DEFAULT_PORT = 40000;\n\n    public Server() {\n        int port = getPort();\n        System.out.println(\"端口号:\" + port);\n    }\n\n    protected abstract int getPort();\n}\n\nclass SimpleServer extends Server {\n\n    private int port = 100;\n\n    public SimpleServer(int _port) {\n        port = _port;\n    }\n\n    @Override\n    protected int getPort() {\n        return Math.random() > 0.5 ? port : DEFAULT_PORT;\n    }\n}\n```\n\n多次执行，结果只有2种，永远不会出现“端口号:100”或是\"端口号:1000\"\n\n```\n端口号:40000\n```\n\n```\n端口号:0\n```\n\n子类实例化时，会先初始化父类（这里只是初始化不是生成父类对象），也就是初始化父类的变量，调用父类的构造函数，然后再初始化子类的变量，调用子类构造函数。\n\n接着分析上面的程序，执行过程如下：\n\n1.\t子类SimpleServer的构造函数接收int类型参数：1000。\n2. \t父类初始化常变量，DEFAULT_PORT初始化为40000。\n3. \t执行父类午餐构造函数，即子类的有参构造默认包含了super()方法。\n4. \t父类构造函数执行到getPort，调用子类实现。\n5. \t子类的getPort返回port值（注意，此时port变量还未赋值，是0）或DEFAULT_PORT（此时是40000）了。\n6. \t父类初始化完毕，开始初始化子类实例变量，port赋值100。\n7. \t执行子类构造函数，port被重新赋值为1000.\n8. \t子类SimpleServer实例化结束，对象创建完毕。\n\n---\n###\t使用匿名类的构造函数\n\n看一段代码\n\n```Java\npublic static void main(String[] args) {\n    List l1 = new ArrayList();\n    List l2 = new ArrayList() {};\n    List l3 = new ArrayList() {{}};\n\n    System.out.println(l1.getClass() == l2.getClass());\n    System.out.println(l2.getClass() == l3.getClass());\n    System.out.println(l1.getClass() == l3.getClass());\n}\n```\n执行结果\n\n```\nfalse\nfalse\nfalse\n```\n\nl1 很容易理解，只是声明了 ArrayList 实例对象，l2 代表的是一个匿名类的生命和赋值，它定义了一个继承于 ArrayList 的匿名类，只是没有覆写任何方法。\n\nl3 也是一个匿名类的定义，它的代码类似于：\n\n```Java\nclass Sub extends ArrayList {\n\t(\n\t\t//初始化块\n\t)\n}\n//声明赋值\nList l3 = new Sub();\n```\n匿名类虽然没有名字，但也是可以有构造函数的，它用构造函数块来代替。\n","slug":"编写高质量代码/类、对象及方法","published":1,"updated":"2019-05-17T05:57:58.588Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1j8f2i7001b7h9m1m8497b4","content":"<ul>\n<li><a href=\"#构造函数尽量简化\">构造函数尽量简化</a></li>\n<li><a href=\"#使用匿名类的构造函数\">使用匿名类的构造函数</a></li>\n</ul>\n<h3 id=\"构造函数尽量简化\"><a href=\"#构造函数尽量简化\" class=\"headerlink\" title=\"构造函数尽量简化\"></a>构造函数尽量简化</h3><p>看一段代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sample2</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Server s = <span class=\"keyword\">new</span> SimpleServer(<span class=\"number\">1000</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Server</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> DEFAULT_PORT = <span class=\"number\">40000</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Server</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> port = getPort();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"端口号:\"</span> + port);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">int</span> <span class=\"title\">getPort</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SimpleServer</span> <span class=\"keyword\">extends</span> <span class=\"title\">Server</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> port = <span class=\"number\">100</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">SimpleServer</span><span class=\"params\">(<span class=\"keyword\">int</span> _port)</span> </span>&#123;</span><br><span class=\"line\">        port = _port;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">int</span> <span class=\"title\">getPort</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Math.random() &gt; <span class=\"number\">0.5</span> ? port : DEFAULT_PORT;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>多次执行，结果只有2种，永远不会出现“端口号:100”或是”端口号:1000”</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">端口号:40000</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">端口号:0</span><br></pre></td></tr></table></figure>\n<p>子类实例化时，会先初始化父类（这里只是初始化不是生成父类对象），也就是初始化父类的变量，调用父类的构造函数，然后再初始化子类的变量，调用子类构造函数。</p>\n<p>接着分析上面的程序，执行过程如下：</p>\n<ol>\n<li>子类SimpleServer的构造函数接收int类型参数：1000。</li>\n<li>父类初始化常变量，DEFAULT_PORT初始化为40000。</li>\n<li>执行父类午餐构造函数，即子类的有参构造默认包含了super()方法。</li>\n<li>父类构造函数执行到getPort，调用子类实现。</li>\n<li>子类的getPort返回port值（注意，此时port变量还未赋值，是0）或DEFAULT_PORT（此时是40000）了。</li>\n<li>父类初始化完毕，开始初始化子类实例变量，port赋值100。</li>\n<li>执行子类构造函数，port被重新赋值为1000.</li>\n<li>子类SimpleServer实例化结束，对象创建完毕。</li>\n</ol>\n<hr>\n<h3 id=\"使用匿名类的构造函数\"><a href=\"#使用匿名类的构造函数\" class=\"headerlink\" title=\"使用匿名类的构造函数\"></a>使用匿名类的构造函数</h3><p>看一段代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    List l1 = <span class=\"keyword\">new</span> ArrayList();</span><br><span class=\"line\">    List l2 = <span class=\"keyword\">new</span> ArrayList() &#123;&#125;;</span><br><span class=\"line\">    List l3 = <span class=\"keyword\">new</span> ArrayList() &#123;&#123;&#125;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    System.out.println(l1.getClass() == l2.getClass());</span><br><span class=\"line\">    System.out.println(l2.getClass() == l3.getClass());</span><br><span class=\"line\">    System.out.println(l1.getClass() == l3.getClass());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>执行结果</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">false</span><br><span class=\"line\">false</span><br><span class=\"line\">false</span><br></pre></td></tr></table></figure>\n<p>l1 很容易理解，只是声明了 ArrayList 实例对象，l2 代表的是一个匿名类的生命和赋值，它定义了一个继承于 ArrayList 的匿名类，只是没有覆写任何方法。</p>\n<p>l3 也是一个匿名类的定义，它的代码类似于：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sub</span> <span class=\"keyword\">extends</span> <span class=\"title\">ArrayList</span> </span>&#123;</span><br><span class=\"line\">\t(</span><br><span class=\"line\">\t\t<span class=\"comment\">//初始化块</span></span><br><span class=\"line\">\t)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//声明赋值</span></span><br><span class=\"line\">List l3 = <span class=\"keyword\">new</span> Sub();</span><br></pre></td></tr></table></figure>\n<p>匿名类虽然没有名字，但也是可以有构造函数的，它用构造函数块来代替。</p>\n","excerpt":"","more":"<ul>\n<li><a href=\"#构造函数尽量简化\">构造函数尽量简化</a></li>\n<li><a href=\"#使用匿名类的构造函数\">使用匿名类的构造函数</a></li>\n</ul>\n<h3 id=\"构造函数尽量简化\"><a href=\"#构造函数尽量简化\" class=\"headerlink\" title=\"构造函数尽量简化\"></a>构造函数尽量简化</h3><p>看一段代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sample2</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Server s = <span class=\"keyword\">new</span> SimpleServer(<span class=\"number\">1000</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Server</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> DEFAULT_PORT = <span class=\"number\">40000</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Server</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> port = getPort();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"端口号:\"</span> + port);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">int</span> <span class=\"title\">getPort</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SimpleServer</span> <span class=\"keyword\">extends</span> <span class=\"title\">Server</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> port = <span class=\"number\">100</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">SimpleServer</span><span class=\"params\">(<span class=\"keyword\">int</span> _port)</span> </span>&#123;</span><br><span class=\"line\">        port = _port;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">int</span> <span class=\"title\">getPort</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Math.random() &gt; <span class=\"number\">0.5</span> ? port : DEFAULT_PORT;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>多次执行，结果只有2种，永远不会出现“端口号:100”或是”端口号:1000”</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">端口号:40000</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">端口号:0</span><br></pre></td></tr></table></figure>\n<p>子类实例化时，会先初始化父类（这里只是初始化不是生成父类对象），也就是初始化父类的变量，调用父类的构造函数，然后再初始化子类的变量，调用子类构造函数。</p>\n<p>接着分析上面的程序，执行过程如下：</p>\n<ol>\n<li>子类SimpleServer的构造函数接收int类型参数：1000。</li>\n<li>父类初始化常变量，DEFAULT_PORT初始化为40000。</li>\n<li>执行父类午餐构造函数，即子类的有参构造默认包含了super()方法。</li>\n<li>父类构造函数执行到getPort，调用子类实现。</li>\n<li>子类的getPort返回port值（注意，此时port变量还未赋值，是0）或DEFAULT_PORT（此时是40000）了。</li>\n<li>父类初始化完毕，开始初始化子类实例变量，port赋值100。</li>\n<li>执行子类构造函数，port被重新赋值为1000.</li>\n<li>子类SimpleServer实例化结束，对象创建完毕。</li>\n</ol>\n<hr>\n<h3 id=\"使用匿名类的构造函数\"><a href=\"#使用匿名类的构造函数\" class=\"headerlink\" title=\"使用匿名类的构造函数\"></a>使用匿名类的构造函数</h3><p>看一段代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    List l1 = <span class=\"keyword\">new</span> ArrayList();</span><br><span class=\"line\">    List l2 = <span class=\"keyword\">new</span> ArrayList() &#123;&#125;;</span><br><span class=\"line\">    List l3 = <span class=\"keyword\">new</span> ArrayList() &#123;&#123;&#125;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    System.out.println(l1.getClass() == l2.getClass());</span><br><span class=\"line\">    System.out.println(l2.getClass() == l3.getClass());</span><br><span class=\"line\">    System.out.println(l1.getClass() == l3.getClass());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>执行结果</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">false</span><br><span class=\"line\">false</span><br><span class=\"line\">false</span><br></pre></td></tr></table></figure>\n<p>l1 很容易理解，只是声明了 ArrayList 实例对象，l2 代表的是一个匿名类的生命和赋值，它定义了一个继承于 ArrayList 的匿名类，只是没有覆写任何方法。</p>\n<p>l3 也是一个匿名类的定义，它的代码类似于：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sub</span> <span class=\"keyword\">extends</span> <span class=\"title\">ArrayList</span> </span>&#123;</span><br><span class=\"line\">\t(</span><br><span class=\"line\">\t\t<span class=\"comment\">//初始化块</span></span><br><span class=\"line\">\t)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//声明赋值</span></span><br><span class=\"line\">List l3 = <span class=\"keyword\">new</span> Sub();</span><br></pre></td></tr></table></figure>\n<p>匿名类虽然没有名字，但也是可以有构造函数的，它用构造函数块来代替。</p>\n"},{"title":"Java7 -- 可能错过的Java7特性","date":"2017-03-22T16:00:00.000Z","_content":"\n#\t可能错过的Java7特性\n\n*\t异常改进\n* \t文件IO\n*  \tequals、hashCode和CompareTo方法\n*  \t其他\n\n##\t异常改进\n\n###\ttry-with-resources\n\nJava7 提供了一个简单实用的代码格式\n\n```Java\n打开一个资源\ntry\t{\n\t实用该资源\n}\nfinally {\n\t关闭该资源\n}\n```\n其中资源所属类必须实现了 AutoCloseable 接口。\n\nvoid close() throws Exception\n\ntry-with-resources 语句最简形式如下\n\n```Java\ntry (Resource res = ...) {\n\t使用 res\n}\n```\n当 try 语句块退出时，会自动调用 res.close() 方法。\n\n```Java\ntry (Scanner in = new Scanner(Paths.get(File.separator, \"data\", \"word\"))) {\n    while (in.hasNext()) {                                                 \n        System.out.println(in.next());                                     \n    }                                                                      \n}                                                                          \n```\n当代码块像往常一样退出或发生异常时，都会调用 in.close() 方法，就如同你之前使用 finally 一样。\n\n###\t忽略异常\n\n无论何时使用输入或输出，在异常产生后如何关闭资源都是一个麻烦的问题。假设产生了一个 IOException ，接下来关闭资源事， close 方法又抛出了另一个异常。\n\n实际在Java中，finally分支中抛出的异常会丢弃掉之前的异常。\n\ntry-with-resources 修正了这个行为。当 AutoCloseable 的 close 方法抛出异常时，原来的异常会被重新抛出，而调用 close 方法产生的异常会被捕获，并被标注为“被忽略”的异常。\n\n###\t捕获多个异常\n\n假设多个异常的行为一致，允许将多个异常写在一个 catch 分支中：\n\n```Java\ntry {\n\t\n} catch (FileNotFoundException | UnknownHostException ex) {\n\n} catch (IOException ex){\n\n}\n```\n\n只有当捕获的异常均不是其他异常的子类时，才能用这种方法。\n\n###\tReflectiveOperationException\n\n在调用一个反射方法时，不得不捕获许多不相关的检查器异常。例如，创建一个类并调用它的 main 方法：\n\nClass.forName(className).getMethod(\"main\").invoke(null, new String[]{});\n\n该语句可能会导致一个 ClassNotFoundException、NoSuchMethodException、IllegalAccessException 或者 InvocationTargetException。\n\nJava7 修复了这一设计上的缺陷，引入了一个新的父类 ReflectiveOperationException, 这样就可以通过这一个异常来捕获其他所有子异常。\n\n##\t使用文件\n\n文件处理上，Java7 的 Path 接口取代了 File 类。\n\n### Path Paths\n\n###\tFiles\n\nFiles 类可以快速实现一些常用的文件 IO 操作，比之前的读写文件编码简洁太多。例如：\n\n####\t读写文件\n\n读取一个文件全部内容\n\n```Java\nbyte[] bytes = Files.readAllBytes(path);\n```\n\n将文件内容读取为一个字符串\n\n```Java\nString content = new String(bytes, StandardCharsets.UTF_8);\n```\n\n按行读取文件\n\n```Java\nList<String> lines = Files.readAllLines(path);\n```\n\n将字符串写入文件\n\n```Java\nFiles.write(path, \"content\".getBytes(StandardCharsets.UTF_8));\n```\n\n按行来写入文件\n\n```Java\nList<String> lines = Arrays.asList(\"abc\", \"xyz\");\nFiles.write(path, lines);\n```\n\n将内容追加到文件\n\n```Java\nList<String> lines = Arrays.asList(\"abc\", \"xyz\");\nFiles.write(path, lines, StandardOpenOption.APPEND);\n```\n\n默认情况下，Files 类的所有方法都使用 UTF-8 来读取或写入字符。\n\n处理一般大小文本文件时，通常最简单方法是将文件内容作为一个字符串或者字符串列表进行处理。如果文件很大，或者是二进制文件，仍然可以使用熟悉的 stream 类或者 reader/writer 类。\n\n```Java\nInputStream in = Files.newInputStream(path);\nOutputStream out = Files.newOutPutStream(path);\nReader reader = Files.newBufferedReader(path);\nWriter writer = Files.newBufferedWriter(path);\n```\n\n这些方便的方法可以帮你省去处理 FileInputStream、FileOutputStream、BufferedReader 或者 BufferedWriter 时的工作。\n\n如果希望将一个 InputStream 中的内容保存到一个文件中，可以使用\n\n```Java\nFiles.copy(in, path);\n```\n\n相反，可以将某个文件内容复制到一个 OutputStream 中。\n\n```Java\nFiles.copy(path, out);\n```\n\n####\t创建文件和目录\n\n创建目录\t\t\t\t\n\n```Java\nFiles.createDirectories(path);\n```\n\n创建空文件\n\n```Java\nFiles.createFile(path);\n```\n\n文件已经存在会抛异常，对已有文件的检查和创建都属于原子操作，所以如果文件不存在，那么它一定会在其他线程之前创建该文件。\n\n####\t复制、移动和删除文件\n\n复制\n\n```Java\nFiles.copy(fromPath, toPath);\n```\n\n移动\n\n```Java\nFiles.move(fromPath, toPath);\n```\n\n如果目标文件或目录存在，copy 或 move 方法会失败。如果希望覆盖目标文件，使用 REPLACE_EXISTING 选项。如果希望复制所有文件属性，使用 COPY_ATTRIBUTES 选项，也可同时提供这两个选项：\n\n```Java\nFiles.copy(fromPath, toPath, StandardCopyOption.REPLACE_EXISTING, StandardCopyOption.COPY_ATTRIBUTES);\n```\n\n可指定使用原子方式来执行移动，这样要么移动操作成功完成，要么源文件依然存在：\n\n```Java\nFiles.move(fromPath, toPath, StandardCopyOption.ATOMIC_MOVE);\n```\n\n删除\n\n```Java\nFiles.delete(path);\n```\n\n如果文件不存在会抛异常，可能希望使用另一个方法：\n\n```Java\nboolean deleted = Files.deleteIfExists(path);\n```\n\n```\n没有直接删除或复制非空目录的方法。要实现请参考 FileVisitor 接口的API文档。\n```\n\n##\tequals、hashcode、和 compareTo 方法\n\n###\t安全的 Null 值相等测试\n\n假设需要为下面的类实现 equals 方法：\n\n```Java\npublic class Person {\n\tprivate String first;\n\tprivate String last;\n\t...\n}\n```\n\n首先，你不得不将参数转换为一个 Person 对象：\n\n```Java\npublic boolean equals(Object otherObject) {\n\tif (this == otherObject) return true;\n\tif (otherObject == null) return false;\n\tif (this.getClass() != otherObject.getClass()) return false;\n\tPerson other = (Person) otherObject;\n\t...\n}\n```\n\nJava7出现后，再不用担心 first 或者 last 可能为空，只需调用\n\n```Java\nreturn Obejcts.equals(a, b);\n```\n如果 a 和 b 都是 null，则返回 true；如果只有 a 为 null，则返回 false；其他情况则返回 a.equals(b)。\n\n###\t计算哈希码\n\n```Java\nreturn Objects.hash(first, last);\n```\n\nObjects.hash 只是会调用从 Java5 开始就存在的 Arrays.hash 方法。但他不是一个支持可变参数的方法。\n\n###\ttoString()\n\nString.valueOf(obj)，可以安全处理 null 对象。如果 obj 为 null，会返回字符串 “null”。如果不喜欢这种方式，可以调用 Objects.toString 方法，并提供一个用于 null 对象的值。例如，Objects.toString(obj, \"\");\n\n```Java\n    /**\n     * Returns the result of calling {@code toString} on the first\n     * argument if the first argument is not {@code null} and returns\n     * the second argument otherwise.\n     *\n     * @param o an object\n     * @param nullDefault string to return if the first argument is\n     *        {@code null}\n     * @return the result of calling {@code toString} on the first\n     * argument if it is not {@code null} and the second argument\n     * otherwise.\n     * @see Objects#toString(Object)\n     */\n    public static String toString(Object o, String nullDefault) {\n        return (o != null) ? o.toString() : nullDefault;\n    }\n```\n\n\n###\t比较数值类型对象\n\n使用静态方法 Integer.compare \n\n```Java\nint diff = Integer.compare(x, other.x);\nif (diff != 0) return diff;\nreturn Integer.compare(y, other.y); \n```\n\n过去某些开发人员会使用 new Integer(x).compareTo(other.x)的方式，但这会创建两个会自动装箱/拆箱的整形对象。相比之下，静态方法 compare 使用的是 int 参数。\n\n此外，Long、Short、Byte、和 Boolean 也都提供了各自的静态方法 compare。\n\n```\nDouble 和 Float 中的静态方法 compare 从 Java1.2 开始就存在了。\n```\n##\t\t其他\n\n###\t字符串转数字\n\n```Java\ndouble x = Double.parseDouble(\"+1.0\");\nint n = Integer.parseInt(\"+1\");\n```\n\n在 Java7 之前，+1 一直不是一个有效整数。\n\n现在这个问题已经在所有通过字符串来构造 int、long、short、byte 和 BigInteger 的方法中被修复了，还包括包装类、处理十六进制和八进制数输入的 decode 方法，一级生成包装类对象的 valueOf 方法。BigInteger(String) 也被修复了。\n\n###\t全局 Logger\n\n```Java\n    public static final Logger getGlobal() {\n        // In order to break a cyclic dependence between the LogManager\n        // and Logger static initializers causing deadlocks, the global\n        // logger is created with a special constructor that does not\n        // initialize its log manager.\n        //\n        // If an application calls Logger.getGlobal() before any logger\n        // has been initialized, it is therefore possible that the\n        // LogManager class has not been initialized yet, and therefore\n        // Logger.global.manager will be null.\n        //\n        // In order to finish the initialization of the global logger, we\n        // will therefore call LogManager.getLogManager() here.\n        //\n        // To prevent race conditions we also need to call\n        // LogManager.getLogManager() unconditionally here.\n        // Indeed we cannot rely on the observed value of global.manager,\n        // because global.manager will become not null somewhere during\n        // the initialization of LogManager.\n        // If two threads are calling getGlobal() concurrently, one thread\n        // will see global.manager null and call LogManager.getLogManager(),\n        // but the other thread could come in at a time when global.manager\n        // is already set although ensureLogManagerInitialized is not finished\n        // yet...\n        // Calling LogManager.getLogManager() unconditionally will fix that.\n\n        LogManager.getLogManager();\n\n        // Now the global LogManager should be initialized,\n        // and the global logger should have been added to\n        // it, unless we were called within the constructor of a LogManager\n        // subclass installed as LogManager, in which case global.manager\n        // would still be null, and global will be lazily initialized later on.\n\n        return global;\n    }\n```\n\n###\tNull 检查\n\n```Java\n    /**\n     * Checks that the specified object reference is not {@code null}. This\n     * method is designed primarily for doing parameter validation in methods\n     * and constructors, as demonstrated below:\n     * <blockquote><pre>\n     * public Foo(Bar bar) {\n     *     this.bar = Objects.requireNonNull(bar);\n     * }\n     * </pre></blockquote>\n     *\n     * @param obj the object reference to check for nullity\n     * @param <T> the type of the reference\n     * @return {@code obj} if not {@code null}\n     * @throws NullPointerException if {@code obj} is {@code null}\n     */\n    public static <T> T requireNonNull(T obj) {\n        if (obj == null)\n            throw new NullPointerException();\n        return obj;\n    }\n```\n\n```Java\n    /**\n     * Checks that the specified object reference is not {@code null} and\n     * throws a customized {@link NullPointerException} if it is. This method\n     * is designed primarily for doing parameter validation in methods and\n     * constructors with multiple parameters, as demonstrated below:\n     * <blockquote><pre>\n     * public Foo(Bar bar, Baz baz) {\n     *     this.bar = Objects.requireNonNull(bar, \"bar must not be null\");\n     *     this.baz = Objects.requireNonNull(baz, \"baz must not be null\");\n     * }\n     * </pre></blockquote>\n     *\n     * @param obj     the object reference to check for nullity\n     * @param message detail message to be used in the event that a {@code\n     *                NullPointerException} is thrown\n     * @param <T> the type of the reference\n     * @return {@code obj} if not {@code null}\n     * @throws NullPointerException if {@code obj} is {@code null}\n     */\n    public static <T> T requireNonNull(T obj, String message) {\n        if (obj == null)\n            throw new NullPointerException(message);\n        return obj;\n    }\n```\n\n###\tProcessBuilder\n\nJava5 之前，Runtime.exec 方法是在 Java 中执行一个外部命令的唯一方式。Java5 添加了 ProcessBuilder 类，加强了对 OS 进程的控制，尤其是通过 ProcessBuilder，你可以改变工作目录。\n\nJava7 添加了一些新方法，使得开发人员能方便地将进程的标准输入、输出及错误重定向到文件中。\n\n```Java\n   public Redirect redirectInput() {\n        return (redirects == null) ? Redirect.PIPE : redirects[0];\n   }\n   \n   public Redirect redirectOutput() {\n        return (redirects == null) ? Redirect.PIPE : redirects[1];\n   }\n   \n   public ProcessBuilder redirectInput(File file) {\n        return redirectInput(Redirect.from(file));\n   }\n   \n   public ProcessBuilder redirectOutput(File file) {\n        return redirectOutput(Redirect.to(file));\n   }\n   \n   public Redirect redirectError() {\n        return (redirects == null) ? Redirect.PIPE : redirects[2];\n   }\n   \n   public ProcessBuilder redirectError(File file) {\n        return redirectError(Redirect.to(file));\n   }\n\n\t...\n```\n\n###\tURLClassLoader\n\nJava7 只是添加了一个用来关闭该类加载器的 close 方法，URLClassLoader 类现在实现了 AutoCloseable 接口，因此可使用 try-with-resources 语句来避免可能出现的资源泄露。\n\n```Java\npublic class URLClassLoader extends SecureClassLoader implements Closeable {\n\t...\n}\n```\n\n###\tBitSet\n\nBitSet 是一个表示 bit 序列的整数集合。该集合可以根据整数 i 来设置第 i 个 bit 位的值。这使得集合操作非常搞笑。求并集、交集、补集只不过是简单的按位或、与、非运算。\n\nJava7 添加了一些构造 BitSet 的方法：\n\n```Java\n    public static BitSet valueOf(byte[] bytes) {\n        return BitSet.valueOf(ByteBuffer.wrap(bytes));\n    }\n    \n    public static BitSet valueOf(ByteBuffer bb) {\n        bb = bb.slice().order(ByteOrder.LITTLE_ENDIAN);\n        int n;\n        for (n = bb.remaining(); n > 0 && bb.get(n - 1) == 0; n--)\n            ;\n        long[] words = new long[(n + 7) / 8];\n        bb.limit(n);\n        int i = 0;\n        while (bb.remaining() >= 8)\n            words[i++] = bb.getLong();\n        for (int remaining = bb.remaining(), j = 0; j < remaining; j++)\n            words[i] |= (bb.get() & 0xffL) << (8 * j);\n        return new BitSet(words);\n    }\n    \n    public static BitSet valueOf(long[] longs) {\n        int n;\n        for (n = longs.length; n > 0 && longs[n - 1] == 0; n--)\n            ;\n        return new BitSet(Arrays.copyOf(longs, n));\n    }\n    \n    public static BitSet valueOf(LongBuffer lb) {\n        lb = lb.slice();\n        int n;\n        for (n = lb.remaining(); n > 0 && lb.get(n - 1) == 0; n--)\n            ;\n        long[] words = new long[n];\n        lb.get(words);\n        return new BitSet(words);\n    }\n```","source":"_posts/Java Web/可能错过的Java7特性.md","raw":"---\ntitle: Java7 -- 可能错过的Java7特性\ndate: 2017-03-23\ncategories: Java Web\ntags: \n- Java7\n---\n\n#\t可能错过的Java7特性\n\n*\t异常改进\n* \t文件IO\n*  \tequals、hashCode和CompareTo方法\n*  \t其他\n\n##\t异常改进\n\n###\ttry-with-resources\n\nJava7 提供了一个简单实用的代码格式\n\n```Java\n打开一个资源\ntry\t{\n\t实用该资源\n}\nfinally {\n\t关闭该资源\n}\n```\n其中资源所属类必须实现了 AutoCloseable 接口。\n\nvoid close() throws Exception\n\ntry-with-resources 语句最简形式如下\n\n```Java\ntry (Resource res = ...) {\n\t使用 res\n}\n```\n当 try 语句块退出时，会自动调用 res.close() 方法。\n\n```Java\ntry (Scanner in = new Scanner(Paths.get(File.separator, \"data\", \"word\"))) {\n    while (in.hasNext()) {                                                 \n        System.out.println(in.next());                                     \n    }                                                                      \n}                                                                          \n```\n当代码块像往常一样退出或发生异常时，都会调用 in.close() 方法，就如同你之前使用 finally 一样。\n\n###\t忽略异常\n\n无论何时使用输入或输出，在异常产生后如何关闭资源都是一个麻烦的问题。假设产生了一个 IOException ，接下来关闭资源事， close 方法又抛出了另一个异常。\n\n实际在Java中，finally分支中抛出的异常会丢弃掉之前的异常。\n\ntry-with-resources 修正了这个行为。当 AutoCloseable 的 close 方法抛出异常时，原来的异常会被重新抛出，而调用 close 方法产生的异常会被捕获，并被标注为“被忽略”的异常。\n\n###\t捕获多个异常\n\n假设多个异常的行为一致，允许将多个异常写在一个 catch 分支中：\n\n```Java\ntry {\n\t\n} catch (FileNotFoundException | UnknownHostException ex) {\n\n} catch (IOException ex){\n\n}\n```\n\n只有当捕获的异常均不是其他异常的子类时，才能用这种方法。\n\n###\tReflectiveOperationException\n\n在调用一个反射方法时，不得不捕获许多不相关的检查器异常。例如，创建一个类并调用它的 main 方法：\n\nClass.forName(className).getMethod(\"main\").invoke(null, new String[]{});\n\n该语句可能会导致一个 ClassNotFoundException、NoSuchMethodException、IllegalAccessException 或者 InvocationTargetException。\n\nJava7 修复了这一设计上的缺陷，引入了一个新的父类 ReflectiveOperationException, 这样就可以通过这一个异常来捕获其他所有子异常。\n\n##\t使用文件\n\n文件处理上，Java7 的 Path 接口取代了 File 类。\n\n### Path Paths\n\n###\tFiles\n\nFiles 类可以快速实现一些常用的文件 IO 操作，比之前的读写文件编码简洁太多。例如：\n\n####\t读写文件\n\n读取一个文件全部内容\n\n```Java\nbyte[] bytes = Files.readAllBytes(path);\n```\n\n将文件内容读取为一个字符串\n\n```Java\nString content = new String(bytes, StandardCharsets.UTF_8);\n```\n\n按行读取文件\n\n```Java\nList<String> lines = Files.readAllLines(path);\n```\n\n将字符串写入文件\n\n```Java\nFiles.write(path, \"content\".getBytes(StandardCharsets.UTF_8));\n```\n\n按行来写入文件\n\n```Java\nList<String> lines = Arrays.asList(\"abc\", \"xyz\");\nFiles.write(path, lines);\n```\n\n将内容追加到文件\n\n```Java\nList<String> lines = Arrays.asList(\"abc\", \"xyz\");\nFiles.write(path, lines, StandardOpenOption.APPEND);\n```\n\n默认情况下，Files 类的所有方法都使用 UTF-8 来读取或写入字符。\n\n处理一般大小文本文件时，通常最简单方法是将文件内容作为一个字符串或者字符串列表进行处理。如果文件很大，或者是二进制文件，仍然可以使用熟悉的 stream 类或者 reader/writer 类。\n\n```Java\nInputStream in = Files.newInputStream(path);\nOutputStream out = Files.newOutPutStream(path);\nReader reader = Files.newBufferedReader(path);\nWriter writer = Files.newBufferedWriter(path);\n```\n\n这些方便的方法可以帮你省去处理 FileInputStream、FileOutputStream、BufferedReader 或者 BufferedWriter 时的工作。\n\n如果希望将一个 InputStream 中的内容保存到一个文件中，可以使用\n\n```Java\nFiles.copy(in, path);\n```\n\n相反，可以将某个文件内容复制到一个 OutputStream 中。\n\n```Java\nFiles.copy(path, out);\n```\n\n####\t创建文件和目录\n\n创建目录\t\t\t\t\n\n```Java\nFiles.createDirectories(path);\n```\n\n创建空文件\n\n```Java\nFiles.createFile(path);\n```\n\n文件已经存在会抛异常，对已有文件的检查和创建都属于原子操作，所以如果文件不存在，那么它一定会在其他线程之前创建该文件。\n\n####\t复制、移动和删除文件\n\n复制\n\n```Java\nFiles.copy(fromPath, toPath);\n```\n\n移动\n\n```Java\nFiles.move(fromPath, toPath);\n```\n\n如果目标文件或目录存在，copy 或 move 方法会失败。如果希望覆盖目标文件，使用 REPLACE_EXISTING 选项。如果希望复制所有文件属性，使用 COPY_ATTRIBUTES 选项，也可同时提供这两个选项：\n\n```Java\nFiles.copy(fromPath, toPath, StandardCopyOption.REPLACE_EXISTING, StandardCopyOption.COPY_ATTRIBUTES);\n```\n\n可指定使用原子方式来执行移动，这样要么移动操作成功完成，要么源文件依然存在：\n\n```Java\nFiles.move(fromPath, toPath, StandardCopyOption.ATOMIC_MOVE);\n```\n\n删除\n\n```Java\nFiles.delete(path);\n```\n\n如果文件不存在会抛异常，可能希望使用另一个方法：\n\n```Java\nboolean deleted = Files.deleteIfExists(path);\n```\n\n```\n没有直接删除或复制非空目录的方法。要实现请参考 FileVisitor 接口的API文档。\n```\n\n##\tequals、hashcode、和 compareTo 方法\n\n###\t安全的 Null 值相等测试\n\n假设需要为下面的类实现 equals 方法：\n\n```Java\npublic class Person {\n\tprivate String first;\n\tprivate String last;\n\t...\n}\n```\n\n首先，你不得不将参数转换为一个 Person 对象：\n\n```Java\npublic boolean equals(Object otherObject) {\n\tif (this == otherObject) return true;\n\tif (otherObject == null) return false;\n\tif (this.getClass() != otherObject.getClass()) return false;\n\tPerson other = (Person) otherObject;\n\t...\n}\n```\n\nJava7出现后，再不用担心 first 或者 last 可能为空，只需调用\n\n```Java\nreturn Obejcts.equals(a, b);\n```\n如果 a 和 b 都是 null，则返回 true；如果只有 a 为 null，则返回 false；其他情况则返回 a.equals(b)。\n\n###\t计算哈希码\n\n```Java\nreturn Objects.hash(first, last);\n```\n\nObjects.hash 只是会调用从 Java5 开始就存在的 Arrays.hash 方法。但他不是一个支持可变参数的方法。\n\n###\ttoString()\n\nString.valueOf(obj)，可以安全处理 null 对象。如果 obj 为 null，会返回字符串 “null”。如果不喜欢这种方式，可以调用 Objects.toString 方法，并提供一个用于 null 对象的值。例如，Objects.toString(obj, \"\");\n\n```Java\n    /**\n     * Returns the result of calling {@code toString} on the first\n     * argument if the first argument is not {@code null} and returns\n     * the second argument otherwise.\n     *\n     * @param o an object\n     * @param nullDefault string to return if the first argument is\n     *        {@code null}\n     * @return the result of calling {@code toString} on the first\n     * argument if it is not {@code null} and the second argument\n     * otherwise.\n     * @see Objects#toString(Object)\n     */\n    public static String toString(Object o, String nullDefault) {\n        return (o != null) ? o.toString() : nullDefault;\n    }\n```\n\n\n###\t比较数值类型对象\n\n使用静态方法 Integer.compare \n\n```Java\nint diff = Integer.compare(x, other.x);\nif (diff != 0) return diff;\nreturn Integer.compare(y, other.y); \n```\n\n过去某些开发人员会使用 new Integer(x).compareTo(other.x)的方式，但这会创建两个会自动装箱/拆箱的整形对象。相比之下，静态方法 compare 使用的是 int 参数。\n\n此外，Long、Short、Byte、和 Boolean 也都提供了各自的静态方法 compare。\n\n```\nDouble 和 Float 中的静态方法 compare 从 Java1.2 开始就存在了。\n```\n##\t\t其他\n\n###\t字符串转数字\n\n```Java\ndouble x = Double.parseDouble(\"+1.0\");\nint n = Integer.parseInt(\"+1\");\n```\n\n在 Java7 之前，+1 一直不是一个有效整数。\n\n现在这个问题已经在所有通过字符串来构造 int、long、short、byte 和 BigInteger 的方法中被修复了，还包括包装类、处理十六进制和八进制数输入的 decode 方法，一级生成包装类对象的 valueOf 方法。BigInteger(String) 也被修复了。\n\n###\t全局 Logger\n\n```Java\n    public static final Logger getGlobal() {\n        // In order to break a cyclic dependence between the LogManager\n        // and Logger static initializers causing deadlocks, the global\n        // logger is created with a special constructor that does not\n        // initialize its log manager.\n        //\n        // If an application calls Logger.getGlobal() before any logger\n        // has been initialized, it is therefore possible that the\n        // LogManager class has not been initialized yet, and therefore\n        // Logger.global.manager will be null.\n        //\n        // In order to finish the initialization of the global logger, we\n        // will therefore call LogManager.getLogManager() here.\n        //\n        // To prevent race conditions we also need to call\n        // LogManager.getLogManager() unconditionally here.\n        // Indeed we cannot rely on the observed value of global.manager,\n        // because global.manager will become not null somewhere during\n        // the initialization of LogManager.\n        // If two threads are calling getGlobal() concurrently, one thread\n        // will see global.manager null and call LogManager.getLogManager(),\n        // but the other thread could come in at a time when global.manager\n        // is already set although ensureLogManagerInitialized is not finished\n        // yet...\n        // Calling LogManager.getLogManager() unconditionally will fix that.\n\n        LogManager.getLogManager();\n\n        // Now the global LogManager should be initialized,\n        // and the global logger should have been added to\n        // it, unless we were called within the constructor of a LogManager\n        // subclass installed as LogManager, in which case global.manager\n        // would still be null, and global will be lazily initialized later on.\n\n        return global;\n    }\n```\n\n###\tNull 检查\n\n```Java\n    /**\n     * Checks that the specified object reference is not {@code null}. This\n     * method is designed primarily for doing parameter validation in methods\n     * and constructors, as demonstrated below:\n     * <blockquote><pre>\n     * public Foo(Bar bar) {\n     *     this.bar = Objects.requireNonNull(bar);\n     * }\n     * </pre></blockquote>\n     *\n     * @param obj the object reference to check for nullity\n     * @param <T> the type of the reference\n     * @return {@code obj} if not {@code null}\n     * @throws NullPointerException if {@code obj} is {@code null}\n     */\n    public static <T> T requireNonNull(T obj) {\n        if (obj == null)\n            throw new NullPointerException();\n        return obj;\n    }\n```\n\n```Java\n    /**\n     * Checks that the specified object reference is not {@code null} and\n     * throws a customized {@link NullPointerException} if it is. This method\n     * is designed primarily for doing parameter validation in methods and\n     * constructors with multiple parameters, as demonstrated below:\n     * <blockquote><pre>\n     * public Foo(Bar bar, Baz baz) {\n     *     this.bar = Objects.requireNonNull(bar, \"bar must not be null\");\n     *     this.baz = Objects.requireNonNull(baz, \"baz must not be null\");\n     * }\n     * </pre></blockquote>\n     *\n     * @param obj     the object reference to check for nullity\n     * @param message detail message to be used in the event that a {@code\n     *                NullPointerException} is thrown\n     * @param <T> the type of the reference\n     * @return {@code obj} if not {@code null}\n     * @throws NullPointerException if {@code obj} is {@code null}\n     */\n    public static <T> T requireNonNull(T obj, String message) {\n        if (obj == null)\n            throw new NullPointerException(message);\n        return obj;\n    }\n```\n\n###\tProcessBuilder\n\nJava5 之前，Runtime.exec 方法是在 Java 中执行一个外部命令的唯一方式。Java5 添加了 ProcessBuilder 类，加强了对 OS 进程的控制，尤其是通过 ProcessBuilder，你可以改变工作目录。\n\nJava7 添加了一些新方法，使得开发人员能方便地将进程的标准输入、输出及错误重定向到文件中。\n\n```Java\n   public Redirect redirectInput() {\n        return (redirects == null) ? Redirect.PIPE : redirects[0];\n   }\n   \n   public Redirect redirectOutput() {\n        return (redirects == null) ? Redirect.PIPE : redirects[1];\n   }\n   \n   public ProcessBuilder redirectInput(File file) {\n        return redirectInput(Redirect.from(file));\n   }\n   \n   public ProcessBuilder redirectOutput(File file) {\n        return redirectOutput(Redirect.to(file));\n   }\n   \n   public Redirect redirectError() {\n        return (redirects == null) ? Redirect.PIPE : redirects[2];\n   }\n   \n   public ProcessBuilder redirectError(File file) {\n        return redirectError(Redirect.to(file));\n   }\n\n\t...\n```\n\n###\tURLClassLoader\n\nJava7 只是添加了一个用来关闭该类加载器的 close 方法，URLClassLoader 类现在实现了 AutoCloseable 接口，因此可使用 try-with-resources 语句来避免可能出现的资源泄露。\n\n```Java\npublic class URLClassLoader extends SecureClassLoader implements Closeable {\n\t...\n}\n```\n\n###\tBitSet\n\nBitSet 是一个表示 bit 序列的整数集合。该集合可以根据整数 i 来设置第 i 个 bit 位的值。这使得集合操作非常搞笑。求并集、交集、补集只不过是简单的按位或、与、非运算。\n\nJava7 添加了一些构造 BitSet 的方法：\n\n```Java\n    public static BitSet valueOf(byte[] bytes) {\n        return BitSet.valueOf(ByteBuffer.wrap(bytes));\n    }\n    \n    public static BitSet valueOf(ByteBuffer bb) {\n        bb = bb.slice().order(ByteOrder.LITTLE_ENDIAN);\n        int n;\n        for (n = bb.remaining(); n > 0 && bb.get(n - 1) == 0; n--)\n            ;\n        long[] words = new long[(n + 7) / 8];\n        bb.limit(n);\n        int i = 0;\n        while (bb.remaining() >= 8)\n            words[i++] = bb.getLong();\n        for (int remaining = bb.remaining(), j = 0; j < remaining; j++)\n            words[i] |= (bb.get() & 0xffL) << (8 * j);\n        return new BitSet(words);\n    }\n    \n    public static BitSet valueOf(long[] longs) {\n        int n;\n        for (n = longs.length; n > 0 && longs[n - 1] == 0; n--)\n            ;\n        return new BitSet(Arrays.copyOf(longs, n));\n    }\n    \n    public static BitSet valueOf(LongBuffer lb) {\n        lb = lb.slice();\n        int n;\n        for (n = lb.remaining(); n > 0 && lb.get(n - 1) == 0; n--)\n            ;\n        long[] words = new long[n];\n        lb.get(words);\n        return new BitSet(words);\n    }\n```","slug":"Java Web/可能错过的Java7特性","published":1,"updated":"2019-05-17T05:57:58.557Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1j8f2in001c7h9mcovaxj0p","content":"<h1 id=\"可能错过的Java7特性\"><a href=\"#可能错过的Java7特性\" class=\"headerlink\" title=\"可能错过的Java7特性\"></a>可能错过的Java7特性</h1><ul>\n<li>异常改进</li>\n<li>文件IO</li>\n<li>equals、hashCode和CompareTo方法</li>\n<li>其他</li>\n</ul>\n<h2 id=\"异常改进\"><a href=\"#异常改进\" class=\"headerlink\" title=\"异常改进\"></a>异常改进</h2><h3 id=\"try-with-resources\"><a href=\"#try-with-resources\" class=\"headerlink\" title=\"try-with-resources\"></a>try-with-resources</h3><p>Java7 提供了一个简单实用的代码格式</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">打开一个资源</span><br><span class=\"line\"><span class=\"keyword\">try</span>\t&#123;</span><br><span class=\"line\">\t实用该资源</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">\t关闭该资源</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其中资源所属类必须实现了 AutoCloseable 接口。</p>\n<p>void close() throws Exception</p>\n<p>try-with-resources 语句最简形式如下</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> (Resource res = ...) &#123;</span><br><span class=\"line\">\t使用 res</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当 try 语句块退出时，会自动调用 res.close() 方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> (Scanner in = <span class=\"keyword\">new</span> Scanner(Paths.get(File.separator, <span class=\"string\">\"data\"</span>, <span class=\"string\">\"word\"</span>))) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (in.hasNext()) &#123;                                                 </span><br><span class=\"line\">        System.out.println(in.next());                                     </span><br><span class=\"line\">    &#125;                                                                      </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当代码块像往常一样退出或发生异常时，都会调用 in.close() 方法，就如同你之前使用 finally 一样。</p>\n<h3 id=\"忽略异常\"><a href=\"#忽略异常\" class=\"headerlink\" title=\"忽略异常\"></a>忽略异常</h3><p>无论何时使用输入或输出，在异常产生后如何关闭资源都是一个麻烦的问题。假设产生了一个 IOException ，接下来关闭资源事， close 方法又抛出了另一个异常。</p>\n<p>实际在Java中，finally分支中抛出的异常会丢弃掉之前的异常。</p>\n<p>try-with-resources 修正了这个行为。当 AutoCloseable 的 close 方法抛出异常时，原来的异常会被重新抛出，而调用 close 方法产生的异常会被捕获，并被标注为“被忽略”的异常。</p>\n<h3 id=\"捕获多个异常\"><a href=\"#捕获多个异常\" class=\"headerlink\" title=\"捕获多个异常\"></a>捕获多个异常</h3><p>假设多个异常的行为一致，允许将多个异常写在一个 catch 分支中：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (FileNotFoundException | UnknownHostException ex) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (IOException ex)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>只有当捕获的异常均不是其他异常的子类时，才能用这种方法。</p>\n<h3 id=\"ReflectiveOperationException\"><a href=\"#ReflectiveOperationException\" class=\"headerlink\" title=\"ReflectiveOperationException\"></a>ReflectiveOperationException</h3><p>在调用一个反射方法时，不得不捕获许多不相关的检查器异常。例如，创建一个类并调用它的 main 方法：</p>\n<p>Class.forName(className).getMethod(“main”).invoke(null, new String[]{});</p>\n<p>该语句可能会导致一个 ClassNotFoundException、NoSuchMethodException、IllegalAccessException 或者 InvocationTargetException。</p>\n<p>Java7 修复了这一设计上的缺陷，引入了一个新的父类 ReflectiveOperationException, 这样就可以通过这一个异常来捕获其他所有子异常。</p>\n<h2 id=\"使用文件\"><a href=\"#使用文件\" class=\"headerlink\" title=\"使用文件\"></a>使用文件</h2><p>文件处理上，Java7 的 Path 接口取代了 File 类。</p>\n<h3 id=\"Path-Paths\"><a href=\"#Path-Paths\" class=\"headerlink\" title=\"Path Paths\"></a>Path Paths</h3><h3 id=\"Files\"><a href=\"#Files\" class=\"headerlink\" title=\"Files\"></a>Files</h3><p>Files 类可以快速实现一些常用的文件 IO 操作，比之前的读写文件编码简洁太多。例如：</p>\n<h4 id=\"读写文件\"><a href=\"#读写文件\" class=\"headerlink\" title=\"读写文件\"></a>读写文件</h4><p>读取一个文件全部内容</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">byte</span>[] bytes = Files.readAllBytes(path);</span><br></pre></td></tr></table></figure>\n<p>将文件内容读取为一个字符串</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String content = <span class=\"keyword\">new</span> String(bytes, StandardCharsets.UTF_8);</span><br></pre></td></tr></table></figure>\n<p>按行读取文件</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;String&gt; lines = Files.readAllLines(path);</span><br></pre></td></tr></table></figure>\n<p>将字符串写入文件</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Files.write(path, <span class=\"string\">\"content\"</span>.getBytes(StandardCharsets.UTF_8));</span><br></pre></td></tr></table></figure>\n<p>按行来写入文件</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;String&gt; lines = Arrays.asList(<span class=\"string\">\"abc\"</span>, <span class=\"string\">\"xyz\"</span>);</span><br><span class=\"line\">Files.write(path, lines);</span><br></pre></td></tr></table></figure>\n<p>将内容追加到文件</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;String&gt; lines = Arrays.asList(<span class=\"string\">\"abc\"</span>, <span class=\"string\">\"xyz\"</span>);</span><br><span class=\"line\">Files.write(path, lines, StandardOpenOption.APPEND);</span><br></pre></td></tr></table></figure>\n<p>默认情况下，Files 类的所有方法都使用 UTF-8 来读取或写入字符。</p>\n<p>处理一般大小文本文件时，通常最简单方法是将文件内容作为一个字符串或者字符串列表进行处理。如果文件很大，或者是二进制文件，仍然可以使用熟悉的 stream 类或者 reader/writer 类。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">InputStream in = Files.newInputStream(path);</span><br><span class=\"line\">OutputStream out = Files.newOutPutStream(path);</span><br><span class=\"line\">Reader reader = Files.newBufferedReader(path);</span><br><span class=\"line\">Writer writer = Files.newBufferedWriter(path);</span><br></pre></td></tr></table></figure>\n<p>这些方便的方法可以帮你省去处理 FileInputStream、FileOutputStream、BufferedReader 或者 BufferedWriter 时的工作。</p>\n<p>如果希望将一个 InputStream 中的内容保存到一个文件中，可以使用</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Files.copy(in, path);</span><br></pre></td></tr></table></figure>\n<p>相反，可以将某个文件内容复制到一个 OutputStream 中。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Files.copy(path, out);</span><br></pre></td></tr></table></figure>\n<h4 id=\"创建文件和目录\"><a href=\"#创建文件和目录\" class=\"headerlink\" title=\"创建文件和目录\"></a>创建文件和目录</h4><p>创建目录                </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Files.createDirectories(path);</span><br></pre></td></tr></table></figure>\n<p>创建空文件</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Files.createFile(path);</span><br></pre></td></tr></table></figure>\n<p>文件已经存在会抛异常，对已有文件的检查和创建都属于原子操作，所以如果文件不存在，那么它一定会在其他线程之前创建该文件。</p>\n<h4 id=\"复制、移动和删除文件\"><a href=\"#复制、移动和删除文件\" class=\"headerlink\" title=\"复制、移动和删除文件\"></a>复制、移动和删除文件</h4><p>复制</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Files.copy(fromPath, toPath);</span><br></pre></td></tr></table></figure>\n<p>移动</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Files.move(fromPath, toPath);</span><br></pre></td></tr></table></figure>\n<p>如果目标文件或目录存在，copy 或 move 方法会失败。如果希望覆盖目标文件，使用 REPLACE_EXISTING 选项。如果希望复制所有文件属性，使用 COPY_ATTRIBUTES 选项，也可同时提供这两个选项：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Files.copy(fromPath, toPath, StandardCopyOption.REPLACE_EXISTING, StandardCopyOption.COPY_ATTRIBUTES);</span><br></pre></td></tr></table></figure>\n<p>可指定使用原子方式来执行移动，这样要么移动操作成功完成，要么源文件依然存在：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Files.move(fromPath, toPath, StandardCopyOption.ATOMIC_MOVE);</span><br></pre></td></tr></table></figure>\n<p>删除</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Files.delete(path);</span><br></pre></td></tr></table></figure>\n<p>如果文件不存在会抛异常，可能希望使用另一个方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">boolean</span> deleted = Files.deleteIfExists(path);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">没有直接删除或复制非空目录的方法。要实现请参考 FileVisitor 接口的API文档。</span><br></pre></td></tr></table></figure>\n<h2 id=\"equals、hashcode、和-compareTo-方法\"><a href=\"#equals、hashcode、和-compareTo-方法\" class=\"headerlink\" title=\"equals、hashcode、和 compareTo 方法\"></a>equals、hashcode、和 compareTo 方法</h2><h3 id=\"安全的-Null-值相等测试\"><a href=\"#安全的-Null-值相等测试\" class=\"headerlink\" title=\"安全的 Null 值相等测试\"></a>安全的 Null 值相等测试</h3><p>假设需要为下面的类实现 equals 方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> String first;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> String last;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>首先，你不得不将参数转换为一个 Person 对象：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object otherObject)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (<span class=\"keyword\">this</span> == otherObject) <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (otherObject == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.getClass() != otherObject.getClass()) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">\tPerson other = (Person) otherObject;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Java7出现后，再不用担心 first 或者 last 可能为空，只需调用</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">return</span> Obejcts.equals(a, b);</span><br></pre></td></tr></table></figure>\n<p>如果 a 和 b 都是 null，则返回 true；如果只有 a 为 null，则返回 false；其他情况则返回 a.equals(b)。</p>\n<h3 id=\"计算哈希码\"><a href=\"#计算哈希码\" class=\"headerlink\" title=\"计算哈希码\"></a>计算哈希码</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">return</span> Objects.hash(first, last);</span><br></pre></td></tr></table></figure>\n<p>Objects.hash 只是会调用从 Java5 开始就存在的 Arrays.hash 方法。但他不是一个支持可变参数的方法。</p>\n<h3 id=\"toString-NaN\"><a href=\"#toString-NaN\" class=\"headerlink\" title=\"toString()\"></a>toString()</h3><p>String.valueOf(obj)，可以安全处理 null 对象。如果 obj 为 null，会返回字符串 “null”。如果不喜欢这种方式，可以调用 Objects.toString 方法，并提供一个用于 null 对象的值。例如，Objects.toString(obj, “”);</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Returns the result of calling &#123;<span class=\"doctag\">@code</span> toString&#125; on the first</span></span><br><span class=\"line\"><span class=\"comment\"> * argument if the first argument is not &#123;<span class=\"doctag\">@code</span> null&#125; and returns</span></span><br><span class=\"line\"><span class=\"comment\"> * the second argument otherwise.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> o an object</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> nullDefault string to return if the first argument is</span></span><br><span class=\"line\"><span class=\"comment\"> *        &#123;<span class=\"doctag\">@code</span> null&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> the result of calling &#123;<span class=\"doctag\">@code</span> toString&#125; on the first</span></span><br><span class=\"line\"><span class=\"comment\"> * argument if it is not &#123;<span class=\"doctag\">@code</span> null&#125; and the second argument</span></span><br><span class=\"line\"><span class=\"comment\"> * otherwise.</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@see</span> Objects#toString(Object)</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title\">toString</span><span class=\"params\">(Object o, String nullDefault)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (o != <span class=\"keyword\">null</span>) ? o.toString() : nullDefault;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"比较数值类型对象\"><a href=\"#比较数值类型对象\" class=\"headerlink\" title=\"比较数值类型对象\"></a>比较数值类型对象</h3><p>使用静态方法 Integer.compare </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> diff = Integer.compare(x, other.x);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (diff != <span class=\"number\">0</span>) <span class=\"keyword\">return</span> diff;</span><br><span class=\"line\"><span class=\"keyword\">return</span> Integer.compare(y, other.y);</span><br></pre></td></tr></table></figure>\n<p>过去某些开发人员会使用 new Integer(x).compareTo(other.x)的方式，但这会创建两个会自动装箱/拆箱的整形对象。相比之下，静态方法 compare 使用的是 int 参数。</p>\n<p>此外，Long、Short、Byte、和 Boolean 也都提供了各自的静态方法 compare。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Double 和 Float 中的静态方法 compare 从 Java1.2 开始就存在了。</span><br></pre></td></tr></table></figure>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><h3 id=\"字符串转数字\"><a href=\"#字符串转数字\" class=\"headerlink\" title=\"字符串转数字\"></a>字符串转数字</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">double</span> x = Double.parseDouble(<span class=\"string\">\"+1.0\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">int</span> n = Integer.parseInt(<span class=\"string\">\"+1\"</span>);</span><br></pre></td></tr></table></figure>\n<p>在 Java7 之前，+1 一直不是一个有效整数。</p>\n<p>现在这个问题已经在所有通过字符串来构造 int、long、short、byte 和 BigInteger 的方法中被修复了，还包括包装类、处理十六进制和八进制数输入的 decode 方法，一级生成包装类对象的 valueOf 方法。BigInteger(String) 也被修复了。</p>\n<h3 id=\"全局-Logger\"><a href=\"#全局-Logger\" class=\"headerlink\" title=\"全局 Logger\"></a>全局 Logger</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Logger <span class=\"title\">getGlobal</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// In order to break a cyclic dependence between the LogManager</span></span><br><span class=\"line\">    <span class=\"comment\">// and Logger static initializers causing deadlocks, the global</span></span><br><span class=\"line\">    <span class=\"comment\">// logger is created with a special constructor that does not</span></span><br><span class=\"line\">    <span class=\"comment\">// initialize its log manager.</span></span><br><span class=\"line\">    <span class=\"comment\">//</span></span><br><span class=\"line\">    <span class=\"comment\">// If an application calls Logger.getGlobal() before any logger</span></span><br><span class=\"line\">    <span class=\"comment\">// has been initialized, it is therefore possible that the</span></span><br><span class=\"line\">    <span class=\"comment\">// LogManager class has not been initialized yet, and therefore</span></span><br><span class=\"line\">    <span class=\"comment\">// Logger.global.manager will be null.</span></span><br><span class=\"line\">    <span class=\"comment\">//</span></span><br><span class=\"line\">    <span class=\"comment\">// In order to finish the initialization of the global logger, we</span></span><br><span class=\"line\">    <span class=\"comment\">// will therefore call LogManager.getLogManager() here.</span></span><br><span class=\"line\">    <span class=\"comment\">//</span></span><br><span class=\"line\">    <span class=\"comment\">// To prevent race conditions we also need to call</span></span><br><span class=\"line\">    <span class=\"comment\">// LogManager.getLogManager() unconditionally here.</span></span><br><span class=\"line\">    <span class=\"comment\">// Indeed we cannot rely on the observed value of global.manager,</span></span><br><span class=\"line\">    <span class=\"comment\">// because global.manager will become not null somewhere during</span></span><br><span class=\"line\">    <span class=\"comment\">// the initialization of LogManager.</span></span><br><span class=\"line\">    <span class=\"comment\">// If two threads are calling getGlobal() concurrently, one thread</span></span><br><span class=\"line\">    <span class=\"comment\">// will see global.manager null and call LogManager.getLogManager(),</span></span><br><span class=\"line\">    <span class=\"comment\">// but the other thread could come in at a time when global.manager</span></span><br><span class=\"line\">    <span class=\"comment\">// is already set although ensureLogManagerInitialized is not finished</span></span><br><span class=\"line\">    <span class=\"comment\">// yet...</span></span><br><span class=\"line\">    <span class=\"comment\">// Calling LogManager.getLogManager() unconditionally will fix that.</span></span><br><span class=\"line\"></span><br><span class=\"line\">    LogManager.getLogManager();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Now the global LogManager should be initialized,</span></span><br><span class=\"line\">    <span class=\"comment\">// and the global logger should have been added to</span></span><br><span class=\"line\">    <span class=\"comment\">// it, unless we were called within the constructor of a LogManager</span></span><br><span class=\"line\">    <span class=\"comment\">// subclass installed as LogManager, in which case global.manager</span></span><br><span class=\"line\">    <span class=\"comment\">// would still be null, and global will be lazily initialized later on.</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> global;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Null-检查\"><a href=\"#Null-检查\" class=\"headerlink\" title=\"Null 检查\"></a>Null 检查</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Checks that the specified object reference is not &#123;<span class=\"doctag\">@code</span> null&#125;. This</span></span><br><span class=\"line\"><span class=\"comment\"> * method is designed primarily for doing parameter validation in methods</span></span><br><span class=\"line\"><span class=\"comment\"> * and constructors, as demonstrated below:</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;blockquote&gt;&lt;pre&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * public Foo(Bar bar) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     this.bar = Objects.requireNonNull(bar);</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;/pre&gt;&lt;/blockquote&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> obj the object reference to check for nullity</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> &lt;T&gt; the type of the reference</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> &#123;<span class=\"doctag\">@code</span> obj&#125; if not &#123;<span class=\"doctag\">@code</span> null&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@throws</span> NullPointerException if &#123;<span class=\"doctag\">@code</span> obj&#125; is &#123;<span class=\"doctag\">@code</span> null&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; <span class=\"function\">T <span class=\"title\">requireNonNull</span><span class=\"params\">(T obj)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (obj == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> obj;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Checks that the specified object reference is not &#123;<span class=\"doctag\">@code</span> null&#125; and</span></span><br><span class=\"line\"><span class=\"comment\"> * throws a customized &#123;<span class=\"doctag\">@link</span> NullPointerException&#125; if it is. This method</span></span><br><span class=\"line\"><span class=\"comment\"> * is designed primarily for doing parameter validation in methods and</span></span><br><span class=\"line\"><span class=\"comment\"> * constructors with multiple parameters, as demonstrated below:</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;blockquote&gt;&lt;pre&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * public Foo(Bar bar, Baz baz) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     this.bar = Objects.requireNonNull(bar, \"bar must not be null\");</span></span><br><span class=\"line\"><span class=\"comment\"> *     this.baz = Objects.requireNonNull(baz, \"baz must not be null\");</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;/pre&gt;&lt;/blockquote&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> obj     the object reference to check for nullity</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> message detail message to be used in the event that a &#123;<span class=\"doctag\">@code</span></span></span><br><span class=\"line\"><span class=\"comment\"> *                NullPointerException&#125; is thrown</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> &lt;T&gt; the type of the reference</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> &#123;<span class=\"doctag\">@code</span> obj&#125; if not &#123;<span class=\"doctag\">@code</span> null&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@throws</span> NullPointerException if &#123;<span class=\"doctag\">@code</span> obj&#125; is &#123;<span class=\"doctag\">@code</span> null&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; <span class=\"function\">T <span class=\"title\">requireNonNull</span><span class=\"params\">(T obj, String message)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (obj == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException(message);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> obj;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"ProcessBuilder\"><a href=\"#ProcessBuilder\" class=\"headerlink\" title=\"ProcessBuilder\"></a>ProcessBuilder</h3><p>Java5 之前，Runtime.exec 方法是在 Java 中执行一个外部命令的唯一方式。Java5 添加了 ProcessBuilder 类，加强了对 OS 进程的控制，尤其是通过 ProcessBuilder，你可以改变工作目录。</p>\n<p>Java7 添加了一些新方法，使得开发人员能方便地将进程的标准输入、输出及错误重定向到文件中。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> Redirect <span class=\"title\">redirectInput</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> (redirects == <span class=\"keyword\">null</span>) ? Redirect.PIPE : redirects[<span class=\"number\">0</span>];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> Redirect <span class=\"title\">redirectOutput</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> (redirects == <span class=\"keyword\">null</span>) ? Redirect.PIPE : redirects[<span class=\"number\">1</span>];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> ProcessBuilder <span class=\"title\">redirectInput</span><span class=\"params\">(File file)</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> redirectInput(Redirect.from(file));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> ProcessBuilder <span class=\"title\">redirectOutput</span><span class=\"params\">(File file)</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> redirectOutput(Redirect.to(file));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> Redirect <span class=\"title\">redirectError</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> (redirects == <span class=\"keyword\">null</span>) ? Redirect.PIPE : redirects[<span class=\"number\">2</span>];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> ProcessBuilder <span class=\"title\">redirectError</span><span class=\"params\">(File file)</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> redirectError(Redirect.to(file));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<h3 id=\"URLClassLoader\"><a href=\"#URLClassLoader\" class=\"headerlink\" title=\"URLClassLoader\"></a>URLClassLoader</h3><p>Java7 只是添加了一个用来关闭该类加载器的 close 方法，URLClassLoader 类现在实现了 AutoCloseable 接口，因此可使用 try-with-resources 语句来避免可能出现的资源泄露。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">URLClassLoader</span> <span class=\"keyword\">extends</span> <span class=\"title\">SecureClassLoader</span> <span class=\"keyword\">implements</span> <span class=\"title\">Closeable</span> </span>&#123;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"BitSet\"><a href=\"#BitSet\" class=\"headerlink\" title=\"BitSet\"></a>BitSet</h3><p>BitSet 是一个表示 bit 序列的整数集合。该集合可以根据整数 i 来设置第 i 个 bit 位的值。这使得集合操作非常搞笑。求并集、交集、补集只不过是简单的按位或、与、非运算。</p>\n<p>Java7 添加了一些构造 BitSet 的方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> BitSet <span class=\"title\">valueOf</span><span class=\"params\">(<span class=\"keyword\">byte</span>[] bytes)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> BitSet.valueOf(ByteBuffer.wrap(bytes));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> BitSet <span class=\"title\">valueOf</span><span class=\"params\">(ByteBuffer bb)</span> </span>&#123;</span><br><span class=\"line\">    bb = bb.slice().order(ByteOrder.LITTLE_ENDIAN);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (n = bb.remaining(); n &gt; <span class=\"number\">0</span> &amp;&amp; bb.get(n - <span class=\"number\">1</span>) == <span class=\"number\">0</span>; n--)</span><br><span class=\"line\">        ;</span><br><span class=\"line\">    <span class=\"keyword\">long</span>[] words = <span class=\"keyword\">new</span> <span class=\"keyword\">long</span>[(n + <span class=\"number\">7</span>) / <span class=\"number\">8</span>];</span><br><span class=\"line\">    bb.limit(n);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (bb.remaining() &gt;= <span class=\"number\">8</span>)</span><br><span class=\"line\">        words[i++] = bb.getLong();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> remaining = bb.remaining(), j = <span class=\"number\">0</span>; j &lt; remaining; j++)</span><br><span class=\"line\">        words[i] |= (bb.get() &amp; <span class=\"number\">0xffL</span>) &lt;&lt; (<span class=\"number\">8</span> * j);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> BitSet(words);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> BitSet <span class=\"title\">valueOf</span><span class=\"params\">(<span class=\"keyword\">long</span>[] longs)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (n = longs.length; n &gt; <span class=\"number\">0</span> &amp;&amp; longs[n - <span class=\"number\">1</span>] == <span class=\"number\">0</span>; n--)</span><br><span class=\"line\">        ;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> BitSet(Arrays.copyOf(longs, n));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> BitSet <span class=\"title\">valueOf</span><span class=\"params\">(LongBuffer lb)</span> </span>&#123;</span><br><span class=\"line\">    lb = lb.slice();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (n = lb.remaining(); n &gt; <span class=\"number\">0</span> &amp;&amp; lb.get(n - <span class=\"number\">1</span>) == <span class=\"number\">0</span>; n--)</span><br><span class=\"line\">        ;</span><br><span class=\"line\">    <span class=\"keyword\">long</span>[] words = <span class=\"keyword\">new</span> <span class=\"keyword\">long</span>[n];</span><br><span class=\"line\">    lb.get(words);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> BitSet(words);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","excerpt":"","more":"<h1 id=\"可能错过的Java7特性\"><a href=\"#可能错过的Java7特性\" class=\"headerlink\" title=\"可能错过的Java7特性\"></a>可能错过的Java7特性</h1><ul>\n<li>异常改进</li>\n<li>文件IO</li>\n<li>equals、hashCode和CompareTo方法</li>\n<li>其他</li>\n</ul>\n<h2 id=\"异常改进\"><a href=\"#异常改进\" class=\"headerlink\" title=\"异常改进\"></a>异常改进</h2><h3 id=\"try-with-resources\"><a href=\"#try-with-resources\" class=\"headerlink\" title=\"try-with-resources\"></a>try-with-resources</h3><p>Java7 提供了一个简单实用的代码格式</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">打开一个资源</span><br><span class=\"line\"><span class=\"keyword\">try</span>\t&#123;</span><br><span class=\"line\">\t实用该资源</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">\t关闭该资源</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其中资源所属类必须实现了 AutoCloseable 接口。</p>\n<p>void close() throws Exception</p>\n<p>try-with-resources 语句最简形式如下</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> (Resource res = ...) &#123;</span><br><span class=\"line\">\t使用 res</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当 try 语句块退出时，会自动调用 res.close() 方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> (Scanner in = <span class=\"keyword\">new</span> Scanner(Paths.get(File.separator, <span class=\"string\">\"data\"</span>, <span class=\"string\">\"word\"</span>))) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (in.hasNext()) &#123;                                                 </span><br><span class=\"line\">        System.out.println(in.next());                                     </span><br><span class=\"line\">    &#125;                                                                      </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当代码块像往常一样退出或发生异常时，都会调用 in.close() 方法，就如同你之前使用 finally 一样。</p>\n<h3 id=\"忽略异常\"><a href=\"#忽略异常\" class=\"headerlink\" title=\"忽略异常\"></a>忽略异常</h3><p>无论何时使用输入或输出，在异常产生后如何关闭资源都是一个麻烦的问题。假设产生了一个 IOException ，接下来关闭资源事， close 方法又抛出了另一个异常。</p>\n<p>实际在Java中，finally分支中抛出的异常会丢弃掉之前的异常。</p>\n<p>try-with-resources 修正了这个行为。当 AutoCloseable 的 close 方法抛出异常时，原来的异常会被重新抛出，而调用 close 方法产生的异常会被捕获，并被标注为“被忽略”的异常。</p>\n<h3 id=\"捕获多个异常\"><a href=\"#捕获多个异常\" class=\"headerlink\" title=\"捕获多个异常\"></a>捕获多个异常</h3><p>假设多个异常的行为一致，允许将多个异常写在一个 catch 分支中：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (FileNotFoundException | UnknownHostException ex) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (IOException ex)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>只有当捕获的异常均不是其他异常的子类时，才能用这种方法。</p>\n<h3 id=\"ReflectiveOperationException\"><a href=\"#ReflectiveOperationException\" class=\"headerlink\" title=\"ReflectiveOperationException\"></a>ReflectiveOperationException</h3><p>在调用一个反射方法时，不得不捕获许多不相关的检查器异常。例如，创建一个类并调用它的 main 方法：</p>\n<p>Class.forName(className).getMethod(“main”).invoke(null, new String[]{});</p>\n<p>该语句可能会导致一个 ClassNotFoundException、NoSuchMethodException、IllegalAccessException 或者 InvocationTargetException。</p>\n<p>Java7 修复了这一设计上的缺陷，引入了一个新的父类 ReflectiveOperationException, 这样就可以通过这一个异常来捕获其他所有子异常。</p>\n<h2 id=\"使用文件\"><a href=\"#使用文件\" class=\"headerlink\" title=\"使用文件\"></a>使用文件</h2><p>文件处理上，Java7 的 Path 接口取代了 File 类。</p>\n<h3 id=\"Path-Paths\"><a href=\"#Path-Paths\" class=\"headerlink\" title=\"Path Paths\"></a>Path Paths</h3><h3 id=\"Files\"><a href=\"#Files\" class=\"headerlink\" title=\"Files\"></a>Files</h3><p>Files 类可以快速实现一些常用的文件 IO 操作，比之前的读写文件编码简洁太多。例如：</p>\n<h4 id=\"读写文件\"><a href=\"#读写文件\" class=\"headerlink\" title=\"读写文件\"></a>读写文件</h4><p>读取一个文件全部内容</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">byte</span>[] bytes = Files.readAllBytes(path);</span><br></pre></td></tr></table></figure>\n<p>将文件内容读取为一个字符串</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String content = <span class=\"keyword\">new</span> String(bytes, StandardCharsets.UTF_8);</span><br></pre></td></tr></table></figure>\n<p>按行读取文件</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;String&gt; lines = Files.readAllLines(path);</span><br></pre></td></tr></table></figure>\n<p>将字符串写入文件</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Files.write(path, <span class=\"string\">\"content\"</span>.getBytes(StandardCharsets.UTF_8));</span><br></pre></td></tr></table></figure>\n<p>按行来写入文件</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;String&gt; lines = Arrays.asList(<span class=\"string\">\"abc\"</span>, <span class=\"string\">\"xyz\"</span>);</span><br><span class=\"line\">Files.write(path, lines);</span><br></pre></td></tr></table></figure>\n<p>将内容追加到文件</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;String&gt; lines = Arrays.asList(<span class=\"string\">\"abc\"</span>, <span class=\"string\">\"xyz\"</span>);</span><br><span class=\"line\">Files.write(path, lines, StandardOpenOption.APPEND);</span><br></pre></td></tr></table></figure>\n<p>默认情况下，Files 类的所有方法都使用 UTF-8 来读取或写入字符。</p>\n<p>处理一般大小文本文件时，通常最简单方法是将文件内容作为一个字符串或者字符串列表进行处理。如果文件很大，或者是二进制文件，仍然可以使用熟悉的 stream 类或者 reader/writer 类。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">InputStream in = Files.newInputStream(path);</span><br><span class=\"line\">OutputStream out = Files.newOutPutStream(path);</span><br><span class=\"line\">Reader reader = Files.newBufferedReader(path);</span><br><span class=\"line\">Writer writer = Files.newBufferedWriter(path);</span><br></pre></td></tr></table></figure>\n<p>这些方便的方法可以帮你省去处理 FileInputStream、FileOutputStream、BufferedReader 或者 BufferedWriter 时的工作。</p>\n<p>如果希望将一个 InputStream 中的内容保存到一个文件中，可以使用</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Files.copy(in, path);</span><br></pre></td></tr></table></figure>\n<p>相反，可以将某个文件内容复制到一个 OutputStream 中。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Files.copy(path, out);</span><br></pre></td></tr></table></figure>\n<h4 id=\"创建文件和目录\"><a href=\"#创建文件和目录\" class=\"headerlink\" title=\"创建文件和目录\"></a>创建文件和目录</h4><p>创建目录                </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Files.createDirectories(path);</span><br></pre></td></tr></table></figure>\n<p>创建空文件</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Files.createFile(path);</span><br></pre></td></tr></table></figure>\n<p>文件已经存在会抛异常，对已有文件的检查和创建都属于原子操作，所以如果文件不存在，那么它一定会在其他线程之前创建该文件。</p>\n<h4 id=\"复制、移动和删除文件\"><a href=\"#复制、移动和删除文件\" class=\"headerlink\" title=\"复制、移动和删除文件\"></a>复制、移动和删除文件</h4><p>复制</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Files.copy(fromPath, toPath);</span><br></pre></td></tr></table></figure>\n<p>移动</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Files.move(fromPath, toPath);</span><br></pre></td></tr></table></figure>\n<p>如果目标文件或目录存在，copy 或 move 方法会失败。如果希望覆盖目标文件，使用 REPLACE_EXISTING 选项。如果希望复制所有文件属性，使用 COPY_ATTRIBUTES 选项，也可同时提供这两个选项：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Files.copy(fromPath, toPath, StandardCopyOption.REPLACE_EXISTING, StandardCopyOption.COPY_ATTRIBUTES);</span><br></pre></td></tr></table></figure>\n<p>可指定使用原子方式来执行移动，这样要么移动操作成功完成，要么源文件依然存在：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Files.move(fromPath, toPath, StandardCopyOption.ATOMIC_MOVE);</span><br></pre></td></tr></table></figure>\n<p>删除</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Files.delete(path);</span><br></pre></td></tr></table></figure>\n<p>如果文件不存在会抛异常，可能希望使用另一个方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">boolean</span> deleted = Files.deleteIfExists(path);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">没有直接删除或复制非空目录的方法。要实现请参考 FileVisitor 接口的API文档。</span><br></pre></td></tr></table></figure>\n<h2 id=\"equals、hashcode、和-compareTo-方法\"><a href=\"#equals、hashcode、和-compareTo-方法\" class=\"headerlink\" title=\"equals、hashcode、和 compareTo 方法\"></a>equals、hashcode、和 compareTo 方法</h2><h3 id=\"安全的-Null-值相等测试\"><a href=\"#安全的-Null-值相等测试\" class=\"headerlink\" title=\"安全的 Null 值相等测试\"></a>安全的 Null 值相等测试</h3><p>假设需要为下面的类实现 equals 方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> String first;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> String last;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>首先，你不得不将参数转换为一个 Person 对象：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object otherObject)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (<span class=\"keyword\">this</span> == otherObject) <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (otherObject == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.getClass() != otherObject.getClass()) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">\tPerson other = (Person) otherObject;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Java7出现后，再不用担心 first 或者 last 可能为空，只需调用</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">return</span> Obejcts.equals(a, b);</span><br></pre></td></tr></table></figure>\n<p>如果 a 和 b 都是 null，则返回 true；如果只有 a 为 null，则返回 false；其他情况则返回 a.equals(b)。</p>\n<h3 id=\"计算哈希码\"><a href=\"#计算哈希码\" class=\"headerlink\" title=\"计算哈希码\"></a>计算哈希码</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">return</span> Objects.hash(first, last);</span><br></pre></td></tr></table></figure>\n<p>Objects.hash 只是会调用从 Java5 开始就存在的 Arrays.hash 方法。但他不是一个支持可变参数的方法。</p>\n<h3 id=\"toString-NaN\"><a href=\"#toString-NaN\" class=\"headerlink\" title=\"toString()\"></a>toString()</h3><p>String.valueOf(obj)，可以安全处理 null 对象。如果 obj 为 null，会返回字符串 “null”。如果不喜欢这种方式，可以调用 Objects.toString 方法，并提供一个用于 null 对象的值。例如，Objects.toString(obj, “”);</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Returns the result of calling &#123;<span class=\"doctag\">@code</span> toString&#125; on the first</span></span><br><span class=\"line\"><span class=\"comment\"> * argument if the first argument is not &#123;<span class=\"doctag\">@code</span> null&#125; and returns</span></span><br><span class=\"line\"><span class=\"comment\"> * the second argument otherwise.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> o an object</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> nullDefault string to return if the first argument is</span></span><br><span class=\"line\"><span class=\"comment\"> *        &#123;<span class=\"doctag\">@code</span> null&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> the result of calling &#123;<span class=\"doctag\">@code</span> toString&#125; on the first</span></span><br><span class=\"line\"><span class=\"comment\"> * argument if it is not &#123;<span class=\"doctag\">@code</span> null&#125; and the second argument</span></span><br><span class=\"line\"><span class=\"comment\"> * otherwise.</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@see</span> Objects#toString(Object)</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title\">toString</span><span class=\"params\">(Object o, String nullDefault)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (o != <span class=\"keyword\">null</span>) ? o.toString() : nullDefault;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"比较数值类型对象\"><a href=\"#比较数值类型对象\" class=\"headerlink\" title=\"比较数值类型对象\"></a>比较数值类型对象</h3><p>使用静态方法 Integer.compare </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> diff = Integer.compare(x, other.x);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (diff != <span class=\"number\">0</span>) <span class=\"keyword\">return</span> diff;</span><br><span class=\"line\"><span class=\"keyword\">return</span> Integer.compare(y, other.y);</span><br></pre></td></tr></table></figure>\n<p>过去某些开发人员会使用 new Integer(x).compareTo(other.x)的方式，但这会创建两个会自动装箱/拆箱的整形对象。相比之下，静态方法 compare 使用的是 int 参数。</p>\n<p>此外，Long、Short、Byte、和 Boolean 也都提供了各自的静态方法 compare。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Double 和 Float 中的静态方法 compare 从 Java1.2 开始就存在了。</span><br></pre></td></tr></table></figure>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><h3 id=\"字符串转数字\"><a href=\"#字符串转数字\" class=\"headerlink\" title=\"字符串转数字\"></a>字符串转数字</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">double</span> x = Double.parseDouble(<span class=\"string\">\"+1.0\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">int</span> n = Integer.parseInt(<span class=\"string\">\"+1\"</span>);</span><br></pre></td></tr></table></figure>\n<p>在 Java7 之前，+1 一直不是一个有效整数。</p>\n<p>现在这个问题已经在所有通过字符串来构造 int、long、short、byte 和 BigInteger 的方法中被修复了，还包括包装类、处理十六进制和八进制数输入的 decode 方法，一级生成包装类对象的 valueOf 方法。BigInteger(String) 也被修复了。</p>\n<h3 id=\"全局-Logger\"><a href=\"#全局-Logger\" class=\"headerlink\" title=\"全局 Logger\"></a>全局 Logger</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Logger <span class=\"title\">getGlobal</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// In order to break a cyclic dependence between the LogManager</span></span><br><span class=\"line\">    <span class=\"comment\">// and Logger static initializers causing deadlocks, the global</span></span><br><span class=\"line\">    <span class=\"comment\">// logger is created with a special constructor that does not</span></span><br><span class=\"line\">    <span class=\"comment\">// initialize its log manager.</span></span><br><span class=\"line\">    <span class=\"comment\">//</span></span><br><span class=\"line\">    <span class=\"comment\">// If an application calls Logger.getGlobal() before any logger</span></span><br><span class=\"line\">    <span class=\"comment\">// has been initialized, it is therefore possible that the</span></span><br><span class=\"line\">    <span class=\"comment\">// LogManager class has not been initialized yet, and therefore</span></span><br><span class=\"line\">    <span class=\"comment\">// Logger.global.manager will be null.</span></span><br><span class=\"line\">    <span class=\"comment\">//</span></span><br><span class=\"line\">    <span class=\"comment\">// In order to finish the initialization of the global logger, we</span></span><br><span class=\"line\">    <span class=\"comment\">// will therefore call LogManager.getLogManager() here.</span></span><br><span class=\"line\">    <span class=\"comment\">//</span></span><br><span class=\"line\">    <span class=\"comment\">// To prevent race conditions we also need to call</span></span><br><span class=\"line\">    <span class=\"comment\">// LogManager.getLogManager() unconditionally here.</span></span><br><span class=\"line\">    <span class=\"comment\">// Indeed we cannot rely on the observed value of global.manager,</span></span><br><span class=\"line\">    <span class=\"comment\">// because global.manager will become not null somewhere during</span></span><br><span class=\"line\">    <span class=\"comment\">// the initialization of LogManager.</span></span><br><span class=\"line\">    <span class=\"comment\">// If two threads are calling getGlobal() concurrently, one thread</span></span><br><span class=\"line\">    <span class=\"comment\">// will see global.manager null and call LogManager.getLogManager(),</span></span><br><span class=\"line\">    <span class=\"comment\">// but the other thread could come in at a time when global.manager</span></span><br><span class=\"line\">    <span class=\"comment\">// is already set although ensureLogManagerInitialized is not finished</span></span><br><span class=\"line\">    <span class=\"comment\">// yet...</span></span><br><span class=\"line\">    <span class=\"comment\">// Calling LogManager.getLogManager() unconditionally will fix that.</span></span><br><span class=\"line\"></span><br><span class=\"line\">    LogManager.getLogManager();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Now the global LogManager should be initialized,</span></span><br><span class=\"line\">    <span class=\"comment\">// and the global logger should have been added to</span></span><br><span class=\"line\">    <span class=\"comment\">// it, unless we were called within the constructor of a LogManager</span></span><br><span class=\"line\">    <span class=\"comment\">// subclass installed as LogManager, in which case global.manager</span></span><br><span class=\"line\">    <span class=\"comment\">// would still be null, and global will be lazily initialized later on.</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> global;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Null-检查\"><a href=\"#Null-检查\" class=\"headerlink\" title=\"Null 检查\"></a>Null 检查</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Checks that the specified object reference is not &#123;<span class=\"doctag\">@code</span> null&#125;. This</span></span><br><span class=\"line\"><span class=\"comment\"> * method is designed primarily for doing parameter validation in methods</span></span><br><span class=\"line\"><span class=\"comment\"> * and constructors, as demonstrated below:</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;blockquote&gt;&lt;pre&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * public Foo(Bar bar) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     this.bar = Objects.requireNonNull(bar);</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;/pre&gt;&lt;/blockquote&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> obj the object reference to check for nullity</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> &lt;T&gt; the type of the reference</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> &#123;<span class=\"doctag\">@code</span> obj&#125; if not &#123;<span class=\"doctag\">@code</span> null&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@throws</span> NullPointerException if &#123;<span class=\"doctag\">@code</span> obj&#125; is &#123;<span class=\"doctag\">@code</span> null&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; <span class=\"function\">T <span class=\"title\">requireNonNull</span><span class=\"params\">(T obj)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (obj == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> obj;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Checks that the specified object reference is not &#123;<span class=\"doctag\">@code</span> null&#125; and</span></span><br><span class=\"line\"><span class=\"comment\"> * throws a customized &#123;<span class=\"doctag\">@link</span> NullPointerException&#125; if it is. This method</span></span><br><span class=\"line\"><span class=\"comment\"> * is designed primarily for doing parameter validation in methods and</span></span><br><span class=\"line\"><span class=\"comment\"> * constructors with multiple parameters, as demonstrated below:</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;blockquote&gt;&lt;pre&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * public Foo(Bar bar, Baz baz) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     this.bar = Objects.requireNonNull(bar, \"bar must not be null\");</span></span><br><span class=\"line\"><span class=\"comment\"> *     this.baz = Objects.requireNonNull(baz, \"baz must not be null\");</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;/pre&gt;&lt;/blockquote&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> obj     the object reference to check for nullity</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> message detail message to be used in the event that a &#123;<span class=\"doctag\">@code</span></span></span><br><span class=\"line\"><span class=\"comment\"> *                NullPointerException&#125; is thrown</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> &lt;T&gt; the type of the reference</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> &#123;<span class=\"doctag\">@code</span> obj&#125; if not &#123;<span class=\"doctag\">@code</span> null&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@throws</span> NullPointerException if &#123;<span class=\"doctag\">@code</span> obj&#125; is &#123;<span class=\"doctag\">@code</span> null&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; <span class=\"function\">T <span class=\"title\">requireNonNull</span><span class=\"params\">(T obj, String message)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (obj == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException(message);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> obj;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"ProcessBuilder\"><a href=\"#ProcessBuilder\" class=\"headerlink\" title=\"ProcessBuilder\"></a>ProcessBuilder</h3><p>Java5 之前，Runtime.exec 方法是在 Java 中执行一个外部命令的唯一方式。Java5 添加了 ProcessBuilder 类，加强了对 OS 进程的控制，尤其是通过 ProcessBuilder，你可以改变工作目录。</p>\n<p>Java7 添加了一些新方法，使得开发人员能方便地将进程的标准输入、输出及错误重定向到文件中。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> Redirect <span class=\"title\">redirectInput</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> (redirects == <span class=\"keyword\">null</span>) ? Redirect.PIPE : redirects[<span class=\"number\">0</span>];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> Redirect <span class=\"title\">redirectOutput</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> (redirects == <span class=\"keyword\">null</span>) ? Redirect.PIPE : redirects[<span class=\"number\">1</span>];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> ProcessBuilder <span class=\"title\">redirectInput</span><span class=\"params\">(File file)</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> redirectInput(Redirect.from(file));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> ProcessBuilder <span class=\"title\">redirectOutput</span><span class=\"params\">(File file)</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> redirectOutput(Redirect.to(file));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> Redirect <span class=\"title\">redirectError</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> (redirects == <span class=\"keyword\">null</span>) ? Redirect.PIPE : redirects[<span class=\"number\">2</span>];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> ProcessBuilder <span class=\"title\">redirectError</span><span class=\"params\">(File file)</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> redirectError(Redirect.to(file));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<h3 id=\"URLClassLoader\"><a href=\"#URLClassLoader\" class=\"headerlink\" title=\"URLClassLoader\"></a>URLClassLoader</h3><p>Java7 只是添加了一个用来关闭该类加载器的 close 方法，URLClassLoader 类现在实现了 AutoCloseable 接口，因此可使用 try-with-resources 语句来避免可能出现的资源泄露。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">URLClassLoader</span> <span class=\"keyword\">extends</span> <span class=\"title\">SecureClassLoader</span> <span class=\"keyword\">implements</span> <span class=\"title\">Closeable</span> </span>&#123;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"BitSet\"><a href=\"#BitSet\" class=\"headerlink\" title=\"BitSet\"></a>BitSet</h3><p>BitSet 是一个表示 bit 序列的整数集合。该集合可以根据整数 i 来设置第 i 个 bit 位的值。这使得集合操作非常搞笑。求并集、交集、补集只不过是简单的按位或、与、非运算。</p>\n<p>Java7 添加了一些构造 BitSet 的方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> BitSet <span class=\"title\">valueOf</span><span class=\"params\">(<span class=\"keyword\">byte</span>[] bytes)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> BitSet.valueOf(ByteBuffer.wrap(bytes));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> BitSet <span class=\"title\">valueOf</span><span class=\"params\">(ByteBuffer bb)</span> </span>&#123;</span><br><span class=\"line\">    bb = bb.slice().order(ByteOrder.LITTLE_ENDIAN);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (n = bb.remaining(); n &gt; <span class=\"number\">0</span> &amp;&amp; bb.get(n - <span class=\"number\">1</span>) == <span class=\"number\">0</span>; n--)</span><br><span class=\"line\">        ;</span><br><span class=\"line\">    <span class=\"keyword\">long</span>[] words = <span class=\"keyword\">new</span> <span class=\"keyword\">long</span>[(n + <span class=\"number\">7</span>) / <span class=\"number\">8</span>];</span><br><span class=\"line\">    bb.limit(n);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (bb.remaining() &gt;= <span class=\"number\">8</span>)</span><br><span class=\"line\">        words[i++] = bb.getLong();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> remaining = bb.remaining(), j = <span class=\"number\">0</span>; j &lt; remaining; j++)</span><br><span class=\"line\">        words[i] |= (bb.get() &amp; <span class=\"number\">0xffL</span>) &lt;&lt; (<span class=\"number\">8</span> * j);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> BitSet(words);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> BitSet <span class=\"title\">valueOf</span><span class=\"params\">(<span class=\"keyword\">long</span>[] longs)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (n = longs.length; n &gt; <span class=\"number\">0</span> &amp;&amp; longs[n - <span class=\"number\">1</span>] == <span class=\"number\">0</span>; n--)</span><br><span class=\"line\">        ;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> BitSet(Arrays.copyOf(longs, n));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> BitSet <span class=\"title\">valueOf</span><span class=\"params\">(LongBuffer lb)</span> </span>&#123;</span><br><span class=\"line\">    lb = lb.slice();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (n = lb.remaining(); n &gt; <span class=\"number\">0</span> &amp;&amp; lb.get(n - <span class=\"number\">1</span>) == <span class=\"number\">0</span>; n--)</span><br><span class=\"line\">        ;</span><br><span class=\"line\">    <span class=\"keyword\">long</span>[] words = <span class=\"keyword\">new</span> <span class=\"keyword\">long</span>[n];</span><br><span class=\"line\">    lb.get(words);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> BitSet(words);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"Tomcat系统架构","date":"2016-05-21T16:00:00.000Z","_content":"\n#\tTomcat总体结构\nTomcat有2个核心组件：  \n*\tConnector  \n* \tContainer  \n\n其中Connector组件可以被替换，一个Container可以选择对用多个Connector。多个Connector和一个Container形成一个Service。有了Service就可以对外提供服务了。但Service需要一个生存环境，这时就非Server莫属了。所以整个Tomcat的生命周期由Server控制。\n\nConnector主要负责对外交流，Container主要处理Connector接受的请求，主要处理内部事务。其实，Service只是在Connector和Container外面多包一层，把它们组装在一起，对外提供服务。一个Service可以设置多个Connector，但只能有一个Container容器。\n\n##\tService\n\n![Service](http://o7s628cn2.bkt.clouddn.com/image/javaweb/Service.png)\n\n从org.apache.catalina.Service接口中定义方法可以看出，它主要是为了关联Connector和Container，同时会初始化其他组件。所有组件的生命周期在一个Lifecycle的接口中控制。\n\n![StandardService](http://o7s628cn2.bkt.clouddn.com/image/javaweb/StandardService.png)\n\n从StandardService类结构方法可以看出，除了Service接口方法的实现以及控制组件生命周期的Lifecycle接口的实现，还有几个方法用于实现时间监听方法。不仅是这个Service组件，在Tomcat中其他组件也同样有这个几个方法，这也是一个典型设计模式。\n\n下面看一下StandardService中几个主要方法，setContainer方法如下：\n\n```\tjava\npublic void setContainer(Container container) {\n\n        Container oldContainer = this.container;\n        if ((oldContainer != null) && (oldContainer instanceof Engine))\n            ((Engine) oldContainer).setService(null);\n        this.container = container;\n        if ((this.container != null) && (this.container instanceof Engine))\n            ((Engine) this.container).setService(this);\n        if (getState().isAvailable() && (this.container != null)) {\n            try {\n                this.container.start();\n            } catch (LifecycleException e) {\n                // Ignore\n            }\n        }\n        if (getState().isAvailable() && (oldContainer != null)) {\n            try {\n                oldContainer.stop();\n            } catch (LifecycleException e) {\n                // Ignore\n            }\n        }\n\n        // Report this property change to interested listeners\n        support.firePropertyChange(\"container\", oldContainer, this.container);\n\n    }\n```\n\n这段代码很简单，首先判断当前Service有没有已经关联的Container，如果已经关联，去除这个关联关系----((Engine) oldContainer).setService(null)。如果这个oldContainer已经启动了，结束它的生命周期，然后再替换新的。\n\nAddConnector方法如下：\n\n```\tjava\npublic void addConnector(Connector connector) {\n\n        synchronized (connectors) {\n            connector.setService(this);\n            Connector results[] = new Connector[connectors.length + 1];\n            System.arraycopy(connectors, 0, results, 0, connectors.length);\n            results[connectors.length] = connector;\n            connectors = results;\n\n            if (getState().isAvailable()) {\n                try {\n                    connector.start();\n                } catch (LifecycleException e) {\n                    log.error(sm.getString(\n                            \"standardService.connector.startFailed\",\n                            connector), e);\n                }\n            }\n\n            // Report this property change to interested listeners\n            support.firePropertyChange(\"connector\", null, connector);\n        }\n\n    }\n```\n\n首先设置关联关系，然后初始化，开始新的生命周期。Connector用的是数组，而不是List集合，从性能角度考虑可以理解。有趣的是这里用了数组但并没有一开始就分配一个固定大小的数组。\n\n##\tServer\nServer要完成的任务很简单，提供一个接口让其他程序能够访问到这个Service集合，同时要维护它所包含的所有Service生命周期，包括如何初始化、如何结束服务、如何找到别人要访问的Service。\n\nServer的类结构图如下：\n![Server](http://o7s628cn2.bkt.clouddn.com/image/javaweb/Server.png)\n\n它的标准实现类StandardServer实现了上面这些方法，同时也实现了Lifecycle、MbeanRegistration两个接口的所有方法。下面看一下StandardServer一个重要方法addService的实现：\n\n```\tjava\npublic void addService(Service service) {\n\n    service.setServer(this);\n\n    synchronized (services) {\n        Service results[] = new Service[services.length + 1];\n        System.arraycopy(services, 0, results, 0, services.length);\n        results[services.length] = service;\n        services = results;\n\n        if (getState().isAvailable()) {\n            try {\n                service.start();\n            } catch (LifecycleException e) {\n                // Ignore\n            }\n        }\n\n        // Report this property change to interested listeners\n        support.firePropertyChange(\"service\", null, service);\n    }\n\n}\n```\n\n从第一行就知道了Service和Server是相互关联的，Server也是和Service管理Connector一样管理它，也是将Service放在一个数组中。\n\n##\tLifecycle\n在Tomcat中组件的生命周期通过Lifecycle接口来控制，组件只要集成这个接口并实现其中方法就可以统一被拥有它的组件控制了。最高级的组件就是Server，而控制Server的是Startup，也就是启动和关闭Tomcat。Lifecycle接口方法的实现都在其他组件中，组件的生命周期由包含它的父组件控制，所以它的Start方法自然就是调用它下面组件的Start方法，Stop方法也是一样。\n\n```\tjava\nprotected void startInternal() throws LifecycleException {\n\n    fireLifecycleEvent(CONFIGURE_START_EVENT, null);\n    setState(LifecycleState.STARTING);\n\n    globalNamingResources.start();\n    \n    // Start our defined Services\n    synchronized (services) {\n        for (int i = 0; i < services.length; i++) {\n            services[i].start();\n        }\n    }\n}\n```\n```\tjava\nprotected void stopInternal() throws LifecycleException {\n\n    setState(LifecycleState.STOPPING);\n    fireLifecycleEvent(CONFIGURE_STOP_EVENT, null);\n    \n    // Stop our defined Services\n    for (int i = 0; i < services.length; i++) {\n        services[i].stop();\n    }\n\n    globalNamingResources.stop();\n    \n    stopAwait();\n}\n```\n监听的代码会包围Service组件的启动过程，但所有Service必须要实现Lifecycle接口，这样做会更加灵活。\n\n##\tConnector组件\n它的主要任务数负责接收浏览器发过来的TCP连接请求，创建一个Request和Response对象分别用于和请求端交换数据。然后会产生一个线程来处理这个请求并把产生的Request和Response对象传给处理这个请求的线程，处理这个请求的线程就是Container要做的事了。\n\n在Tomcat7中，Connector有3种选择：\t\n*\tBIO--Http11Protocol\n* \tNIO--Http11NioProtocol\n*  apr--Http11AprProtocol\n\n```\tjava\npublic Connector(String protocol) {\n    setProtocol(protocol);\n    // Instantiate protocol handler\n    try {\n        Class<?> clazz = Class.forName(protocolHandlerClassName);\n        this.protocolHandler = (ProtocolHandler) clazz.newInstance();\n    } catch (Exception e) {\n        log.error(sm.getString(\n                \"coyoteConnector.protocolHandlerInstantiationFailed\"), e);\n    }\n}\n```\n通过上述代码可以看出，Connector会根据我们在server.xml中配置的Connector类型来初始化。\n\n这里以常用的NIO来说明，找到Http11NioProtocol基类的start方法：\n\n```\tjava\npublic void start() throws Exception {\n    if (getLog().isInfoEnabled())\n        getLog().info(sm.getString(\"abstractProtocolHandler.start\",\n                getNameInternal()));\n    try {\n        endpoint.start();\n    } catch (Exception ex) {\n        getLog().error(sm.getString(\"abstractProtocolHandler.startError\",\n                getNameInternal()), ex);\n        throw ex;\n    }\n\n    // Start async timeout thread\n    asyncTimeout = new AsyncTimeout();\n    Thread timeoutThread = new Thread(asyncTimeout, getNameInternal() + \"-AsyncTimeout\");\n    timeoutThread.setPriority(endpoint.getThreadPriority());\n    timeoutThread.setDaemon(true);\n    timeoutThread.start();\n}\n```\nstart方法中调用endpoint.start()，找到对应方法，在NioEndpoint类中：\n\n```\tjava\npublic void startInternal() throws Exception {\n\n        if (!running) {\n            running = true;\n            paused = false;\n\n            processorCache = new SynchronizedStack<>(SynchronizedStack.DEFAULT_SIZE,\n                    socketProperties.getProcessorCache());\n            eventCache = new SynchronizedStack<>(SynchronizedStack.DEFAULT_SIZE,\n                            socketProperties.getEventCache());\n            nioChannels = new SynchronizedStack<>(SynchronizedStack.DEFAULT_SIZE,\n                    socketProperties.getBufferPool());\n\n            // Create worker collection\n            if ( getExecutor() == null ) {\n                createExecutor();\n            }\n\n            initializeConnectionLatch();\n\n            // Start poller threads\n            pollers = new Poller[getPollerThreadCount()];\n            for (int i=0; i<pollers.length; i++) {\n                pollers[i] = new Poller();\n                Thread pollerThread = new Thread(pollers[i], getName() + \"-ClientPoller-\"+i);\n                pollerThread.setPriority(threadPriority);\n                pollerThread.setDaemon(true);\n                pollerThread.start();\n            }\n\n            startAcceptorThreads();\n        }\n    }\n```\n\n当执行到startAcceptorThreads()时，就会进入等待请求的状态，知道一个新的请求到来才会激活它继续执行。\n","source":"_posts/Java Web/Tomcat的系统架构.md","raw":"---\ntitle: Tomcat系统架构\ndate: 2016-05-22\ncategories: Java Web\ntags: \n- Java\n- Tomcat\n---\n\n#\tTomcat总体结构\nTomcat有2个核心组件：  \n*\tConnector  \n* \tContainer  \n\n其中Connector组件可以被替换，一个Container可以选择对用多个Connector。多个Connector和一个Container形成一个Service。有了Service就可以对外提供服务了。但Service需要一个生存环境，这时就非Server莫属了。所以整个Tomcat的生命周期由Server控制。\n\nConnector主要负责对外交流，Container主要处理Connector接受的请求，主要处理内部事务。其实，Service只是在Connector和Container外面多包一层，把它们组装在一起，对外提供服务。一个Service可以设置多个Connector，但只能有一个Container容器。\n\n##\tService\n\n![Service](http://o7s628cn2.bkt.clouddn.com/image/javaweb/Service.png)\n\n从org.apache.catalina.Service接口中定义方法可以看出，它主要是为了关联Connector和Container，同时会初始化其他组件。所有组件的生命周期在一个Lifecycle的接口中控制。\n\n![StandardService](http://o7s628cn2.bkt.clouddn.com/image/javaweb/StandardService.png)\n\n从StandardService类结构方法可以看出，除了Service接口方法的实现以及控制组件生命周期的Lifecycle接口的实现，还有几个方法用于实现时间监听方法。不仅是这个Service组件，在Tomcat中其他组件也同样有这个几个方法，这也是一个典型设计模式。\n\n下面看一下StandardService中几个主要方法，setContainer方法如下：\n\n```\tjava\npublic void setContainer(Container container) {\n\n        Container oldContainer = this.container;\n        if ((oldContainer != null) && (oldContainer instanceof Engine))\n            ((Engine) oldContainer).setService(null);\n        this.container = container;\n        if ((this.container != null) && (this.container instanceof Engine))\n            ((Engine) this.container).setService(this);\n        if (getState().isAvailable() && (this.container != null)) {\n            try {\n                this.container.start();\n            } catch (LifecycleException e) {\n                // Ignore\n            }\n        }\n        if (getState().isAvailable() && (oldContainer != null)) {\n            try {\n                oldContainer.stop();\n            } catch (LifecycleException e) {\n                // Ignore\n            }\n        }\n\n        // Report this property change to interested listeners\n        support.firePropertyChange(\"container\", oldContainer, this.container);\n\n    }\n```\n\n这段代码很简单，首先判断当前Service有没有已经关联的Container，如果已经关联，去除这个关联关系----((Engine) oldContainer).setService(null)。如果这个oldContainer已经启动了，结束它的生命周期，然后再替换新的。\n\nAddConnector方法如下：\n\n```\tjava\npublic void addConnector(Connector connector) {\n\n        synchronized (connectors) {\n            connector.setService(this);\n            Connector results[] = new Connector[connectors.length + 1];\n            System.arraycopy(connectors, 0, results, 0, connectors.length);\n            results[connectors.length] = connector;\n            connectors = results;\n\n            if (getState().isAvailable()) {\n                try {\n                    connector.start();\n                } catch (LifecycleException e) {\n                    log.error(sm.getString(\n                            \"standardService.connector.startFailed\",\n                            connector), e);\n                }\n            }\n\n            // Report this property change to interested listeners\n            support.firePropertyChange(\"connector\", null, connector);\n        }\n\n    }\n```\n\n首先设置关联关系，然后初始化，开始新的生命周期。Connector用的是数组，而不是List集合，从性能角度考虑可以理解。有趣的是这里用了数组但并没有一开始就分配一个固定大小的数组。\n\n##\tServer\nServer要完成的任务很简单，提供一个接口让其他程序能够访问到这个Service集合，同时要维护它所包含的所有Service生命周期，包括如何初始化、如何结束服务、如何找到别人要访问的Service。\n\nServer的类结构图如下：\n![Server](http://o7s628cn2.bkt.clouddn.com/image/javaweb/Server.png)\n\n它的标准实现类StandardServer实现了上面这些方法，同时也实现了Lifecycle、MbeanRegistration两个接口的所有方法。下面看一下StandardServer一个重要方法addService的实现：\n\n```\tjava\npublic void addService(Service service) {\n\n    service.setServer(this);\n\n    synchronized (services) {\n        Service results[] = new Service[services.length + 1];\n        System.arraycopy(services, 0, results, 0, services.length);\n        results[services.length] = service;\n        services = results;\n\n        if (getState().isAvailable()) {\n            try {\n                service.start();\n            } catch (LifecycleException e) {\n                // Ignore\n            }\n        }\n\n        // Report this property change to interested listeners\n        support.firePropertyChange(\"service\", null, service);\n    }\n\n}\n```\n\n从第一行就知道了Service和Server是相互关联的，Server也是和Service管理Connector一样管理它，也是将Service放在一个数组中。\n\n##\tLifecycle\n在Tomcat中组件的生命周期通过Lifecycle接口来控制，组件只要集成这个接口并实现其中方法就可以统一被拥有它的组件控制了。最高级的组件就是Server，而控制Server的是Startup，也就是启动和关闭Tomcat。Lifecycle接口方法的实现都在其他组件中，组件的生命周期由包含它的父组件控制，所以它的Start方法自然就是调用它下面组件的Start方法，Stop方法也是一样。\n\n```\tjava\nprotected void startInternal() throws LifecycleException {\n\n    fireLifecycleEvent(CONFIGURE_START_EVENT, null);\n    setState(LifecycleState.STARTING);\n\n    globalNamingResources.start();\n    \n    // Start our defined Services\n    synchronized (services) {\n        for (int i = 0; i < services.length; i++) {\n            services[i].start();\n        }\n    }\n}\n```\n```\tjava\nprotected void stopInternal() throws LifecycleException {\n\n    setState(LifecycleState.STOPPING);\n    fireLifecycleEvent(CONFIGURE_STOP_EVENT, null);\n    \n    // Stop our defined Services\n    for (int i = 0; i < services.length; i++) {\n        services[i].stop();\n    }\n\n    globalNamingResources.stop();\n    \n    stopAwait();\n}\n```\n监听的代码会包围Service组件的启动过程，但所有Service必须要实现Lifecycle接口，这样做会更加灵活。\n\n##\tConnector组件\n它的主要任务数负责接收浏览器发过来的TCP连接请求，创建一个Request和Response对象分别用于和请求端交换数据。然后会产生一个线程来处理这个请求并把产生的Request和Response对象传给处理这个请求的线程，处理这个请求的线程就是Container要做的事了。\n\n在Tomcat7中，Connector有3种选择：\t\n*\tBIO--Http11Protocol\n* \tNIO--Http11NioProtocol\n*  apr--Http11AprProtocol\n\n```\tjava\npublic Connector(String protocol) {\n    setProtocol(protocol);\n    // Instantiate protocol handler\n    try {\n        Class<?> clazz = Class.forName(protocolHandlerClassName);\n        this.protocolHandler = (ProtocolHandler) clazz.newInstance();\n    } catch (Exception e) {\n        log.error(sm.getString(\n                \"coyoteConnector.protocolHandlerInstantiationFailed\"), e);\n    }\n}\n```\n通过上述代码可以看出，Connector会根据我们在server.xml中配置的Connector类型来初始化。\n\n这里以常用的NIO来说明，找到Http11NioProtocol基类的start方法：\n\n```\tjava\npublic void start() throws Exception {\n    if (getLog().isInfoEnabled())\n        getLog().info(sm.getString(\"abstractProtocolHandler.start\",\n                getNameInternal()));\n    try {\n        endpoint.start();\n    } catch (Exception ex) {\n        getLog().error(sm.getString(\"abstractProtocolHandler.startError\",\n                getNameInternal()), ex);\n        throw ex;\n    }\n\n    // Start async timeout thread\n    asyncTimeout = new AsyncTimeout();\n    Thread timeoutThread = new Thread(asyncTimeout, getNameInternal() + \"-AsyncTimeout\");\n    timeoutThread.setPriority(endpoint.getThreadPriority());\n    timeoutThread.setDaemon(true);\n    timeoutThread.start();\n}\n```\nstart方法中调用endpoint.start()，找到对应方法，在NioEndpoint类中：\n\n```\tjava\npublic void startInternal() throws Exception {\n\n        if (!running) {\n            running = true;\n            paused = false;\n\n            processorCache = new SynchronizedStack<>(SynchronizedStack.DEFAULT_SIZE,\n                    socketProperties.getProcessorCache());\n            eventCache = new SynchronizedStack<>(SynchronizedStack.DEFAULT_SIZE,\n                            socketProperties.getEventCache());\n            nioChannels = new SynchronizedStack<>(SynchronizedStack.DEFAULT_SIZE,\n                    socketProperties.getBufferPool());\n\n            // Create worker collection\n            if ( getExecutor() == null ) {\n                createExecutor();\n            }\n\n            initializeConnectionLatch();\n\n            // Start poller threads\n            pollers = new Poller[getPollerThreadCount()];\n            for (int i=0; i<pollers.length; i++) {\n                pollers[i] = new Poller();\n                Thread pollerThread = new Thread(pollers[i], getName() + \"-ClientPoller-\"+i);\n                pollerThread.setPriority(threadPriority);\n                pollerThread.setDaemon(true);\n                pollerThread.start();\n            }\n\n            startAcceptorThreads();\n        }\n    }\n```\n\n当执行到startAcceptorThreads()时，就会进入等待请求的状态，知道一个新的请求到来才会激活它继续执行。\n","slug":"Java Web/Tomcat的系统架构","published":1,"updated":"2019-05-17T05:57:58.556Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1j8f2ip001h7h9mta8ngz4i","content":"<h1 id=\"Tomcat总体结构\"><a href=\"#Tomcat总体结构\" class=\"headerlink\" title=\"Tomcat总体结构\"></a>Tomcat总体结构</h1><p>Tomcat有2个核心组件：  </p>\n<ul>\n<li>Connector  </li>\n<li>Container  </li>\n</ul>\n<p>其中Connector组件可以被替换，一个Container可以选择对用多个Connector。多个Connector和一个Container形成一个Service。有了Service就可以对外提供服务了。但Service需要一个生存环境，这时就非Server莫属了。所以整个Tomcat的生命周期由Server控制。</p>\n<p>Connector主要负责对外交流，Container主要处理Connector接受的请求，主要处理内部事务。其实，Service只是在Connector和Container外面多包一层，把它们组装在一起，对外提供服务。一个Service可以设置多个Connector，但只能有一个Container容器。</p>\n<h2 id=\"Service\"><a href=\"#Service\" class=\"headerlink\" title=\"Service\"></a>Service</h2><p><img src=\"http://o7s628cn2.bkt.clouddn.com/image/javaweb/Service.png\" alt=\"Service\"></p>\n<p>从org.apache.catalina.Service接口中定义方法可以看出，它主要是为了关联Connector和Container，同时会初始化其他组件。所有组件的生命周期在一个Lifecycle的接口中控制。</p>\n<p><img src=\"http://o7s628cn2.bkt.clouddn.com/image/javaweb/StandardService.png\" alt=\"StandardService\"></p>\n<p>从StandardService类结构方法可以看出，除了Service接口方法的实现以及控制组件生命周期的Lifecycle接口的实现，还有几个方法用于实现时间监听方法。不仅是这个Service组件，在Tomcat中其他组件也同样有这个几个方法，这也是一个典型设计模式。</p>\n<p>下面看一下StandardService中几个主要方法，setContainer方法如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setContainer</span><span class=\"params\">(Container container)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        Container oldContainer = <span class=\"keyword\">this</span>.container;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((oldContainer != <span class=\"keyword\">null</span>) &amp;&amp; (oldContainer <span class=\"keyword\">instanceof</span> Engine))</span><br><span class=\"line\">            ((Engine) oldContainer).setService(<span class=\"keyword\">null</span>);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.container = container;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((<span class=\"keyword\">this</span>.container != <span class=\"keyword\">null</span>) &amp;&amp; (<span class=\"keyword\">this</span>.container <span class=\"keyword\">instanceof</span> Engine))</span><br><span class=\"line\">            ((Engine) <span class=\"keyword\">this</span>.container).setService(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (getState().isAvailable() &amp;&amp; (<span class=\"keyword\">this</span>.container != <span class=\"keyword\">null</span>)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">this</span>.container.start();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (LifecycleException e) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// Ignore</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (getState().isAvailable() &amp;&amp; (oldContainer != <span class=\"keyword\">null</span>)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                oldContainer.stop();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (LifecycleException e) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// Ignore</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Report this property change to interested listeners</span></span><br><span class=\"line\">        support.firePropertyChange(<span class=\"string\">\"container\"</span>, oldContainer, <span class=\"keyword\">this</span>.container);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>这段代码很简单，首先判断当前Service有没有已经关联的Container，如果已经关联，去除这个关联关系—-((Engine) oldContainer).setService(null)。如果这个oldContainer已经启动了，结束它的生命周期，然后再替换新的。</p>\n<p>AddConnector方法如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addConnector</span><span class=\"params\">(Connector connector)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (connectors) &#123;</span><br><span class=\"line\">            connector.setService(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">            Connector results[] = <span class=\"keyword\">new</span> Connector[connectors.length + <span class=\"number\">1</span>];</span><br><span class=\"line\">            System.arraycopy(connectors, <span class=\"number\">0</span>, results, <span class=\"number\">0</span>, connectors.length);</span><br><span class=\"line\">            results[connectors.length] = connector;</span><br><span class=\"line\">            connectors = results;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (getState().isAvailable()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    connector.start();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (LifecycleException e) &#123;</span><br><span class=\"line\">                    log.error(sm.getString(</span><br><span class=\"line\">                            <span class=\"string\">\"standardService.connector.startFailed\"</span>,</span><br><span class=\"line\">                            connector), e);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// Report this property change to interested listeners</span></span><br><span class=\"line\">            support.firePropertyChange(<span class=\"string\">\"connector\"</span>, <span class=\"keyword\">null</span>, connector);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>首先设置关联关系，然后初始化，开始新的生命周期。Connector用的是数组，而不是List集合，从性能角度考虑可以理解。有趣的是这里用了数组但并没有一开始就分配一个固定大小的数组。</p>\n<h2 id=\"Server\"><a href=\"#Server\" class=\"headerlink\" title=\"Server\"></a>Server</h2><p>Server要完成的任务很简单，提供一个接口让其他程序能够访问到这个Service集合，同时要维护它所包含的所有Service生命周期，包括如何初始化、如何结束服务、如何找到别人要访问的Service。</p>\n<p>Server的类结构图如下：<br><img src=\"http://o7s628cn2.bkt.clouddn.com/image/javaweb/Server.png\" alt=\"Server\"></p>\n<p>它的标准实现类StandardServer实现了上面这些方法，同时也实现了Lifecycle、MbeanRegistration两个接口的所有方法。下面看一下StandardServer一个重要方法addService的实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addService</span><span class=\"params\">(Service service)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    service.setServer(<span class=\"keyword\">this</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (services) &#123;</span><br><span class=\"line\">        Service results[] = <span class=\"keyword\">new</span> Service[services.length + <span class=\"number\">1</span>];</span><br><span class=\"line\">        System.arraycopy(services, <span class=\"number\">0</span>, results, <span class=\"number\">0</span>, services.length);</span><br><span class=\"line\">        results[services.length] = service;</span><br><span class=\"line\">        services = results;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (getState().isAvailable()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                service.start();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (LifecycleException e) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// Ignore</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Report this property change to interested listeners</span></span><br><span class=\"line\">        support.firePropertyChange(<span class=\"string\">\"service\"</span>, <span class=\"keyword\">null</span>, service);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从第一行就知道了Service和Server是相互关联的，Server也是和Service管理Connector一样管理它，也是将Service放在一个数组中。</p>\n<h2 id=\"Lifecycle\"><a href=\"#Lifecycle\" class=\"headerlink\" title=\"Lifecycle\"></a>Lifecycle</h2><p>在Tomcat中组件的生命周期通过Lifecycle接口来控制，组件只要集成这个接口并实现其中方法就可以统一被拥有它的组件控制了。最高级的组件就是Server，而控制Server的是Startup，也就是启动和关闭Tomcat。Lifecycle接口方法的实现都在其他组件中，组件的生命周期由包含它的父组件控制，所以它的Start方法自然就是调用它下面组件的Start方法，Stop方法也是一样。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">startInternal</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> LifecycleException </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    fireLifecycleEvent(CONFIGURE_START_EVENT, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">    setState(LifecycleState.STARTING);</span><br><span class=\"line\"></span><br><span class=\"line\">    globalNamingResources.start();</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// Start our defined Services</span></span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (services) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; services.length; i++) &#123;</span><br><span class=\"line\">            services[i].start();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">stopInternal</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> LifecycleException </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    setState(LifecycleState.STOPPING);</span><br><span class=\"line\">    fireLifecycleEvent(CONFIGURE_STOP_EVENT, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// Stop our defined Services</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; services.length; i++) &#123;</span><br><span class=\"line\">        services[i].stop();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    globalNamingResources.stop();</span><br><span class=\"line\">    </span><br><span class=\"line\">    stopAwait();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>监听的代码会包围Service组件的启动过程，但所有Service必须要实现Lifecycle接口，这样做会更加灵活。</p>\n<h2 id=\"Connector组件\"><a href=\"#Connector组件\" class=\"headerlink\" title=\"Connector组件\"></a>Connector组件</h2><p>它的主要任务数负责接收浏览器发过来的TCP连接请求，创建一个Request和Response对象分别用于和请求端交换数据。然后会产生一个线程来处理这个请求并把产生的Request和Response对象传给处理这个请求的线程，处理这个请求的线程就是Container要做的事了。</p>\n<p>在Tomcat7中，Connector有3种选择：    </p>\n<ul>\n<li>BIO–Http11Protocol</li>\n<li>NIO–Http11NioProtocol</li>\n<li>apr–Http11AprProtocol</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Connector</span><span class=\"params\">(String protocol)</span> </span>&#123;</span><br><span class=\"line\">    setProtocol(protocol);</span><br><span class=\"line\">    <span class=\"comment\">// Instantiate protocol handler</span></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        Class&lt;?&gt; clazz = Class.forName(protocolHandlerClassName);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.protocolHandler = (ProtocolHandler) clazz.newInstance();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">        log.error(sm.getString(</span><br><span class=\"line\">                <span class=\"string\">\"coyoteConnector.protocolHandlerInstantiationFailed\"</span>), e);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过上述代码可以看出，Connector会根据我们在server.xml中配置的Connector类型来初始化。</p>\n<p>这里以常用的NIO来说明，找到Http11NioProtocol基类的start方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">start</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (getLog().isInfoEnabled())</span><br><span class=\"line\">        getLog().info(sm.getString(<span class=\"string\">\"abstractProtocolHandler.start\"</span>,</span><br><span class=\"line\">                getNameInternal()));</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        endpoint.start();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception ex) &#123;</span><br><span class=\"line\">        getLog().error(sm.getString(<span class=\"string\">\"abstractProtocolHandler.startError\"</span>,</span><br><span class=\"line\">                getNameInternal()), ex);</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> ex;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Start async timeout thread</span></span><br><span class=\"line\">    asyncTimeout = <span class=\"keyword\">new</span> AsyncTimeout();</span><br><span class=\"line\">    Thread timeoutThread = <span class=\"keyword\">new</span> Thread(asyncTimeout, getNameInternal() + <span class=\"string\">\"-AsyncTimeout\"</span>);</span><br><span class=\"line\">    timeoutThread.setPriority(endpoint.getThreadPriority());</span><br><span class=\"line\">    timeoutThread.setDaemon(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">    timeoutThread.start();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>start方法中调用endpoint.start()，找到对应方法，在NioEndpoint类中：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">startInternal</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!running) &#123;</span><br><span class=\"line\">            running = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            paused = <span class=\"keyword\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            processorCache = <span class=\"keyword\">new</span> SynchronizedStack&lt;&gt;(SynchronizedStack.DEFAULT_SIZE,</span><br><span class=\"line\">                    socketProperties.getProcessorCache());</span><br><span class=\"line\">            eventCache = <span class=\"keyword\">new</span> SynchronizedStack&lt;&gt;(SynchronizedStack.DEFAULT_SIZE,</span><br><span class=\"line\">                            socketProperties.getEventCache());</span><br><span class=\"line\">            nioChannels = <span class=\"keyword\">new</span> SynchronizedStack&lt;&gt;(SynchronizedStack.DEFAULT_SIZE,</span><br><span class=\"line\">                    socketProperties.getBufferPool());</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// Create worker collection</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> ( getExecutor() == <span class=\"keyword\">null</span> ) &#123;</span><br><span class=\"line\">                createExecutor();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            initializeConnectionLatch();</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// Start poller threads</span></span><br><span class=\"line\">            pollers = <span class=\"keyword\">new</span> Poller[getPollerThreadCount()];</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;pollers.length; i++) &#123;</span><br><span class=\"line\">                pollers[i] = <span class=\"keyword\">new</span> Poller();</span><br><span class=\"line\">                Thread pollerThread = <span class=\"keyword\">new</span> Thread(pollers[i], getName() + <span class=\"string\">\"-ClientPoller-\"</span>+i);</span><br><span class=\"line\">                pollerThread.setPriority(threadPriority);</span><br><span class=\"line\">                pollerThread.setDaemon(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">                pollerThread.start();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            startAcceptorThreads();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>当执行到startAcceptorThreads()时，就会进入等待请求的状态，知道一个新的请求到来才会激活它继续执行。</p>\n","excerpt":"","more":"<h1 id=\"Tomcat总体结构\"><a href=\"#Tomcat总体结构\" class=\"headerlink\" title=\"Tomcat总体结构\"></a>Tomcat总体结构</h1><p>Tomcat有2个核心组件：  </p>\n<ul>\n<li>Connector  </li>\n<li>Container  </li>\n</ul>\n<p>其中Connector组件可以被替换，一个Container可以选择对用多个Connector。多个Connector和一个Container形成一个Service。有了Service就可以对外提供服务了。但Service需要一个生存环境，这时就非Server莫属了。所以整个Tomcat的生命周期由Server控制。</p>\n<p>Connector主要负责对外交流，Container主要处理Connector接受的请求，主要处理内部事务。其实，Service只是在Connector和Container外面多包一层，把它们组装在一起，对外提供服务。一个Service可以设置多个Connector，但只能有一个Container容器。</p>\n<h2 id=\"Service\"><a href=\"#Service\" class=\"headerlink\" title=\"Service\"></a>Service</h2><p><img src=\"http://o7s628cn2.bkt.clouddn.com/image/javaweb/Service.png\" alt=\"Service\"></p>\n<p>从org.apache.catalina.Service接口中定义方法可以看出，它主要是为了关联Connector和Container，同时会初始化其他组件。所有组件的生命周期在一个Lifecycle的接口中控制。</p>\n<p><img src=\"http://o7s628cn2.bkt.clouddn.com/image/javaweb/StandardService.png\" alt=\"StandardService\"></p>\n<p>从StandardService类结构方法可以看出，除了Service接口方法的实现以及控制组件生命周期的Lifecycle接口的实现，还有几个方法用于实现时间监听方法。不仅是这个Service组件，在Tomcat中其他组件也同样有这个几个方法，这也是一个典型设计模式。</p>\n<p>下面看一下StandardService中几个主要方法，setContainer方法如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setContainer</span><span class=\"params\">(Container container)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        Container oldContainer = <span class=\"keyword\">this</span>.container;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((oldContainer != <span class=\"keyword\">null</span>) &amp;&amp; (oldContainer <span class=\"keyword\">instanceof</span> Engine))</span><br><span class=\"line\">            ((Engine) oldContainer).setService(<span class=\"keyword\">null</span>);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.container = container;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((<span class=\"keyword\">this</span>.container != <span class=\"keyword\">null</span>) &amp;&amp; (<span class=\"keyword\">this</span>.container <span class=\"keyword\">instanceof</span> Engine))</span><br><span class=\"line\">            ((Engine) <span class=\"keyword\">this</span>.container).setService(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (getState().isAvailable() &amp;&amp; (<span class=\"keyword\">this</span>.container != <span class=\"keyword\">null</span>)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">this</span>.container.start();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (LifecycleException e) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// Ignore</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (getState().isAvailable() &amp;&amp; (oldContainer != <span class=\"keyword\">null</span>)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                oldContainer.stop();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (LifecycleException e) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// Ignore</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Report this property change to interested listeners</span></span><br><span class=\"line\">        support.firePropertyChange(<span class=\"string\">\"container\"</span>, oldContainer, <span class=\"keyword\">this</span>.container);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>这段代码很简单，首先判断当前Service有没有已经关联的Container，如果已经关联，去除这个关联关系—-((Engine) oldContainer).setService(null)。如果这个oldContainer已经启动了，结束它的生命周期，然后再替换新的。</p>\n<p>AddConnector方法如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addConnector</span><span class=\"params\">(Connector connector)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (connectors) &#123;</span><br><span class=\"line\">            connector.setService(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">            Connector results[] = <span class=\"keyword\">new</span> Connector[connectors.length + <span class=\"number\">1</span>];</span><br><span class=\"line\">            System.arraycopy(connectors, <span class=\"number\">0</span>, results, <span class=\"number\">0</span>, connectors.length);</span><br><span class=\"line\">            results[connectors.length] = connector;</span><br><span class=\"line\">            connectors = results;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (getState().isAvailable()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    connector.start();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (LifecycleException e) &#123;</span><br><span class=\"line\">                    log.error(sm.getString(</span><br><span class=\"line\">                            <span class=\"string\">\"standardService.connector.startFailed\"</span>,</span><br><span class=\"line\">                            connector), e);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// Report this property change to interested listeners</span></span><br><span class=\"line\">            support.firePropertyChange(<span class=\"string\">\"connector\"</span>, <span class=\"keyword\">null</span>, connector);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>首先设置关联关系，然后初始化，开始新的生命周期。Connector用的是数组，而不是List集合，从性能角度考虑可以理解。有趣的是这里用了数组但并没有一开始就分配一个固定大小的数组。</p>\n<h2 id=\"Server\"><a href=\"#Server\" class=\"headerlink\" title=\"Server\"></a>Server</h2><p>Server要完成的任务很简单，提供一个接口让其他程序能够访问到这个Service集合，同时要维护它所包含的所有Service生命周期，包括如何初始化、如何结束服务、如何找到别人要访问的Service。</p>\n<p>Server的类结构图如下：<br><img src=\"http://o7s628cn2.bkt.clouddn.com/image/javaweb/Server.png\" alt=\"Server\"></p>\n<p>它的标准实现类StandardServer实现了上面这些方法，同时也实现了Lifecycle、MbeanRegistration两个接口的所有方法。下面看一下StandardServer一个重要方法addService的实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addService</span><span class=\"params\">(Service service)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    service.setServer(<span class=\"keyword\">this</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (services) &#123;</span><br><span class=\"line\">        Service results[] = <span class=\"keyword\">new</span> Service[services.length + <span class=\"number\">1</span>];</span><br><span class=\"line\">        System.arraycopy(services, <span class=\"number\">0</span>, results, <span class=\"number\">0</span>, services.length);</span><br><span class=\"line\">        results[services.length] = service;</span><br><span class=\"line\">        services = results;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (getState().isAvailable()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                service.start();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (LifecycleException e) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// Ignore</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Report this property change to interested listeners</span></span><br><span class=\"line\">        support.firePropertyChange(<span class=\"string\">\"service\"</span>, <span class=\"keyword\">null</span>, service);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从第一行就知道了Service和Server是相互关联的，Server也是和Service管理Connector一样管理它，也是将Service放在一个数组中。</p>\n<h2 id=\"Lifecycle\"><a href=\"#Lifecycle\" class=\"headerlink\" title=\"Lifecycle\"></a>Lifecycle</h2><p>在Tomcat中组件的生命周期通过Lifecycle接口来控制，组件只要集成这个接口并实现其中方法就可以统一被拥有它的组件控制了。最高级的组件就是Server，而控制Server的是Startup，也就是启动和关闭Tomcat。Lifecycle接口方法的实现都在其他组件中，组件的生命周期由包含它的父组件控制，所以它的Start方法自然就是调用它下面组件的Start方法，Stop方法也是一样。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">startInternal</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> LifecycleException </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    fireLifecycleEvent(CONFIGURE_START_EVENT, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">    setState(LifecycleState.STARTING);</span><br><span class=\"line\"></span><br><span class=\"line\">    globalNamingResources.start();</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// Start our defined Services</span></span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (services) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; services.length; i++) &#123;</span><br><span class=\"line\">            services[i].start();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">stopInternal</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> LifecycleException </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    setState(LifecycleState.STOPPING);</span><br><span class=\"line\">    fireLifecycleEvent(CONFIGURE_STOP_EVENT, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// Stop our defined Services</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; services.length; i++) &#123;</span><br><span class=\"line\">        services[i].stop();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    globalNamingResources.stop();</span><br><span class=\"line\">    </span><br><span class=\"line\">    stopAwait();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>监听的代码会包围Service组件的启动过程，但所有Service必须要实现Lifecycle接口，这样做会更加灵活。</p>\n<h2 id=\"Connector组件\"><a href=\"#Connector组件\" class=\"headerlink\" title=\"Connector组件\"></a>Connector组件</h2><p>它的主要任务数负责接收浏览器发过来的TCP连接请求，创建一个Request和Response对象分别用于和请求端交换数据。然后会产生一个线程来处理这个请求并把产生的Request和Response对象传给处理这个请求的线程，处理这个请求的线程就是Container要做的事了。</p>\n<p>在Tomcat7中，Connector有3种选择：    </p>\n<ul>\n<li>BIO–Http11Protocol</li>\n<li>NIO–Http11NioProtocol</li>\n<li>apr–Http11AprProtocol</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Connector</span><span class=\"params\">(String protocol)</span> </span>&#123;</span><br><span class=\"line\">    setProtocol(protocol);</span><br><span class=\"line\">    <span class=\"comment\">// Instantiate protocol handler</span></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        Class&lt;?&gt; clazz = Class.forName(protocolHandlerClassName);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.protocolHandler = (ProtocolHandler) clazz.newInstance();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">        log.error(sm.getString(</span><br><span class=\"line\">                <span class=\"string\">\"coyoteConnector.protocolHandlerInstantiationFailed\"</span>), e);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过上述代码可以看出，Connector会根据我们在server.xml中配置的Connector类型来初始化。</p>\n<p>这里以常用的NIO来说明，找到Http11NioProtocol基类的start方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">start</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (getLog().isInfoEnabled())</span><br><span class=\"line\">        getLog().info(sm.getString(<span class=\"string\">\"abstractProtocolHandler.start\"</span>,</span><br><span class=\"line\">                getNameInternal()));</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        endpoint.start();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception ex) &#123;</span><br><span class=\"line\">        getLog().error(sm.getString(<span class=\"string\">\"abstractProtocolHandler.startError\"</span>,</span><br><span class=\"line\">                getNameInternal()), ex);</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> ex;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Start async timeout thread</span></span><br><span class=\"line\">    asyncTimeout = <span class=\"keyword\">new</span> AsyncTimeout();</span><br><span class=\"line\">    Thread timeoutThread = <span class=\"keyword\">new</span> Thread(asyncTimeout, getNameInternal() + <span class=\"string\">\"-AsyncTimeout\"</span>);</span><br><span class=\"line\">    timeoutThread.setPriority(endpoint.getThreadPriority());</span><br><span class=\"line\">    timeoutThread.setDaemon(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">    timeoutThread.start();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>start方法中调用endpoint.start()，找到对应方法，在NioEndpoint类中：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">startInternal</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!running) &#123;</span><br><span class=\"line\">            running = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            paused = <span class=\"keyword\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            processorCache = <span class=\"keyword\">new</span> SynchronizedStack&lt;&gt;(SynchronizedStack.DEFAULT_SIZE,</span><br><span class=\"line\">                    socketProperties.getProcessorCache());</span><br><span class=\"line\">            eventCache = <span class=\"keyword\">new</span> SynchronizedStack&lt;&gt;(SynchronizedStack.DEFAULT_SIZE,</span><br><span class=\"line\">                            socketProperties.getEventCache());</span><br><span class=\"line\">            nioChannels = <span class=\"keyword\">new</span> SynchronizedStack&lt;&gt;(SynchronizedStack.DEFAULT_SIZE,</span><br><span class=\"line\">                    socketProperties.getBufferPool());</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// Create worker collection</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> ( getExecutor() == <span class=\"keyword\">null</span> ) &#123;</span><br><span class=\"line\">                createExecutor();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            initializeConnectionLatch();</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// Start poller threads</span></span><br><span class=\"line\">            pollers = <span class=\"keyword\">new</span> Poller[getPollerThreadCount()];</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;pollers.length; i++) &#123;</span><br><span class=\"line\">                pollers[i] = <span class=\"keyword\">new</span> Poller();</span><br><span class=\"line\">                Thread pollerThread = <span class=\"keyword\">new</span> Thread(pollers[i], getName() + <span class=\"string\">\"-ClientPoller-\"</span>+i);</span><br><span class=\"line\">                pollerThread.setPriority(threadPriority);</span><br><span class=\"line\">                pollerThread.setDaemon(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">                pollerThread.start();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            startAcceptorThreads();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>当执行到startAcceptorThreads()时，就会进入等待请求的状态，知道一个新的请求到来才会激活它继续执行。</p>\n"},{"title":"深入分析I/O工作机制","date":"2016-05-16T16:00:00.000Z","_content":"\n#\tJava的I/O基本架构\nJava的I/O操作类在java.io下，大概有将近80个类，大概可以分为以下4类：  \n*\t基于字节操作的IO接口：InputStream和OutputStream  \n* \t基于字符操作的IO接口：Writer和Reader  \n*  \t基于磁盘操作的IO接口：File  \n*  \t基于网络操作的IO接口：Socket\n\n前2组主要是传输数据的数据格式，后两组主要是传输数据的方式，虽然Socket不在java.io下，在此仍然放在一起，因为IO核心问题要么是数据格式影响IO操作，要么是传输方式影响IO操作，也就是将什么样的数据写到什么地方的问题。\n\n##\t字节与字符的转化接口\n数据持久化或网络传输都是以字节进行的，所以必须要有从字符到字节或者字节到字符的转化。\nInputStreamReader类是从字节到字符的转化桥梁，从InputStream到Reader的过程要指定编码字符集，否则将采用操作系统默认的字符集，很可能会出现乱码问题。StreamDecoder正是完成从字节到字符的解码的实现类。  \n\n```\tjava\ntry {\n\tStringBuffer str = new StringBuffer();\n\tchar[] buf = new char[1024];\n\tFileReader f = new FileReader(\"file\");\n\twhile(f.read(buf) > 0){\n\t\tstr.append(buf);\n\t}\n\tstr.toString();\n} catch (IOException e){\n}\n```\n\nFileReader就是按照上述方式读取文件，FileReader继承了InputStreamReader，实际上是读取文件流，然后通过StreamDecoder解码成char。   \n写入也是类似过程，通过OutputStreamWriter类完成从字符到字节的过程，有StreamEncoder完成解码过程。\n\n---\n#\t磁盘I/O工作机制\n读取和写入文件I/O操作都调用操作系统提供的接口，因为磁盘设备是操作系统管理的，应用程序要访问物理设备只能通过系统调用的方式。只要是操作系统调用，就存在内核空间地址和用户空间地址切换的问题，这是操作系统本身安全机制，而将内核程序运行使用的内存空间和用户程序运行的内存空间进行隔离造成的。这样虽然保证了内核程旭运行安全，但必然存在数据可能需要从内核空间向用户空间复制的问题。\n\n如果遇到非常耗时的操作，如磁盘I/O，数据从磁盘复制到内存空间，然后又从内核空间复制到用户空间，将会非常缓慢。这时OS为了加速I/O访问，在内核空间使用缓存机制，也就是从磁盘读取的文件按照一定的组织方式进行缓存，如果用户访问的是同一段磁盘地址的空间数据，那么OS将从内核缓存中直接取出返回给用户程序，这样可以减少I/O响应时间。\n\n##\t标准访问文件方式\n当程序调用read()接口时，操作系统检查在内核告诉缓存中有没有需要的数据，如果已经缓存了，那么直接从缓存中返回，如果没有，从磁盘中读取，然后缓存在操作系统缓存中。\n\n写入方式是，程序调用write()接口将数据从用户地址空间复制到内核地址空间的缓存中。这时对用户程序来说写已经完成，至于什么时候再写到磁盘中由OS决定，除非显示调用了sync同步命令。\n\n##\t直接I/O方式\n程序直接访问磁盘，不经过OS内核数据缓冲区，这样做的目的是减少一次从内核缓冲区到用户程序缓存的数据复制。这种方式通常是在对数据的缓存管理由应用程序实现的数据库管理系统中。如在数据库管理系统中，系统明确知道应该缓存哪些数据，应该失效哪些数据，还可以对一些热点数据做预加载，提前将热点数据加载到内存，可以加速数据的访问效率。\n\n但直接I/O也有负面影响，如果访问的数据不在应用程序缓存中，那么每次数据都会从磁盘直接加载，这种加载会非常缓慢。通过直接I/O与异步I/O结合使用，会得到比较好的性能。\n\n##\t同步访问文件的方式\n数据的读取和写入都是同步操作的，它与标准访问文件不同的是，只有当数据被成功写到磁盘时才返回给应用程序成功的标志。\n\n这种访问文件的方式性能比较差，只有在一些对数据安全性要求比较高的场景中才会使用，而且通常这种操作方式的硬件都是定制的。\n\n##\t异步访问文件的方式\n当访问数据的线程发出请求之后，线程会接着去处理其他事情，而不是阻塞等待，当请求的数据返回后继续处理下面的操作。这种访问文件的方式可明显提供应用程序效率，但不会改变访问文件的效率。\n\n##\t内存映射方式\nOS将内存中某一块区域与磁盘中的文件关联起来，当腰访问内存中一段数据时，转换为访问文件的某一段数据。这种方式目的同样是减少数据从内核空间缓存到用户空间缓存的数据复制操作，因为这2个数据是共享的。\n\n##\tJava访问磁盘文件\n在Java中通常的File并不代表一个真实存在的文件对象，当指定一个路径描述符时，它会返回一个代表这个路径的虚拟对象，这个可能是一个真实存在的文件或者是一个包含多个文件的目录。大多数情况下，我们并不关心这个文件是否真的存在，而是关心对这个文件到底如何操作。\n\n何时会真正检查一个文件存不存在？要是在真正要读取这个文件时。例如，FileInputStream类都是操作一个文件的接口，注意到在创建一个FileInputStream对象时会创建一个FileDescriptor对象，其实这个对象就是真正代表一个存在的文件对象的描述。当操作一个文件对象时可以通过getFD()方法获取真正操作的与底层OS相关联的文件描述。例如，可以调用FileDescriptor.sync()方法将操作系统缓存中的数据强制刷新到物理磁盘中。\n\n```\tjava\npublic FileInputStream(File file) throws FileNotFoundException {\n        String name = (file != null ? file.getPath() : null);\n        SecurityManager security = System.getSecurityManager();\n        if (security != null) {\n            security.checkRead(name);\n        }\n        if (name == null) {\n            throw new NullPointerException();\n        }\n        if (file.isInvalid()) {\n            throw new FileNotFoundException(\"Invalid file path\");\n        }\n        fd = new FileDescriptor();\n        fd.incrementAndGetUseCount();\n        this.path = name;\n        open(name);\n    }\n```\n\n当传入一个文件路径时，将会根据这个路径创建一个File对象来标识这个文件，然后根据这个File对象创建真正读取文件的操作对象，这时将会真正创建一个关联真实存在的磁盘文件的描述符FileDescriptor，通过这个对象可以直接控制这个磁盘文件。\n\n---\n#\tJava Socket工作机制\n##\t建立通信链路\n当客户端要与服务端通信时，客户端首先要创建一个Socket实例，OS将为这个Socket实例分配一个没有被使用的本地端口号，并创建一个包含本地地址、远程地址和端口号的套接字数据结构，这个数据结构将一直保存在系统中直到这个连接关闭。在创建Socket实例的构造函数正确返回之前，将要进行TCP的3次握手协议，TCP握手协议完成后，Socket实例对象将创建完成，否则抛出IOException错误。\n\n与之对应的服务端将创建一个ServerSocket实例，创建ServerSocket比较简单，只要指定的端口号未被占用，一般实例都会创建成功。同时OS也会为ServerSocket实例创建一个底层数据结构，这个数据结构包含指定监听的端口号和包含监听地址的通配符，通常情况下都是“*”，即监听所有地址。之后当调用accept()方法时，将进入阻塞状态，等待客户端的请求。\n\n当一个新的请求到来时，将为这个连接创建一个新的套接字数据结构，该套接字数据的信息包含的地址和端口信息正是请求源地址和端口。这个新创建的数据结构将会关联到ServerSocket实例的一个未完成的连接数据结构列表中。注意，这时服务端的与之对应的Socket实例并没有完成创建，而要等到与客户端的3次握手完成后，这个服务端的Socket实例才会返回，并将这个Socket实例对应的数据结构从未完成列表中移到已完成列表中。所以与ServerSocket所关联的列表中每个数据结构都代表与一个客户端建立的TCP连接。\n\n##\t数据传输\n当连接建立成功，服务端和客户端都会拥有一个Socket实例，每个Socket实例都有一个InputStream和一个OutputStream，并通过这两个对象交换数据。同时我们知道网络I/O都是以字节流传输的，当创建Socket对象时，OS将会为InputStream和OutputStream分别分配一定大小的缓存区，数据的写入和读取都是通过这个缓存区完成。\n\n写入端将数据写到OutputStream的SendQ队列中，当队列填满时，数据将被转移到另一端InputStream的RecvQ队列中，如果这时RecvQ已经满了，那么OutputStream的write方法将会阻塞，直到RecvQ队列有足够的空间容纳SendQ发送的数据。这个缓存区的大小及写入端的速度和读取端的速度非常影响这个连接的数据传输效率，由于可能会发生阻塞，所有网络I/O与磁盘I/O不同的是数据的写入和读取还要有一个协调的过程，如果两边同时传送数据可能会产生死锁。\n","source":"_posts/Java Web/深入分析IO工作机制.md","raw":"---\ntitle: 深入分析I/O工作机制\ndate: 2016-05-17\ncategories: Java Web\ntags: \n- Java\n- IO \n---\n\n#\tJava的I/O基本架构\nJava的I/O操作类在java.io下，大概有将近80个类，大概可以分为以下4类：  \n*\t基于字节操作的IO接口：InputStream和OutputStream  \n* \t基于字符操作的IO接口：Writer和Reader  \n*  \t基于磁盘操作的IO接口：File  \n*  \t基于网络操作的IO接口：Socket\n\n前2组主要是传输数据的数据格式，后两组主要是传输数据的方式，虽然Socket不在java.io下，在此仍然放在一起，因为IO核心问题要么是数据格式影响IO操作，要么是传输方式影响IO操作，也就是将什么样的数据写到什么地方的问题。\n\n##\t字节与字符的转化接口\n数据持久化或网络传输都是以字节进行的，所以必须要有从字符到字节或者字节到字符的转化。\nInputStreamReader类是从字节到字符的转化桥梁，从InputStream到Reader的过程要指定编码字符集，否则将采用操作系统默认的字符集，很可能会出现乱码问题。StreamDecoder正是完成从字节到字符的解码的实现类。  \n\n```\tjava\ntry {\n\tStringBuffer str = new StringBuffer();\n\tchar[] buf = new char[1024];\n\tFileReader f = new FileReader(\"file\");\n\twhile(f.read(buf) > 0){\n\t\tstr.append(buf);\n\t}\n\tstr.toString();\n} catch (IOException e){\n}\n```\n\nFileReader就是按照上述方式读取文件，FileReader继承了InputStreamReader，实际上是读取文件流，然后通过StreamDecoder解码成char。   \n写入也是类似过程，通过OutputStreamWriter类完成从字符到字节的过程，有StreamEncoder完成解码过程。\n\n---\n#\t磁盘I/O工作机制\n读取和写入文件I/O操作都调用操作系统提供的接口，因为磁盘设备是操作系统管理的，应用程序要访问物理设备只能通过系统调用的方式。只要是操作系统调用，就存在内核空间地址和用户空间地址切换的问题，这是操作系统本身安全机制，而将内核程序运行使用的内存空间和用户程序运行的内存空间进行隔离造成的。这样虽然保证了内核程旭运行安全，但必然存在数据可能需要从内核空间向用户空间复制的问题。\n\n如果遇到非常耗时的操作，如磁盘I/O，数据从磁盘复制到内存空间，然后又从内核空间复制到用户空间，将会非常缓慢。这时OS为了加速I/O访问，在内核空间使用缓存机制，也就是从磁盘读取的文件按照一定的组织方式进行缓存，如果用户访问的是同一段磁盘地址的空间数据，那么OS将从内核缓存中直接取出返回给用户程序，这样可以减少I/O响应时间。\n\n##\t标准访问文件方式\n当程序调用read()接口时，操作系统检查在内核告诉缓存中有没有需要的数据，如果已经缓存了，那么直接从缓存中返回，如果没有，从磁盘中读取，然后缓存在操作系统缓存中。\n\n写入方式是，程序调用write()接口将数据从用户地址空间复制到内核地址空间的缓存中。这时对用户程序来说写已经完成，至于什么时候再写到磁盘中由OS决定，除非显示调用了sync同步命令。\n\n##\t直接I/O方式\n程序直接访问磁盘，不经过OS内核数据缓冲区，这样做的目的是减少一次从内核缓冲区到用户程序缓存的数据复制。这种方式通常是在对数据的缓存管理由应用程序实现的数据库管理系统中。如在数据库管理系统中，系统明确知道应该缓存哪些数据，应该失效哪些数据，还可以对一些热点数据做预加载，提前将热点数据加载到内存，可以加速数据的访问效率。\n\n但直接I/O也有负面影响，如果访问的数据不在应用程序缓存中，那么每次数据都会从磁盘直接加载，这种加载会非常缓慢。通过直接I/O与异步I/O结合使用，会得到比较好的性能。\n\n##\t同步访问文件的方式\n数据的读取和写入都是同步操作的，它与标准访问文件不同的是，只有当数据被成功写到磁盘时才返回给应用程序成功的标志。\n\n这种访问文件的方式性能比较差，只有在一些对数据安全性要求比较高的场景中才会使用，而且通常这种操作方式的硬件都是定制的。\n\n##\t异步访问文件的方式\n当访问数据的线程发出请求之后，线程会接着去处理其他事情，而不是阻塞等待，当请求的数据返回后继续处理下面的操作。这种访问文件的方式可明显提供应用程序效率，但不会改变访问文件的效率。\n\n##\t内存映射方式\nOS将内存中某一块区域与磁盘中的文件关联起来，当腰访问内存中一段数据时，转换为访问文件的某一段数据。这种方式目的同样是减少数据从内核空间缓存到用户空间缓存的数据复制操作，因为这2个数据是共享的。\n\n##\tJava访问磁盘文件\n在Java中通常的File并不代表一个真实存在的文件对象，当指定一个路径描述符时，它会返回一个代表这个路径的虚拟对象，这个可能是一个真实存在的文件或者是一个包含多个文件的目录。大多数情况下，我们并不关心这个文件是否真的存在，而是关心对这个文件到底如何操作。\n\n何时会真正检查一个文件存不存在？要是在真正要读取这个文件时。例如，FileInputStream类都是操作一个文件的接口，注意到在创建一个FileInputStream对象时会创建一个FileDescriptor对象，其实这个对象就是真正代表一个存在的文件对象的描述。当操作一个文件对象时可以通过getFD()方法获取真正操作的与底层OS相关联的文件描述。例如，可以调用FileDescriptor.sync()方法将操作系统缓存中的数据强制刷新到物理磁盘中。\n\n```\tjava\npublic FileInputStream(File file) throws FileNotFoundException {\n        String name = (file != null ? file.getPath() : null);\n        SecurityManager security = System.getSecurityManager();\n        if (security != null) {\n            security.checkRead(name);\n        }\n        if (name == null) {\n            throw new NullPointerException();\n        }\n        if (file.isInvalid()) {\n            throw new FileNotFoundException(\"Invalid file path\");\n        }\n        fd = new FileDescriptor();\n        fd.incrementAndGetUseCount();\n        this.path = name;\n        open(name);\n    }\n```\n\n当传入一个文件路径时，将会根据这个路径创建一个File对象来标识这个文件，然后根据这个File对象创建真正读取文件的操作对象，这时将会真正创建一个关联真实存在的磁盘文件的描述符FileDescriptor，通过这个对象可以直接控制这个磁盘文件。\n\n---\n#\tJava Socket工作机制\n##\t建立通信链路\n当客户端要与服务端通信时，客户端首先要创建一个Socket实例，OS将为这个Socket实例分配一个没有被使用的本地端口号，并创建一个包含本地地址、远程地址和端口号的套接字数据结构，这个数据结构将一直保存在系统中直到这个连接关闭。在创建Socket实例的构造函数正确返回之前，将要进行TCP的3次握手协议，TCP握手协议完成后，Socket实例对象将创建完成，否则抛出IOException错误。\n\n与之对应的服务端将创建一个ServerSocket实例，创建ServerSocket比较简单，只要指定的端口号未被占用，一般实例都会创建成功。同时OS也会为ServerSocket实例创建一个底层数据结构，这个数据结构包含指定监听的端口号和包含监听地址的通配符，通常情况下都是“*”，即监听所有地址。之后当调用accept()方法时，将进入阻塞状态，等待客户端的请求。\n\n当一个新的请求到来时，将为这个连接创建一个新的套接字数据结构，该套接字数据的信息包含的地址和端口信息正是请求源地址和端口。这个新创建的数据结构将会关联到ServerSocket实例的一个未完成的连接数据结构列表中。注意，这时服务端的与之对应的Socket实例并没有完成创建，而要等到与客户端的3次握手完成后，这个服务端的Socket实例才会返回，并将这个Socket实例对应的数据结构从未完成列表中移到已完成列表中。所以与ServerSocket所关联的列表中每个数据结构都代表与一个客户端建立的TCP连接。\n\n##\t数据传输\n当连接建立成功，服务端和客户端都会拥有一个Socket实例，每个Socket实例都有一个InputStream和一个OutputStream，并通过这两个对象交换数据。同时我们知道网络I/O都是以字节流传输的，当创建Socket对象时，OS将会为InputStream和OutputStream分别分配一定大小的缓存区，数据的写入和读取都是通过这个缓存区完成。\n\n写入端将数据写到OutputStream的SendQ队列中，当队列填满时，数据将被转移到另一端InputStream的RecvQ队列中，如果这时RecvQ已经满了，那么OutputStream的write方法将会阻塞，直到RecvQ队列有足够的空间容纳SendQ发送的数据。这个缓存区的大小及写入端的速度和读取端的速度非常影响这个连接的数据传输效率，由于可能会发生阻塞，所有网络I/O与磁盘I/O不同的是数据的写入和读取还要有一个协调的过程，如果两边同时传送数据可能会产生死锁。\n","slug":"Java Web/深入分析IO工作机制","published":1,"updated":"2019-05-17T05:57:58.558Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1j8f2iq001k7h9mds4tfk67","content":"<h1 id=\"Java的I-O基本架构\"><a href=\"#Java的I-O基本架构\" class=\"headerlink\" title=\"Java的I/O基本架构\"></a>Java的I/O基本架构</h1><p>Java的I/O操作类在java.io下，大概有将近80个类，大概可以分为以下4类：  </p>\n<ul>\n<li>基于字节操作的IO接口：InputStream和OutputStream  </li>\n<li>基于字符操作的IO接口：Writer和Reader  </li>\n<li>基于磁盘操作的IO接口：File  </li>\n<li>基于网络操作的IO接口：Socket</li>\n</ul>\n<p>前2组主要是传输数据的数据格式，后两组主要是传输数据的方式，虽然Socket不在java.io下，在此仍然放在一起，因为IO核心问题要么是数据格式影响IO操作，要么是传输方式影响IO操作，也就是将什么样的数据写到什么地方的问题。</p>\n<h2 id=\"字节与字符的转化接口\"><a href=\"#字节与字符的转化接口\" class=\"headerlink\" title=\"字节与字符的转化接口\"></a>字节与字符的转化接口</h2><p>数据持久化或网络传输都是以字节进行的，所以必须要有从字符到字节或者字节到字符的转化。<br>InputStreamReader类是从字节到字符的转化桥梁，从InputStream到Reader的过程要指定编码字符集，否则将采用操作系统默认的字符集，很可能会出现乱码问题。StreamDecoder正是完成从字节到字符的解码的实现类。  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\tStringBuffer str = <span class=\"keyword\">new</span> StringBuffer();</span><br><span class=\"line\">\t<span class=\"keyword\">char</span>[] buf = <span class=\"keyword\">new</span> <span class=\"keyword\">char</span>[<span class=\"number\">1024</span>];</span><br><span class=\"line\">\tFileReader f = <span class=\"keyword\">new</span> FileReader(<span class=\"string\">\"file\"</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(f.read(buf) &gt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">\t\tstr.append(buf);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tstr.toString();</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (IOException e)&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>FileReader就是按照上述方式读取文件，FileReader继承了InputStreamReader，实际上是读取文件流，然后通过StreamDecoder解码成char。<br>写入也是类似过程，通过OutputStreamWriter类完成从字符到字节的过程，有StreamEncoder完成解码过程。</p>\n<hr>\n<h1 id=\"磁盘I-O工作机制\"><a href=\"#磁盘I-O工作机制\" class=\"headerlink\" title=\"磁盘I/O工作机制\"></a>磁盘I/O工作机制</h1><p>读取和写入文件I/O操作都调用操作系统提供的接口，因为磁盘设备是操作系统管理的，应用程序要访问物理设备只能通过系统调用的方式。只要是操作系统调用，就存在内核空间地址和用户空间地址切换的问题，这是操作系统本身安全机制，而将内核程序运行使用的内存空间和用户程序运行的内存空间进行隔离造成的。这样虽然保证了内核程旭运行安全，但必然存在数据可能需要从内核空间向用户空间复制的问题。</p>\n<p>如果遇到非常耗时的操作，如磁盘I/O，数据从磁盘复制到内存空间，然后又从内核空间复制到用户空间，将会非常缓慢。这时OS为了加速I/O访问，在内核空间使用缓存机制，也就是从磁盘读取的文件按照一定的组织方式进行缓存，如果用户访问的是同一段磁盘地址的空间数据，那么OS将从内核缓存中直接取出返回给用户程序，这样可以减少I/O响应时间。</p>\n<h2 id=\"标准访问文件方式\"><a href=\"#标准访问文件方式\" class=\"headerlink\" title=\"标准访问文件方式\"></a>标准访问文件方式</h2><p>当程序调用read()接口时，操作系统检查在内核告诉缓存中有没有需要的数据，如果已经缓存了，那么直接从缓存中返回，如果没有，从磁盘中读取，然后缓存在操作系统缓存中。</p>\n<p>写入方式是，程序调用write()接口将数据从用户地址空间复制到内核地址空间的缓存中。这时对用户程序来说写已经完成，至于什么时候再写到磁盘中由OS决定，除非显示调用了sync同步命令。</p>\n<h2 id=\"直接I-O方式\"><a href=\"#直接I-O方式\" class=\"headerlink\" title=\"直接I/O方式\"></a>直接I/O方式</h2><p>程序直接访问磁盘，不经过OS内核数据缓冲区，这样做的目的是减少一次从内核缓冲区到用户程序缓存的数据复制。这种方式通常是在对数据的缓存管理由应用程序实现的数据库管理系统中。如在数据库管理系统中，系统明确知道应该缓存哪些数据，应该失效哪些数据，还可以对一些热点数据做预加载，提前将热点数据加载到内存，可以加速数据的访问效率。</p>\n<p>但直接I/O也有负面影响，如果访问的数据不在应用程序缓存中，那么每次数据都会从磁盘直接加载，这种加载会非常缓慢。通过直接I/O与异步I/O结合使用，会得到比较好的性能。</p>\n<h2 id=\"同步访问文件的方式\"><a href=\"#同步访问文件的方式\" class=\"headerlink\" title=\"同步访问文件的方式\"></a>同步访问文件的方式</h2><p>数据的读取和写入都是同步操作的，它与标准访问文件不同的是，只有当数据被成功写到磁盘时才返回给应用程序成功的标志。</p>\n<p>这种访问文件的方式性能比较差，只有在一些对数据安全性要求比较高的场景中才会使用，而且通常这种操作方式的硬件都是定制的。</p>\n<h2 id=\"异步访问文件的方式\"><a href=\"#异步访问文件的方式\" class=\"headerlink\" title=\"异步访问文件的方式\"></a>异步访问文件的方式</h2><p>当访问数据的线程发出请求之后，线程会接着去处理其他事情，而不是阻塞等待，当请求的数据返回后继续处理下面的操作。这种访问文件的方式可明显提供应用程序效率，但不会改变访问文件的效率。</p>\n<h2 id=\"内存映射方式\"><a href=\"#内存映射方式\" class=\"headerlink\" title=\"内存映射方式\"></a>内存映射方式</h2><p>OS将内存中某一块区域与磁盘中的文件关联起来，当腰访问内存中一段数据时，转换为访问文件的某一段数据。这种方式目的同样是减少数据从内核空间缓存到用户空间缓存的数据复制操作，因为这2个数据是共享的。</p>\n<h2 id=\"Java访问磁盘文件\"><a href=\"#Java访问磁盘文件\" class=\"headerlink\" title=\"Java访问磁盘文件\"></a>Java访问磁盘文件</h2><p>在Java中通常的File并不代表一个真实存在的文件对象，当指定一个路径描述符时，它会返回一个代表这个路径的虚拟对象，这个可能是一个真实存在的文件或者是一个包含多个文件的目录。大多数情况下，我们并不关心这个文件是否真的存在，而是关心对这个文件到底如何操作。</p>\n<p>何时会真正检查一个文件存不存在？要是在真正要读取这个文件时。例如，FileInputStream类都是操作一个文件的接口，注意到在创建一个FileInputStream对象时会创建一个FileDescriptor对象，其实这个对象就是真正代表一个存在的文件对象的描述。当操作一个文件对象时可以通过getFD()方法获取真正操作的与底层OS相关联的文件描述。例如，可以调用FileDescriptor.sync()方法将操作系统缓存中的数据强制刷新到物理磁盘中。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">FileInputStream</span><span class=\"params\">(File file)</span> <span class=\"keyword\">throws</span> FileNotFoundException </span>&#123;</span><br><span class=\"line\">        String name = (file != <span class=\"keyword\">null</span> ? file.getPath() : <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        SecurityManager security = System.getSecurityManager();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (security != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            security.checkRead(name);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (name == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (file.isInvalid()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> FileNotFoundException(<span class=\"string\">\"Invalid file path\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        fd = <span class=\"keyword\">new</span> FileDescriptor();</span><br><span class=\"line\">        fd.incrementAndGetUseCount();</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.path = name;</span><br><span class=\"line\">        open(name);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>当传入一个文件路径时，将会根据这个路径创建一个File对象来标识这个文件，然后根据这个File对象创建真正读取文件的操作对象，这时将会真正创建一个关联真实存在的磁盘文件的描述符FileDescriptor，通过这个对象可以直接控制这个磁盘文件。</p>\n<hr>\n<h1 id=\"Java-Socket工作机制\"><a href=\"#Java-Socket工作机制\" class=\"headerlink\" title=\"Java Socket工作机制\"></a>Java Socket工作机制</h1><h2 id=\"建立通信链路\"><a href=\"#建立通信链路\" class=\"headerlink\" title=\"建立通信链路\"></a>建立通信链路</h2><p>当客户端要与服务端通信时，客户端首先要创建一个Socket实例，OS将为这个Socket实例分配一个没有被使用的本地端口号，并创建一个包含本地地址、远程地址和端口号的套接字数据结构，这个数据结构将一直保存在系统中直到这个连接关闭。在创建Socket实例的构造函数正确返回之前，将要进行TCP的3次握手协议，TCP握手协议完成后，Socket实例对象将创建完成，否则抛出IOException错误。</p>\n<p>与之对应的服务端将创建一个ServerSocket实例，创建ServerSocket比较简单，只要指定的端口号未被占用，一般实例都会创建成功。同时OS也会为ServerSocket实例创建一个底层数据结构，这个数据结构包含指定监听的端口号和包含监听地址的通配符，通常情况下都是“*”，即监听所有地址。之后当调用accept()方法时，将进入阻塞状态，等待客户端的请求。</p>\n<p>当一个新的请求到来时，将为这个连接创建一个新的套接字数据结构，该套接字数据的信息包含的地址和端口信息正是请求源地址和端口。这个新创建的数据结构将会关联到ServerSocket实例的一个未完成的连接数据结构列表中。注意，这时服务端的与之对应的Socket实例并没有完成创建，而要等到与客户端的3次握手完成后，这个服务端的Socket实例才会返回，并将这个Socket实例对应的数据结构从未完成列表中移到已完成列表中。所以与ServerSocket所关联的列表中每个数据结构都代表与一个客户端建立的TCP连接。</p>\n<h2 id=\"数据传输\"><a href=\"#数据传输\" class=\"headerlink\" title=\"数据传输\"></a>数据传输</h2><p>当连接建立成功，服务端和客户端都会拥有一个Socket实例，每个Socket实例都有一个InputStream和一个OutputStream，并通过这两个对象交换数据。同时我们知道网络I/O都是以字节流传输的，当创建Socket对象时，OS将会为InputStream和OutputStream分别分配一定大小的缓存区，数据的写入和读取都是通过这个缓存区完成。</p>\n<p>写入端将数据写到OutputStream的SendQ队列中，当队列填满时，数据将被转移到另一端InputStream的RecvQ队列中，如果这时RecvQ已经满了，那么OutputStream的write方法将会阻塞，直到RecvQ队列有足够的空间容纳SendQ发送的数据。这个缓存区的大小及写入端的速度和读取端的速度非常影响这个连接的数据传输效率，由于可能会发生阻塞，所有网络I/O与磁盘I/O不同的是数据的写入和读取还要有一个协调的过程，如果两边同时传送数据可能会产生死锁。</p>\n","excerpt":"","more":"<h1 id=\"Java的I-O基本架构\"><a href=\"#Java的I-O基本架构\" class=\"headerlink\" title=\"Java的I/O基本架构\"></a>Java的I/O基本架构</h1><p>Java的I/O操作类在java.io下，大概有将近80个类，大概可以分为以下4类：  </p>\n<ul>\n<li>基于字节操作的IO接口：InputStream和OutputStream  </li>\n<li>基于字符操作的IO接口：Writer和Reader  </li>\n<li>基于磁盘操作的IO接口：File  </li>\n<li>基于网络操作的IO接口：Socket</li>\n</ul>\n<p>前2组主要是传输数据的数据格式，后两组主要是传输数据的方式，虽然Socket不在java.io下，在此仍然放在一起，因为IO核心问题要么是数据格式影响IO操作，要么是传输方式影响IO操作，也就是将什么样的数据写到什么地方的问题。</p>\n<h2 id=\"字节与字符的转化接口\"><a href=\"#字节与字符的转化接口\" class=\"headerlink\" title=\"字节与字符的转化接口\"></a>字节与字符的转化接口</h2><p>数据持久化或网络传输都是以字节进行的，所以必须要有从字符到字节或者字节到字符的转化。<br>InputStreamReader类是从字节到字符的转化桥梁，从InputStream到Reader的过程要指定编码字符集，否则将采用操作系统默认的字符集，很可能会出现乱码问题。StreamDecoder正是完成从字节到字符的解码的实现类。  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\tStringBuffer str = <span class=\"keyword\">new</span> StringBuffer();</span><br><span class=\"line\">\t<span class=\"keyword\">char</span>[] buf = <span class=\"keyword\">new</span> <span class=\"keyword\">char</span>[<span class=\"number\">1024</span>];</span><br><span class=\"line\">\tFileReader f = <span class=\"keyword\">new</span> FileReader(<span class=\"string\">\"file\"</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(f.read(buf) &gt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">\t\tstr.append(buf);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tstr.toString();</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (IOException e)&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>FileReader就是按照上述方式读取文件，FileReader继承了InputStreamReader，实际上是读取文件流，然后通过StreamDecoder解码成char。<br>写入也是类似过程，通过OutputStreamWriter类完成从字符到字节的过程，有StreamEncoder完成解码过程。</p>\n<hr>\n<h1 id=\"磁盘I-O工作机制\"><a href=\"#磁盘I-O工作机制\" class=\"headerlink\" title=\"磁盘I/O工作机制\"></a>磁盘I/O工作机制</h1><p>读取和写入文件I/O操作都调用操作系统提供的接口，因为磁盘设备是操作系统管理的，应用程序要访问物理设备只能通过系统调用的方式。只要是操作系统调用，就存在内核空间地址和用户空间地址切换的问题，这是操作系统本身安全机制，而将内核程序运行使用的内存空间和用户程序运行的内存空间进行隔离造成的。这样虽然保证了内核程旭运行安全，但必然存在数据可能需要从内核空间向用户空间复制的问题。</p>\n<p>如果遇到非常耗时的操作，如磁盘I/O，数据从磁盘复制到内存空间，然后又从内核空间复制到用户空间，将会非常缓慢。这时OS为了加速I/O访问，在内核空间使用缓存机制，也就是从磁盘读取的文件按照一定的组织方式进行缓存，如果用户访问的是同一段磁盘地址的空间数据，那么OS将从内核缓存中直接取出返回给用户程序，这样可以减少I/O响应时间。</p>\n<h2 id=\"标准访问文件方式\"><a href=\"#标准访问文件方式\" class=\"headerlink\" title=\"标准访问文件方式\"></a>标准访问文件方式</h2><p>当程序调用read()接口时，操作系统检查在内核告诉缓存中有没有需要的数据，如果已经缓存了，那么直接从缓存中返回，如果没有，从磁盘中读取，然后缓存在操作系统缓存中。</p>\n<p>写入方式是，程序调用write()接口将数据从用户地址空间复制到内核地址空间的缓存中。这时对用户程序来说写已经完成，至于什么时候再写到磁盘中由OS决定，除非显示调用了sync同步命令。</p>\n<h2 id=\"直接I-O方式\"><a href=\"#直接I-O方式\" class=\"headerlink\" title=\"直接I/O方式\"></a>直接I/O方式</h2><p>程序直接访问磁盘，不经过OS内核数据缓冲区，这样做的目的是减少一次从内核缓冲区到用户程序缓存的数据复制。这种方式通常是在对数据的缓存管理由应用程序实现的数据库管理系统中。如在数据库管理系统中，系统明确知道应该缓存哪些数据，应该失效哪些数据，还可以对一些热点数据做预加载，提前将热点数据加载到内存，可以加速数据的访问效率。</p>\n<p>但直接I/O也有负面影响，如果访问的数据不在应用程序缓存中，那么每次数据都会从磁盘直接加载，这种加载会非常缓慢。通过直接I/O与异步I/O结合使用，会得到比较好的性能。</p>\n<h2 id=\"同步访问文件的方式\"><a href=\"#同步访问文件的方式\" class=\"headerlink\" title=\"同步访问文件的方式\"></a>同步访问文件的方式</h2><p>数据的读取和写入都是同步操作的，它与标准访问文件不同的是，只有当数据被成功写到磁盘时才返回给应用程序成功的标志。</p>\n<p>这种访问文件的方式性能比较差，只有在一些对数据安全性要求比较高的场景中才会使用，而且通常这种操作方式的硬件都是定制的。</p>\n<h2 id=\"异步访问文件的方式\"><a href=\"#异步访问文件的方式\" class=\"headerlink\" title=\"异步访问文件的方式\"></a>异步访问文件的方式</h2><p>当访问数据的线程发出请求之后，线程会接着去处理其他事情，而不是阻塞等待，当请求的数据返回后继续处理下面的操作。这种访问文件的方式可明显提供应用程序效率，但不会改变访问文件的效率。</p>\n<h2 id=\"内存映射方式\"><a href=\"#内存映射方式\" class=\"headerlink\" title=\"内存映射方式\"></a>内存映射方式</h2><p>OS将内存中某一块区域与磁盘中的文件关联起来，当腰访问内存中一段数据时，转换为访问文件的某一段数据。这种方式目的同样是减少数据从内核空间缓存到用户空间缓存的数据复制操作，因为这2个数据是共享的。</p>\n<h2 id=\"Java访问磁盘文件\"><a href=\"#Java访问磁盘文件\" class=\"headerlink\" title=\"Java访问磁盘文件\"></a>Java访问磁盘文件</h2><p>在Java中通常的File并不代表一个真实存在的文件对象，当指定一个路径描述符时，它会返回一个代表这个路径的虚拟对象，这个可能是一个真实存在的文件或者是一个包含多个文件的目录。大多数情况下，我们并不关心这个文件是否真的存在，而是关心对这个文件到底如何操作。</p>\n<p>何时会真正检查一个文件存不存在？要是在真正要读取这个文件时。例如，FileInputStream类都是操作一个文件的接口，注意到在创建一个FileInputStream对象时会创建一个FileDescriptor对象，其实这个对象就是真正代表一个存在的文件对象的描述。当操作一个文件对象时可以通过getFD()方法获取真正操作的与底层OS相关联的文件描述。例如，可以调用FileDescriptor.sync()方法将操作系统缓存中的数据强制刷新到物理磁盘中。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">FileInputStream</span><span class=\"params\">(File file)</span> <span class=\"keyword\">throws</span> FileNotFoundException </span>&#123;</span><br><span class=\"line\">        String name = (file != <span class=\"keyword\">null</span> ? file.getPath() : <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        SecurityManager security = System.getSecurityManager();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (security != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            security.checkRead(name);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (name == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (file.isInvalid()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> FileNotFoundException(<span class=\"string\">\"Invalid file path\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        fd = <span class=\"keyword\">new</span> FileDescriptor();</span><br><span class=\"line\">        fd.incrementAndGetUseCount();</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.path = name;</span><br><span class=\"line\">        open(name);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>当传入一个文件路径时，将会根据这个路径创建一个File对象来标识这个文件，然后根据这个File对象创建真正读取文件的操作对象，这时将会真正创建一个关联真实存在的磁盘文件的描述符FileDescriptor，通过这个对象可以直接控制这个磁盘文件。</p>\n<hr>\n<h1 id=\"Java-Socket工作机制\"><a href=\"#Java-Socket工作机制\" class=\"headerlink\" title=\"Java Socket工作机制\"></a>Java Socket工作机制</h1><h2 id=\"建立通信链路\"><a href=\"#建立通信链路\" class=\"headerlink\" title=\"建立通信链路\"></a>建立通信链路</h2><p>当客户端要与服务端通信时，客户端首先要创建一个Socket实例，OS将为这个Socket实例分配一个没有被使用的本地端口号，并创建一个包含本地地址、远程地址和端口号的套接字数据结构，这个数据结构将一直保存在系统中直到这个连接关闭。在创建Socket实例的构造函数正确返回之前，将要进行TCP的3次握手协议，TCP握手协议完成后，Socket实例对象将创建完成，否则抛出IOException错误。</p>\n<p>与之对应的服务端将创建一个ServerSocket实例，创建ServerSocket比较简单，只要指定的端口号未被占用，一般实例都会创建成功。同时OS也会为ServerSocket实例创建一个底层数据结构，这个数据结构包含指定监听的端口号和包含监听地址的通配符，通常情况下都是“*”，即监听所有地址。之后当调用accept()方法时，将进入阻塞状态，等待客户端的请求。</p>\n<p>当一个新的请求到来时，将为这个连接创建一个新的套接字数据结构，该套接字数据的信息包含的地址和端口信息正是请求源地址和端口。这个新创建的数据结构将会关联到ServerSocket实例的一个未完成的连接数据结构列表中。注意，这时服务端的与之对应的Socket实例并没有完成创建，而要等到与客户端的3次握手完成后，这个服务端的Socket实例才会返回，并将这个Socket实例对应的数据结构从未完成列表中移到已完成列表中。所以与ServerSocket所关联的列表中每个数据结构都代表与一个客户端建立的TCP连接。</p>\n<h2 id=\"数据传输\"><a href=\"#数据传输\" class=\"headerlink\" title=\"数据传输\"></a>数据传输</h2><p>当连接建立成功，服务端和客户端都会拥有一个Socket实例，每个Socket实例都有一个InputStream和一个OutputStream，并通过这两个对象交换数据。同时我们知道网络I/O都是以字节流传输的，当创建Socket对象时，OS将会为InputStream和OutputStream分别分配一定大小的缓存区，数据的写入和读取都是通过这个缓存区完成。</p>\n<p>写入端将数据写到OutputStream的SendQ队列中，当队列填满时，数据将被转移到另一端InputStream的RecvQ队列中，如果这时RecvQ已经满了，那么OutputStream的write方法将会阻塞，直到RecvQ队列有足够的空间容纳SendQ发送的数据。这个缓存区的大小及写入端的速度和读取端的速度非常影响这个连接的数据传输效率，由于可能会发生阻塞，所有网络I/O与磁盘I/O不同的是数据的写入和读取还要有一个协调的过程，如果两边同时传送数据可能会产生死锁。</p>\n"},{"title":"Hystrix之hystrix-javanica","date":"2017-07-15T16:00:00.000Z","_content":"\n##\t什么是 Hystrix？\n\n在分布式环境中，不可避免地会有一些服务依赖项会失败。Hystrix是一个库，它通过添加延迟容忍和容错逻辑来帮助控制这些分布式服务之间的交互。Hystrix通过隔离服务之间的访问点、阻止它们之间的级联故障，并提供备用选项，从而提高系统的整体弹性。\n\n##\tHystrix 解决什么问题？\n\n对于每个具有99.99％正常运行时间的30个服务。\n\n>99.99^30 = 99.7％正常运行时间\n\n>10亿次请求中的0.3％= 3,000,000次故障\n\n>2+小时停机时间/月，即使所有依赖关系都有很好的正常运行时间。\n\n即使所有依赖关系表现良好，即使0.01％的停机时间对数十个服务中的每一个服务的总体影响等同于每个月停机的潜在时间。\n\n对于高容量流量，单个后端依赖关系故障可能导致所有服务器上资源在几秒钟内饱和。\n\n##\tHystrix 工作原理\n\n*\t防止任何单个依赖关系使用容器（如Tomcat）全部线程。\n*\t减少负载并快速失败，而不是排队。\n*\t在可行的情况下提供回退以保护用户免受故障。\n*\t使用隔离技术（如隔板，泳道和断路器模式）来限制任何一个依赖的影响。\n*\t提供准实时的监控指标、报警。\n*\t提供低延迟的配置修改，并支持Hystrix大多数的动态属性更改，以便循环使用低延迟修改进行实时操作修改。\n*\t保护整个依赖客户端执行中的故障，而不仅仅是在网络流量中。\n\n##\tHystrix 功能实现\n\n*\t通过HystrixCommand或HystrixObservableCommand包装请求，\n实现在单独的线程中执行（这是命令模式的一种）。\n\n*\t超时调用比您定义的阈值长时间更长。提供一个默认配置，对于大多数依赖调用你可以通过”properties”来自定义它们的超时时间，以使它们的可用性达到99.5%或更高。\n\n*\t为每个依赖调用维护一个小的线程池（或信号量）; 如果它满了，那么依赖调用的请求将立即被拒绝，而不是排队等待。\n\n*\t处理成功，失败（由客户端抛出的异常），超时和线程拒绝。\n\n*\t跳闸断路器可以在一段时间内停止对特定服务的所有请求，如果服务的错误百分比通过阈值，可手动或自动停止。\n\n*\t当请求失败时执行回退逻辑，被拒绝，超时或短路。\n\n*\t准实时监控，运行时变更配置。\n\n##\thystrix-javanica\n\n使用完整的hystrix需要大量代码，可能需要花费大量时间写一个Hystrix命令。Javanica旨在通过引入注释来简化使用hystrix。Javanica通过在Spring中声明HystrixCommandAspect这个bean来实现，这里不再赘述AOP。\n\nJavanica 通过 ConfigurationManager 来管理属性配置。\n\n以下注解和代码效果等同。\n\n```Java\n    @HystrixCommand(commandProperties = {\n            @HystrixProperty(name = \"execution.isolation.thread.timeoutInMilliseconds\", value = \"500\")\n        })\n    public User getUserById(String id) {\n        return userResource.getUserById(id);\n    }\n```\n\n```Java\nConfigurationManager.getConfigInstance().setProperty(\"hystrix.command.getUserById.execution.isolation.thread.timeoutInMilliseconds\", \"500\");\n```\n\n\n###\tHystrixCommand 注解配置\n\n####\t隔离策略\n\n*\tExecutionIsolationStrategy.THREAD\n\n\t在一个单独的线程上执行，并发请求受到线程池中线程数量的限制。推荐使用。\n\t\n* \tExecutionIsolationStrategy.SEMAPHORE\n\n\t它在调用线程上执行，并发请求受到信号量计数的限制。开销太大，适用于非网络调用。\n\n\n####\tHystrixCommand\n\n参数|作用|默认值\n:-:|:-:|:-:\ngroupKey|所属分组，一个group共用一个线程池|当前类名\ncommandKey|业务key|当前方法名\nexecution.isolation.strategy|隔离策略|ExecutionIsolationStrategy.THREAD\nexecution.isolation.thread.timeoutInMilliseconds|超时时间|1000ms\nexecution.timeout.enable|超时开关|true\nexecution.isolation.thread.interruptOnTimeout|超时线程中断|true，Thread模式有效\nexecution.isolation.thread.interruptOnCancel|取消线程中断|false，Thread模式有效\nexecution.isolation.semaphore.maxConcurrentRequests|信号量最大并发度|10，SEMAPHORE模式有效\n\n####\tFallback\n\n参数|作用|默认值\n:-:|:-:|:-:\nfallback.isolation.semaphore.maxConcurrentRequests|fallback最大并发度|10\nfallback.enabled|fallback开关|true\n\n####\tCircuit Breaker\n\n参数|作用|默认值\n:-:|:-:|:-:\ncircuitBreaker.enabled|熔断器开关|true\ncircuitBreaker.requestVolumeThreshold|触发熔断的最小个数/10s|20\ncircuitBreaker.sleepWindowInMilliseconds|熔断多长时间后去尝试请求|5000ms\ncircuitBreaker.errorThresholdPercentage|触发熔断的失败百分比|50\ncircuitBreaker.forceOpen|强制打开|false，设为true会拒绝所有请求\ncircuitBreaker.forceClosed|强制关闭|false，设为true会允许所有请求通过\n\n####\tThreadPool\n\n参数|作用|默认值|实时修改\n:-:|:-:|:-:|:-:\ncoreSize|线程池大小|10|支持\nmaximumSize|队列大小|10|支持\nmaxQueueSize|BlockingQueue的最大长度|-1使用SynchronousQueue，否则使用LinkedBlockingQueue|初始化时确定，不允许运行时修改\nqueueSizeRejectionThreshold|队列大小拒绝阈值|5|支持，即使maxQueueSize没有达到，也会出现拒绝，因为允许动态更改拒绝队列的大小\nkeepAliveTimeMinutes|线程释放的空闲时间|1|支持\nallowMaximumSizeToDivergeFromCoreSize|maximumSize大于coreSize时，线程空闲时是否释放资源|false|支持\n\n###\tSpringMVC\n\n```xml\n\t<aop:aspectj-autoproxy/>\n    <bean id=\"hystrixAspect\" class=\"com.netflix.hystrix.contrib.javanica.aop.aspectj.HystrixCommandAspect\"></bean>\n```\n\n###\tSpringBoot\n\n```Java\n\t@Configuration\n\tpublic class HystrixConfiguration {\n\t\n\t  @Bean\n\t  public HystrixCommandAspect hystrixAspect() {\n\t    return new HystrixCommandAspect();\n\t  }\n\t\n\t}\n```\n\n###\tSync Execution\n\n```Java\n\t@HystrixCommand(groupKey=\"UserGroup\", commandKey = \"GetUserByIdCommand\")\n\tpublic User getUserById(String id) {\n\t    return userResource.getUserById(id);\n\t}\n```\n\n###\tAsync Execution\n\n```Java\n\t@HystrixCommand\n\tpublic Future<User> getUserByIdAsync(final String id) {\n\t    return new AsyncResult<User>() {\n\t        @Override\n\t        public User invoke() {\n\t            return userResource.getUserById(id);\n\t        }\n\t    };\n\t}\n```\n\n###\tReactive Exection\n\n```Java\n\t@HystrixCommand\n\tpublic Observable<User> getUserById(final String id) {\n\t    return Observable.create(new Observable.OnSubscribe<User>() {\n\t            @Override\n\t            public void call(Subscriber<? super User> observer) {\n\t                try {\n\t                    if (!observer.isUnsubscribed()) {\n\t                        observer.onNext(new User(id, name + id));\n\t                        observer.onCompleted();\n\t                    }\n\t                } catch (Exception e) {\n\t                    observer.onError(e);\n\t                }\n\t            }\n\t        });\n\t}\n```\n\n###\tFallback\n\n```Java\n\t@HystrixCommand(fallbackMethod = \"defaultUser\")\n\tpublic User getUserById(String id) {\n\t    return userResource.getUserById(id);\n\t}\n\t\n\tprivate User defaultUser(String id) {\n\t    return new User(\"def\", \"def\");\n\t}\n```\n\n*\tHystrix命令和fallback应该在同一个类中，并且具有相同的方法签名(失败执行异常的可选参数)。\n*  \t如果需要异常，在末尾添加Throwable，对访问修饰符无要求。\n* \tfallback方法可以继续添加fallback。\n\n### Fallback Exception\n\n```Java\n\t@HystrixCommand(fallbackMethod = \"fallback1\")\n\tUser getUserById(String id) {\n\t    throw new RuntimeException(\"getUserById command failed\");\n\t}\n\t\n\t@HystrixCommand(fallbackMethod = \"fallback2\")\n\tUser fallback1(String id, Throwable e) {\n\t    assert \"getUserById command failed\".equals(e.getMessage());\n\t    throw new RuntimeException(\"fallback1 failed\");\n\t}\n\t\n\t@HystrixCommand(fallbackMethod = \"fallback3\")\n\tUser fallback2(String id) {\n\t    throw new RuntimeException(\"fallback2 failed\");\n\t}\n\t\n\t@HystrixCommand(fallbackMethod = \"staticFallback\")\n\tUser fallback3(String id, Throwable e) {\n\t    assert \"fallback2 failed\".equals(e.getMessage());\n\t    throw new RuntimeException(\"fallback3 failed\");\n\t}\n\t\n\tUser staticFallback(String id, Throwable e) {\n\t    assert \"fallback3 failed\".equals(e.getMessage());\n\t    return new User(\"def\", \"def\");\n\t}\n\t    \n\t// test\n\t@Test\n\tpublic void test() {\n\t\tassertEquals(\"def\", getUserById(\"1\").getName());\n\t}\n```\n\n###\tAsync/Sync fallback\n\n*\tsync command, sync fallback\n* \tasync command, sync fallback\n*  \tasync command, async fallback\n\n###\tDefault fallback\n\n该特性允许为整个类或具体的命令定义默认的回退。如果你有一组具有完全相同的回滚逻辑的命令，那么仍然需要为每个命令定义一个fallback，因为fallback应该具有与命令相同的签名，如下所示:\n\n```Java\n\t public class Service {\n\t    @RequestMapping(value = \"/test1\")\n\t    @HystrixCommand(fallbackMethod = \"fallback\")\n\t    public APIResponse test1(String param1) {\n\t        // some codes here\n\t        return APIResponse.success(\"success\");\n\t    }\n\t\n\t    @RequestMapping(value = \"/test2\")\n\t    @HystrixCommand(fallbackMethod = \"fallback\")\n\t    public APIResponse test2() {\n\t        // some codes here\n\t        return APIResponse.success(\"success\");\n\t    }\n\t\n\t    @RequestMapping(value = \"/test3\")\n\t    @HystrixCommand(fallbackMethod = \"fallback\")\n\t    public APIResponse test3(ObjectRequest obj) {\n\t        // some codes here\n\t        return APIResponse.success(\"success\");\n\t    }\n\t\n\t    private APIResponse fallback(String param1) {\n\t        return APIResponse.failed(\"Server is busy\");\n\t    }\n\t\n\t    private APIResponse fallback() {\n\t        return APIResponse.failed(\"Server is busy\");\n\t    }\n\t    \n\t    private APIResponse fallback(ObjectRequest obj) {\n\t        return APIResponse.failed(\"Server is busy\");\n\t    }\n\t}\n```\n\n默认的fallback特性减少冗余方法：\n\n```Java\n\t@DefaultProperties(defaultFallback = \"fallback\")\n\tpublic class Service {\n\t    @RequestMapping(value = \"/test1\")\n\t    @HystrixCommand\n\t    public APIResponse test1(String param1) {\n\t        // some codes here\n\t        return APIResponse.success(\"success\");\n\t    }\n\t\n\t    @RequestMapping(value = \"/test2\")\n\t    @HystrixCommand\n\t    public APIResponse test2() {\n\t        // some codes here\n\t        return APIResponse.success(\"success\");\n\t    }\n\t\n\t    @RequestMapping(value = \"/test3\")\n\t    @HystrixCommand\n\t    public APIResponse test3(ObjectRequest obj) {\n\t        // some codes here\n\t        return APIResponse.success(\"success\");\n\t    }\n\t\n\t    private APIResponse fallback() {\n\t        return APIResponse.failed(\"Server is busy\");\n\t    }\n\t}\n```\n\n默认的fallback不含任何参数，除了异常参数以获得执行异常，并且不应该抛出任何异常。以下是按下行优先级的顺序排列:\n\n1.\t@HystrixCommand 定义的 fallbackMethod。\n2. \t@HystrixCommand 定义的 defaultFallback。\n3. \t在 class 上 使用 @DefaultProperties 定义的 defaultFallback。\n\n###\t错误传播\n\n@HystrixCommand 提供忽略指定异常不触发fallback的功能。\n\n```Java\n    @HystrixCommand(ignoreExceptions = {BadRequestException.class})\n    public User getUserById(String id) {\n        return userResource.getUserById(id);\n    }\n```\t\n\n如果 userResource.getUserById(id) 抛出一个 BadRequestException，然后这个异常会裹着 HystrixBadRequestException 再抛出来，不会触发fallback。","source":"_posts/SpringCloud/Hystrix.md","raw":"---\ntitle: Hystrix之hystrix-javanica\ndate: 2017-07-16\ncategories: SpringCloud \ntags: \n- Hystrix\n- SpringCloud\n---\n\n##\t什么是 Hystrix？\n\n在分布式环境中，不可避免地会有一些服务依赖项会失败。Hystrix是一个库，它通过添加延迟容忍和容错逻辑来帮助控制这些分布式服务之间的交互。Hystrix通过隔离服务之间的访问点、阻止它们之间的级联故障，并提供备用选项，从而提高系统的整体弹性。\n\n##\tHystrix 解决什么问题？\n\n对于每个具有99.99％正常运行时间的30个服务。\n\n>99.99^30 = 99.7％正常运行时间\n\n>10亿次请求中的0.3％= 3,000,000次故障\n\n>2+小时停机时间/月，即使所有依赖关系都有很好的正常运行时间。\n\n即使所有依赖关系表现良好，即使0.01％的停机时间对数十个服务中的每一个服务的总体影响等同于每个月停机的潜在时间。\n\n对于高容量流量，单个后端依赖关系故障可能导致所有服务器上资源在几秒钟内饱和。\n\n##\tHystrix 工作原理\n\n*\t防止任何单个依赖关系使用容器（如Tomcat）全部线程。\n*\t减少负载并快速失败，而不是排队。\n*\t在可行的情况下提供回退以保护用户免受故障。\n*\t使用隔离技术（如隔板，泳道和断路器模式）来限制任何一个依赖的影响。\n*\t提供准实时的监控指标、报警。\n*\t提供低延迟的配置修改，并支持Hystrix大多数的动态属性更改，以便循环使用低延迟修改进行实时操作修改。\n*\t保护整个依赖客户端执行中的故障，而不仅仅是在网络流量中。\n\n##\tHystrix 功能实现\n\n*\t通过HystrixCommand或HystrixObservableCommand包装请求，\n实现在单独的线程中执行（这是命令模式的一种）。\n\n*\t超时调用比您定义的阈值长时间更长。提供一个默认配置，对于大多数依赖调用你可以通过”properties”来自定义它们的超时时间，以使它们的可用性达到99.5%或更高。\n\n*\t为每个依赖调用维护一个小的线程池（或信号量）; 如果它满了，那么依赖调用的请求将立即被拒绝，而不是排队等待。\n\n*\t处理成功，失败（由客户端抛出的异常），超时和线程拒绝。\n\n*\t跳闸断路器可以在一段时间内停止对特定服务的所有请求，如果服务的错误百分比通过阈值，可手动或自动停止。\n\n*\t当请求失败时执行回退逻辑，被拒绝，超时或短路。\n\n*\t准实时监控，运行时变更配置。\n\n##\thystrix-javanica\n\n使用完整的hystrix需要大量代码，可能需要花费大量时间写一个Hystrix命令。Javanica旨在通过引入注释来简化使用hystrix。Javanica通过在Spring中声明HystrixCommandAspect这个bean来实现，这里不再赘述AOP。\n\nJavanica 通过 ConfigurationManager 来管理属性配置。\n\n以下注解和代码效果等同。\n\n```Java\n    @HystrixCommand(commandProperties = {\n            @HystrixProperty(name = \"execution.isolation.thread.timeoutInMilliseconds\", value = \"500\")\n        })\n    public User getUserById(String id) {\n        return userResource.getUserById(id);\n    }\n```\n\n```Java\nConfigurationManager.getConfigInstance().setProperty(\"hystrix.command.getUserById.execution.isolation.thread.timeoutInMilliseconds\", \"500\");\n```\n\n\n###\tHystrixCommand 注解配置\n\n####\t隔离策略\n\n*\tExecutionIsolationStrategy.THREAD\n\n\t在一个单独的线程上执行，并发请求受到线程池中线程数量的限制。推荐使用。\n\t\n* \tExecutionIsolationStrategy.SEMAPHORE\n\n\t它在调用线程上执行，并发请求受到信号量计数的限制。开销太大，适用于非网络调用。\n\n\n####\tHystrixCommand\n\n参数|作用|默认值\n:-:|:-:|:-:\ngroupKey|所属分组，一个group共用一个线程池|当前类名\ncommandKey|业务key|当前方法名\nexecution.isolation.strategy|隔离策略|ExecutionIsolationStrategy.THREAD\nexecution.isolation.thread.timeoutInMilliseconds|超时时间|1000ms\nexecution.timeout.enable|超时开关|true\nexecution.isolation.thread.interruptOnTimeout|超时线程中断|true，Thread模式有效\nexecution.isolation.thread.interruptOnCancel|取消线程中断|false，Thread模式有效\nexecution.isolation.semaphore.maxConcurrentRequests|信号量最大并发度|10，SEMAPHORE模式有效\n\n####\tFallback\n\n参数|作用|默认值\n:-:|:-:|:-:\nfallback.isolation.semaphore.maxConcurrentRequests|fallback最大并发度|10\nfallback.enabled|fallback开关|true\n\n####\tCircuit Breaker\n\n参数|作用|默认值\n:-:|:-:|:-:\ncircuitBreaker.enabled|熔断器开关|true\ncircuitBreaker.requestVolumeThreshold|触发熔断的最小个数/10s|20\ncircuitBreaker.sleepWindowInMilliseconds|熔断多长时间后去尝试请求|5000ms\ncircuitBreaker.errorThresholdPercentage|触发熔断的失败百分比|50\ncircuitBreaker.forceOpen|强制打开|false，设为true会拒绝所有请求\ncircuitBreaker.forceClosed|强制关闭|false，设为true会允许所有请求通过\n\n####\tThreadPool\n\n参数|作用|默认值|实时修改\n:-:|:-:|:-:|:-:\ncoreSize|线程池大小|10|支持\nmaximumSize|队列大小|10|支持\nmaxQueueSize|BlockingQueue的最大长度|-1使用SynchronousQueue，否则使用LinkedBlockingQueue|初始化时确定，不允许运行时修改\nqueueSizeRejectionThreshold|队列大小拒绝阈值|5|支持，即使maxQueueSize没有达到，也会出现拒绝，因为允许动态更改拒绝队列的大小\nkeepAliveTimeMinutes|线程释放的空闲时间|1|支持\nallowMaximumSizeToDivergeFromCoreSize|maximumSize大于coreSize时，线程空闲时是否释放资源|false|支持\n\n###\tSpringMVC\n\n```xml\n\t<aop:aspectj-autoproxy/>\n    <bean id=\"hystrixAspect\" class=\"com.netflix.hystrix.contrib.javanica.aop.aspectj.HystrixCommandAspect\"></bean>\n```\n\n###\tSpringBoot\n\n```Java\n\t@Configuration\n\tpublic class HystrixConfiguration {\n\t\n\t  @Bean\n\t  public HystrixCommandAspect hystrixAspect() {\n\t    return new HystrixCommandAspect();\n\t  }\n\t\n\t}\n```\n\n###\tSync Execution\n\n```Java\n\t@HystrixCommand(groupKey=\"UserGroup\", commandKey = \"GetUserByIdCommand\")\n\tpublic User getUserById(String id) {\n\t    return userResource.getUserById(id);\n\t}\n```\n\n###\tAsync Execution\n\n```Java\n\t@HystrixCommand\n\tpublic Future<User> getUserByIdAsync(final String id) {\n\t    return new AsyncResult<User>() {\n\t        @Override\n\t        public User invoke() {\n\t            return userResource.getUserById(id);\n\t        }\n\t    };\n\t}\n```\n\n###\tReactive Exection\n\n```Java\n\t@HystrixCommand\n\tpublic Observable<User> getUserById(final String id) {\n\t    return Observable.create(new Observable.OnSubscribe<User>() {\n\t            @Override\n\t            public void call(Subscriber<? super User> observer) {\n\t                try {\n\t                    if (!observer.isUnsubscribed()) {\n\t                        observer.onNext(new User(id, name + id));\n\t                        observer.onCompleted();\n\t                    }\n\t                } catch (Exception e) {\n\t                    observer.onError(e);\n\t                }\n\t            }\n\t        });\n\t}\n```\n\n###\tFallback\n\n```Java\n\t@HystrixCommand(fallbackMethod = \"defaultUser\")\n\tpublic User getUserById(String id) {\n\t    return userResource.getUserById(id);\n\t}\n\t\n\tprivate User defaultUser(String id) {\n\t    return new User(\"def\", \"def\");\n\t}\n```\n\n*\tHystrix命令和fallback应该在同一个类中，并且具有相同的方法签名(失败执行异常的可选参数)。\n*  \t如果需要异常，在末尾添加Throwable，对访问修饰符无要求。\n* \tfallback方法可以继续添加fallback。\n\n### Fallback Exception\n\n```Java\n\t@HystrixCommand(fallbackMethod = \"fallback1\")\n\tUser getUserById(String id) {\n\t    throw new RuntimeException(\"getUserById command failed\");\n\t}\n\t\n\t@HystrixCommand(fallbackMethod = \"fallback2\")\n\tUser fallback1(String id, Throwable e) {\n\t    assert \"getUserById command failed\".equals(e.getMessage());\n\t    throw new RuntimeException(\"fallback1 failed\");\n\t}\n\t\n\t@HystrixCommand(fallbackMethod = \"fallback3\")\n\tUser fallback2(String id) {\n\t    throw new RuntimeException(\"fallback2 failed\");\n\t}\n\t\n\t@HystrixCommand(fallbackMethod = \"staticFallback\")\n\tUser fallback3(String id, Throwable e) {\n\t    assert \"fallback2 failed\".equals(e.getMessage());\n\t    throw new RuntimeException(\"fallback3 failed\");\n\t}\n\t\n\tUser staticFallback(String id, Throwable e) {\n\t    assert \"fallback3 failed\".equals(e.getMessage());\n\t    return new User(\"def\", \"def\");\n\t}\n\t    \n\t// test\n\t@Test\n\tpublic void test() {\n\t\tassertEquals(\"def\", getUserById(\"1\").getName());\n\t}\n```\n\n###\tAsync/Sync fallback\n\n*\tsync command, sync fallback\n* \tasync command, sync fallback\n*  \tasync command, async fallback\n\n###\tDefault fallback\n\n该特性允许为整个类或具体的命令定义默认的回退。如果你有一组具有完全相同的回滚逻辑的命令，那么仍然需要为每个命令定义一个fallback，因为fallback应该具有与命令相同的签名，如下所示:\n\n```Java\n\t public class Service {\n\t    @RequestMapping(value = \"/test1\")\n\t    @HystrixCommand(fallbackMethod = \"fallback\")\n\t    public APIResponse test1(String param1) {\n\t        // some codes here\n\t        return APIResponse.success(\"success\");\n\t    }\n\t\n\t    @RequestMapping(value = \"/test2\")\n\t    @HystrixCommand(fallbackMethod = \"fallback\")\n\t    public APIResponse test2() {\n\t        // some codes here\n\t        return APIResponse.success(\"success\");\n\t    }\n\t\n\t    @RequestMapping(value = \"/test3\")\n\t    @HystrixCommand(fallbackMethod = \"fallback\")\n\t    public APIResponse test3(ObjectRequest obj) {\n\t        // some codes here\n\t        return APIResponse.success(\"success\");\n\t    }\n\t\n\t    private APIResponse fallback(String param1) {\n\t        return APIResponse.failed(\"Server is busy\");\n\t    }\n\t\n\t    private APIResponse fallback() {\n\t        return APIResponse.failed(\"Server is busy\");\n\t    }\n\t    \n\t    private APIResponse fallback(ObjectRequest obj) {\n\t        return APIResponse.failed(\"Server is busy\");\n\t    }\n\t}\n```\n\n默认的fallback特性减少冗余方法：\n\n```Java\n\t@DefaultProperties(defaultFallback = \"fallback\")\n\tpublic class Service {\n\t    @RequestMapping(value = \"/test1\")\n\t    @HystrixCommand\n\t    public APIResponse test1(String param1) {\n\t        // some codes here\n\t        return APIResponse.success(\"success\");\n\t    }\n\t\n\t    @RequestMapping(value = \"/test2\")\n\t    @HystrixCommand\n\t    public APIResponse test2() {\n\t        // some codes here\n\t        return APIResponse.success(\"success\");\n\t    }\n\t\n\t    @RequestMapping(value = \"/test3\")\n\t    @HystrixCommand\n\t    public APIResponse test3(ObjectRequest obj) {\n\t        // some codes here\n\t        return APIResponse.success(\"success\");\n\t    }\n\t\n\t    private APIResponse fallback() {\n\t        return APIResponse.failed(\"Server is busy\");\n\t    }\n\t}\n```\n\n默认的fallback不含任何参数，除了异常参数以获得执行异常，并且不应该抛出任何异常。以下是按下行优先级的顺序排列:\n\n1.\t@HystrixCommand 定义的 fallbackMethod。\n2. \t@HystrixCommand 定义的 defaultFallback。\n3. \t在 class 上 使用 @DefaultProperties 定义的 defaultFallback。\n\n###\t错误传播\n\n@HystrixCommand 提供忽略指定异常不触发fallback的功能。\n\n```Java\n    @HystrixCommand(ignoreExceptions = {BadRequestException.class})\n    public User getUserById(String id) {\n        return userResource.getUserById(id);\n    }\n```\t\n\n如果 userResource.getUserById(id) 抛出一个 BadRequestException，然后这个异常会裹着 HystrixBadRequestException 再抛出来，不会触发fallback。","slug":"SpringCloud/Hystrix","published":1,"updated":"2017-07-19T09:12:51.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1j8f2ir001p7h9mw3pvjkvg","content":"<h2 id=\"什么是-Hystrix？\"><a href=\"#什么是-Hystrix？\" class=\"headerlink\" title=\"什么是 Hystrix？\"></a>什么是 Hystrix？</h2><p>在分布式环境中，不可避免地会有一些服务依赖项会失败。Hystrix是一个库，它通过添加延迟容忍和容错逻辑来帮助控制这些分布式服务之间的交互。Hystrix通过隔离服务之间的访问点、阻止它们之间的级联故障，并提供备用选项，从而提高系统的整体弹性。</p>\n<h2 id=\"Hystrix-解决什么问题？\"><a href=\"#Hystrix-解决什么问题？\" class=\"headerlink\" title=\"Hystrix 解决什么问题？\"></a>Hystrix 解决什么问题？</h2><p>对于每个具有99.99％正常运行时间的30个服务。</p>\n<blockquote>\n<p>99.99^30 = 99.7％正常运行时间</p>\n<p>10亿次请求中的0.3％= 3,000,000次故障</p>\n<p>2+小时停机时间/月，即使所有依赖关系都有很好的正常运行时间。</p>\n</blockquote>\n<p>即使所有依赖关系表现良好，即使0.01％的停机时间对数十个服务中的每一个服务的总体影响等同于每个月停机的潜在时间。</p>\n<p>对于高容量流量，单个后端依赖关系故障可能导致所有服务器上资源在几秒钟内饱和。</p>\n<h2 id=\"Hystrix-工作原理\"><a href=\"#Hystrix-工作原理\" class=\"headerlink\" title=\"Hystrix 工作原理\"></a>Hystrix 工作原理</h2><ul>\n<li>防止任何单个依赖关系使用容器（如Tomcat）全部线程。</li>\n<li>减少负载并快速失败，而不是排队。</li>\n<li>在可行的情况下提供回退以保护用户免受故障。</li>\n<li>使用隔离技术（如隔板，泳道和断路器模式）来限制任何一个依赖的影响。</li>\n<li>提供准实时的监控指标、报警。</li>\n<li>提供低延迟的配置修改，并支持Hystrix大多数的动态属性更改，以便循环使用低延迟修改进行实时操作修改。</li>\n<li>保护整个依赖客户端执行中的故障，而不仅仅是在网络流量中。</li>\n</ul>\n<h2 id=\"Hystrix-功能实现\"><a href=\"#Hystrix-功能实现\" class=\"headerlink\" title=\"Hystrix 功能实现\"></a>Hystrix 功能实现</h2><ul>\n<li><p>通过HystrixCommand或HystrixObservableCommand包装请求，<br>实现在单独的线程中执行（这是命令模式的一种）。</p>\n</li>\n<li><p>超时调用比您定义的阈值长时间更长。提供一个默认配置，对于大多数依赖调用你可以通过”properties”来自定义它们的超时时间，以使它们的可用性达到99.5%或更高。</p>\n</li>\n<li><p>为每个依赖调用维护一个小的线程池（或信号量）; 如果它满了，那么依赖调用的请求将立即被拒绝，而不是排队等待。</p>\n</li>\n<li><p>处理成功，失败（由客户端抛出的异常），超时和线程拒绝。</p>\n</li>\n<li><p>跳闸断路器可以在一段时间内停止对特定服务的所有请求，如果服务的错误百分比通过阈值，可手动或自动停止。</p>\n</li>\n<li><p>当请求失败时执行回退逻辑，被拒绝，超时或短路。</p>\n</li>\n<li><p>准实时监控，运行时变更配置。</p>\n</li>\n</ul>\n<h2 id=\"hystrix-javanica\"><a href=\"#hystrix-javanica\" class=\"headerlink\" title=\"hystrix-javanica\"></a>hystrix-javanica</h2><p>使用完整的hystrix需要大量代码，可能需要花费大量时间写一个Hystrix命令。Javanica旨在通过引入注释来简化使用hystrix。Javanica通过在Spring中声明HystrixCommandAspect这个bean来实现，这里不再赘述AOP。</p>\n<p>Javanica 通过 ConfigurationManager 来管理属性配置。</p>\n<p>以下注解和代码效果等同。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@HystrixCommand</span>(commandProperties = &#123;</span><br><span class=\"line\">        <span class=\"meta\">@HystrixProperty</span>(name = <span class=\"string\">\"execution.isolation.thread.timeoutInMilliseconds\"</span>, value = <span class=\"string\">\"500\"</span>)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> User <span class=\"title\">getUserById</span><span class=\"params\">(String id)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> userResource.getUserById(id);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ConfigurationManager.getConfigInstance().setProperty(<span class=\"string\">\"hystrix.command.getUserById.execution.isolation.thread.timeoutInMilliseconds\"</span>, <span class=\"string\">\"500\"</span>);</span><br></pre></td></tr></table></figure>\n<h3 id=\"HystrixCommand-注解配置\"><a href=\"#HystrixCommand-注解配置\" class=\"headerlink\" title=\"HystrixCommand 注解配置\"></a>HystrixCommand 注解配置</h3><h4 id=\"隔离策略\"><a href=\"#隔离策略\" class=\"headerlink\" title=\"隔离策略\"></a>隔离策略</h4><ul>\n<li><p>ExecutionIsolationStrategy.THREAD</p>\n<p>在一个单独的线程上执行，并发请求受到线程池中线程数量的限制。推荐使用。</p>\n</li>\n<li><p>ExecutionIsolationStrategy.SEMAPHORE</p>\n<p>它在调用线程上执行，并发请求受到信号量计数的限制。开销太大，适用于非网络调用。</p>\n</li>\n</ul>\n<h4 id=\"HystrixCommand\"><a href=\"#HystrixCommand\" class=\"headerlink\" title=\"HystrixCommand\"></a>HystrixCommand</h4><table>\n<thead>\n<tr>\n<th style=\"text-align:center\">参数</th>\n<th style=\"text-align:center\">作用</th>\n<th style=\"text-align:center\">默认值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">groupKey</td>\n<td style=\"text-align:center\">所属分组，一个group共用一个线程池</td>\n<td style=\"text-align:center\">当前类名</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">commandKey</td>\n<td style=\"text-align:center\">业务key</td>\n<td style=\"text-align:center\">当前方法名</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">execution.isolation.strategy</td>\n<td style=\"text-align:center\">隔离策略</td>\n<td style=\"text-align:center\">ExecutionIsolationStrategy.THREAD</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">execution.isolation.thread.timeoutInMilliseconds</td>\n<td style=\"text-align:center\">超时时间</td>\n<td style=\"text-align:center\">1000ms</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">execution.timeout.enable</td>\n<td style=\"text-align:center\">超时开关</td>\n<td style=\"text-align:center\">true</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">execution.isolation.thread.interruptOnTimeout</td>\n<td style=\"text-align:center\">超时线程中断</td>\n<td style=\"text-align:center\">true，Thread模式有效</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">execution.isolation.thread.interruptOnCancel</td>\n<td style=\"text-align:center\">取消线程中断</td>\n<td style=\"text-align:center\">false，Thread模式有效</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">execution.isolation.semaphore.maxConcurrentRequests</td>\n<td style=\"text-align:center\">信号量最大并发度</td>\n<td style=\"text-align:center\">10，SEMAPHORE模式有效</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"Fallback\"><a href=\"#Fallback\" class=\"headerlink\" title=\"Fallback\"></a>Fallback</h4><table>\n<thead>\n<tr>\n<th style=\"text-align:center\">参数</th>\n<th style=\"text-align:center\">作用</th>\n<th style=\"text-align:center\">默认值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">fallback.isolation.semaphore.maxConcurrentRequests</td>\n<td style=\"text-align:center\">fallback最大并发度</td>\n<td style=\"text-align:center\">10</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">fallback.enabled</td>\n<td style=\"text-align:center\">fallback开关</td>\n<td style=\"text-align:center\">true</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"Circuit-Breaker\"><a href=\"#Circuit-Breaker\" class=\"headerlink\" title=\"Circuit Breaker\"></a>Circuit Breaker</h4><table>\n<thead>\n<tr>\n<th style=\"text-align:center\">参数</th>\n<th style=\"text-align:center\">作用</th>\n<th style=\"text-align:center\">默认值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">circuitBreaker.enabled</td>\n<td style=\"text-align:center\">熔断器开关</td>\n<td style=\"text-align:center\">true</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">circuitBreaker.requestVolumeThreshold</td>\n<td style=\"text-align:center\">触发熔断的最小个数/10s</td>\n<td style=\"text-align:center\">20</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">circuitBreaker.sleepWindowInMilliseconds</td>\n<td style=\"text-align:center\">熔断多长时间后去尝试请求</td>\n<td style=\"text-align:center\">5000ms</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">circuitBreaker.errorThresholdPercentage</td>\n<td style=\"text-align:center\">触发熔断的失败百分比</td>\n<td style=\"text-align:center\">50</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">circuitBreaker.forceOpen</td>\n<td style=\"text-align:center\">强制打开</td>\n<td style=\"text-align:center\">false，设为true会拒绝所有请求</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">circuitBreaker.forceClosed</td>\n<td style=\"text-align:center\">强制关闭</td>\n<td style=\"text-align:center\">false，设为true会允许所有请求通过</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"ThreadPool\"><a href=\"#ThreadPool\" class=\"headerlink\" title=\"ThreadPool\"></a>ThreadPool</h4><table>\n<thead>\n<tr>\n<th style=\"text-align:center\">参数</th>\n<th style=\"text-align:center\">作用</th>\n<th style=\"text-align:center\">默认值</th>\n<th style=\"text-align:center\">实时修改</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">coreSize</td>\n<td style=\"text-align:center\">线程池大小</td>\n<td style=\"text-align:center\">10</td>\n<td style=\"text-align:center\">支持</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">maximumSize</td>\n<td style=\"text-align:center\">队列大小</td>\n<td style=\"text-align:center\">10</td>\n<td style=\"text-align:center\">支持</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">maxQueueSize</td>\n<td style=\"text-align:center\">BlockingQueue的最大长度</td>\n<td style=\"text-align:center\">-1使用SynchronousQueue，否则使用LinkedBlockingQueue</td>\n<td style=\"text-align:center\">初始化时确定，不允许运行时修改</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">queueSizeRejectionThreshold</td>\n<td style=\"text-align:center\">队列大小拒绝阈值</td>\n<td style=\"text-align:center\">5</td>\n<td style=\"text-align:center\">支持，即使maxQueueSize没有达到，也会出现拒绝，因为允许动态更改拒绝队列的大小</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">keepAliveTimeMinutes</td>\n<td style=\"text-align:center\">线程释放的空闲时间</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">支持</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">allowMaximumSizeToDivergeFromCoreSize</td>\n<td style=\"text-align:center\">maximumSize大于coreSize时，线程空闲时是否释放资源</td>\n<td style=\"text-align:center\">false</td>\n<td style=\"text-align:center\">支持</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"SpringMVC\"><a href=\"#SpringMVC\" class=\"headerlink\" title=\"SpringMVC\"></a>SpringMVC</h3><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">aop:aspectj-autoproxy</span>/&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"hystrixAspect\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com.netflix.hystrix.contrib.javanica.aop.aspectj.HystrixCommandAspect\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"SpringBoot\"><a href=\"#SpringBoot\" class=\"headerlink\" title=\"SpringBoot\"></a>SpringBoot</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HystrixConfiguration</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Bean</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> HystrixCommandAspect <span class=\"title\">hystrixAspect</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> HystrixCommandAspect();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Sync-Execution\"><a href=\"#Sync-Execution\" class=\"headerlink\" title=\"Sync Execution\"></a>Sync Execution</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@HystrixCommand</span>(groupKey=<span class=\"string\">\"UserGroup\"</span>, commandKey = <span class=\"string\">\"GetUserByIdCommand\"</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> User <span class=\"title\">getUserById</span><span class=\"params\">(String id)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> userResource.getUserById(id);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Async-Execution\"><a href=\"#Async-Execution\" class=\"headerlink\" title=\"Async Execution\"></a>Async Execution</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@HystrixCommand</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Future&lt;User&gt; <span class=\"title\">getUserByIdAsync</span><span class=\"params\">(<span class=\"keyword\">final</span> String id)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> AsyncResult&lt;User&gt;() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> User <span class=\"title\">invoke</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> userResource.getUserById(id);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Reactive-Exection\"><a href=\"#Reactive-Exection\" class=\"headerlink\" title=\"Reactive Exection\"></a>Reactive Exection</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@HystrixCommand</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Observable&lt;User&gt; <span class=\"title\">getUserById</span><span class=\"params\">(<span class=\"keyword\">final</span> String id)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Observable.create(<span class=\"keyword\">new</span> Observable.OnSubscribe&lt;User&gt;() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">call</span><span class=\"params\">(Subscriber&lt;? <span class=\"keyword\">super</span> User&gt; observer)</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (!observer.isUnsubscribed()) &#123;</span><br><span class=\"line\">                        observer.onNext(<span class=\"keyword\">new</span> User(id, name + id));</span><br><span class=\"line\">                        observer.onCompleted();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                    observer.onError(e);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Fallback-1\"><a href=\"#Fallback-1\" class=\"headerlink\" title=\"Fallback\"></a>Fallback</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@HystrixCommand</span>(fallbackMethod = <span class=\"string\">\"defaultUser\"</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> User <span class=\"title\">getUserById</span><span class=\"params\">(String id)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> userResource.getUserById(id);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> User <span class=\"title\">defaultUser</span><span class=\"params\">(String id)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> User(<span class=\"string\">\"def\"</span>, <span class=\"string\">\"def\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>Hystrix命令和fallback应该在同一个类中，并且具有相同的方法签名(失败执行异常的可选参数)。</li>\n<li>如果需要异常，在末尾添加Throwable，对访问修饰符无要求。</li>\n<li>fallback方法可以继续添加fallback。</li>\n</ul>\n<h3 id=\"Fallback-Exception\"><a href=\"#Fallback-Exception\" class=\"headerlink\" title=\"Fallback Exception\"></a>Fallback Exception</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@HystrixCommand</span>(fallbackMethod = <span class=\"string\">\"fallback1\"</span>)</span><br><span class=\"line\"><span class=\"function\">User <span class=\"title\">getUserById</span><span class=\"params\">(String id)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"getUserById command failed\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@HystrixCommand</span>(fallbackMethod = <span class=\"string\">\"fallback2\"</span>)</span><br><span class=\"line\"><span class=\"function\">User <span class=\"title\">fallback1</span><span class=\"params\">(String id, Throwable e)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">assert</span> <span class=\"string\">\"getUserById command failed\"</span>.equals(e.getMessage());</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"fallback1 failed\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@HystrixCommand</span>(fallbackMethod = <span class=\"string\">\"fallback3\"</span>)</span><br><span class=\"line\"><span class=\"function\">User <span class=\"title\">fallback2</span><span class=\"params\">(String id)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"fallback2 failed\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@HystrixCommand</span>(fallbackMethod = <span class=\"string\">\"staticFallback\"</span>)</span><br><span class=\"line\"><span class=\"function\">User <span class=\"title\">fallback3</span><span class=\"params\">(String id, Throwable e)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">assert</span> <span class=\"string\">\"fallback2 failed\"</span>.equals(e.getMessage());</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"fallback3 failed\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">User <span class=\"title\">staticFallback</span><span class=\"params\">(String id, Throwable e)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">assert</span> <span class=\"string\">\"fallback3 failed\"</span>.equals(e.getMessage());</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> User(<span class=\"string\">\"def\"</span>, <span class=\"string\">\"def\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">// test</span></span><br><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tassertEquals(<span class=\"string\">\"def\"</span>, getUserById(<span class=\"string\">\"1\"</span>).getName());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Async-Sync-fallback\"><a href=\"#Async-Sync-fallback\" class=\"headerlink\" title=\"Async/Sync fallback\"></a>Async/Sync fallback</h3><ul>\n<li>sync command, sync fallback</li>\n<li>async command, sync fallback</li>\n<li>async command, async fallback</li>\n</ul>\n<h3 id=\"Default-fallback\"><a href=\"#Default-fallback\" class=\"headerlink\" title=\"Default fallback\"></a>Default fallback</h3><p>该特性允许为整个类或具体的命令定义默认的回退。如果你有一组具有完全相同的回滚逻辑的命令，那么仍然需要为每个命令定义一个fallback，因为fallback应该具有与命令相同的签名，如下所示:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Service</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping</span>(value = <span class=\"string\">\"/test1\"</span>)</span><br><span class=\"line\">    <span class=\"meta\">@HystrixCommand</span>(fallbackMethod = <span class=\"string\">\"fallback\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> APIResponse <span class=\"title\">test1</span><span class=\"params\">(String param1)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// some codes here</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> APIResponse.success(<span class=\"string\">\"success\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping</span>(value = <span class=\"string\">\"/test2\"</span>)</span><br><span class=\"line\">    <span class=\"meta\">@HystrixCommand</span>(fallbackMethod = <span class=\"string\">\"fallback\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> APIResponse <span class=\"title\">test2</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// some codes here</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> APIResponse.success(<span class=\"string\">\"success\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping</span>(value = <span class=\"string\">\"/test3\"</span>)</span><br><span class=\"line\">    <span class=\"meta\">@HystrixCommand</span>(fallbackMethod = <span class=\"string\">\"fallback\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> APIResponse <span class=\"title\">test3</span><span class=\"params\">(ObjectRequest obj)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// some codes here</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> APIResponse.success(<span class=\"string\">\"success\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> APIResponse <span class=\"title\">fallback</span><span class=\"params\">(String param1)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> APIResponse.failed(<span class=\"string\">\"Server is busy\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> APIResponse <span class=\"title\">fallback</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> APIResponse.failed(<span class=\"string\">\"Server is busy\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> APIResponse <span class=\"title\">fallback</span><span class=\"params\">(ObjectRequest obj)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> APIResponse.failed(<span class=\"string\">\"Server is busy\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>默认的fallback特性减少冗余方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@DefaultProperties</span>(defaultFallback = <span class=\"string\">\"fallback\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Service</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping</span>(value = <span class=\"string\">\"/test1\"</span>)</span><br><span class=\"line\">    <span class=\"meta\">@HystrixCommand</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> APIResponse <span class=\"title\">test1</span><span class=\"params\">(String param1)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// some codes here</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> APIResponse.success(<span class=\"string\">\"success\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping</span>(value = <span class=\"string\">\"/test2\"</span>)</span><br><span class=\"line\">    <span class=\"meta\">@HystrixCommand</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> APIResponse <span class=\"title\">test2</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// some codes here</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> APIResponse.success(<span class=\"string\">\"success\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping</span>(value = <span class=\"string\">\"/test3\"</span>)</span><br><span class=\"line\">    <span class=\"meta\">@HystrixCommand</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> APIResponse <span class=\"title\">test3</span><span class=\"params\">(ObjectRequest obj)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// some codes here</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> APIResponse.success(<span class=\"string\">\"success\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> APIResponse <span class=\"title\">fallback</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> APIResponse.failed(<span class=\"string\">\"Server is busy\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>默认的fallback不含任何参数，除了异常参数以获得执行异常，并且不应该抛出任何异常。以下是按下行优先级的顺序排列:</p>\n<ol>\n<li>@HystrixCommand 定义的 fallbackMethod。</li>\n<li>@HystrixCommand 定义的 defaultFallback。</li>\n<li>在 class 上 使用 @DefaultProperties 定义的 defaultFallback。</li>\n</ol>\n<h3 id=\"错误传播\"><a href=\"#错误传播\" class=\"headerlink\" title=\"错误传播\"></a>错误传播</h3><p>@HystrixCommand 提供忽略指定异常不触发fallback的功能。</p>\n<pre><code class=\"Java\"><span class=\"meta\">@HystrixCommand</span>(ignoreExceptions = {BadRequestException.class})\n<span class=\"function\"><span class=\"keyword\">public</span> User <span class=\"title\">getUserById</span><span class=\"params\">(String id)</span> </span>{\n    <span class=\"keyword\">return</span> userResource.getUserById(id);\n}\n</code></pre>\n<p>如果 userResource.getUserById(id) 抛出一个 BadRequestException，然后这个异常会裹着 HystrixBadRequestException 再抛出来，不会触发fallback。</p>\n","excerpt":"","more":"<h2 id=\"什么是-Hystrix？\"><a href=\"#什么是-Hystrix？\" class=\"headerlink\" title=\"什么是 Hystrix？\"></a>什么是 Hystrix？</h2><p>在分布式环境中，不可避免地会有一些服务依赖项会失败。Hystrix是一个库，它通过添加延迟容忍和容错逻辑来帮助控制这些分布式服务之间的交互。Hystrix通过隔离服务之间的访问点、阻止它们之间的级联故障，并提供备用选项，从而提高系统的整体弹性。</p>\n<h2 id=\"Hystrix-解决什么问题？\"><a href=\"#Hystrix-解决什么问题？\" class=\"headerlink\" title=\"Hystrix 解决什么问题？\"></a>Hystrix 解决什么问题？</h2><p>对于每个具有99.99％正常运行时间的30个服务。</p>\n<blockquote>\n<p>99.99^30 = 99.7％正常运行时间</p>\n<p>10亿次请求中的0.3％= 3,000,000次故障</p>\n<p>2+小时停机时间/月，即使所有依赖关系都有很好的正常运行时间。</p>\n</blockquote>\n<p>即使所有依赖关系表现良好，即使0.01％的停机时间对数十个服务中的每一个服务的总体影响等同于每个月停机的潜在时间。</p>\n<p>对于高容量流量，单个后端依赖关系故障可能导致所有服务器上资源在几秒钟内饱和。</p>\n<h2 id=\"Hystrix-工作原理\"><a href=\"#Hystrix-工作原理\" class=\"headerlink\" title=\"Hystrix 工作原理\"></a>Hystrix 工作原理</h2><ul>\n<li>防止任何单个依赖关系使用容器（如Tomcat）全部线程。</li>\n<li>减少负载并快速失败，而不是排队。</li>\n<li>在可行的情况下提供回退以保护用户免受故障。</li>\n<li>使用隔离技术（如隔板，泳道和断路器模式）来限制任何一个依赖的影响。</li>\n<li>提供准实时的监控指标、报警。</li>\n<li>提供低延迟的配置修改，并支持Hystrix大多数的动态属性更改，以便循环使用低延迟修改进行实时操作修改。</li>\n<li>保护整个依赖客户端执行中的故障，而不仅仅是在网络流量中。</li>\n</ul>\n<h2 id=\"Hystrix-功能实现\"><a href=\"#Hystrix-功能实现\" class=\"headerlink\" title=\"Hystrix 功能实现\"></a>Hystrix 功能实现</h2><ul>\n<li><p>通过HystrixCommand或HystrixObservableCommand包装请求，<br>实现在单独的线程中执行（这是命令模式的一种）。</p>\n</li>\n<li><p>超时调用比您定义的阈值长时间更长。提供一个默认配置，对于大多数依赖调用你可以通过”properties”来自定义它们的超时时间，以使它们的可用性达到99.5%或更高。</p>\n</li>\n<li><p>为每个依赖调用维护一个小的线程池（或信号量）; 如果它满了，那么依赖调用的请求将立即被拒绝，而不是排队等待。</p>\n</li>\n<li><p>处理成功，失败（由客户端抛出的异常），超时和线程拒绝。</p>\n</li>\n<li><p>跳闸断路器可以在一段时间内停止对特定服务的所有请求，如果服务的错误百分比通过阈值，可手动或自动停止。</p>\n</li>\n<li><p>当请求失败时执行回退逻辑，被拒绝，超时或短路。</p>\n</li>\n<li><p>准实时监控，运行时变更配置。</p>\n</li>\n</ul>\n<h2 id=\"hystrix-javanica\"><a href=\"#hystrix-javanica\" class=\"headerlink\" title=\"hystrix-javanica\"></a>hystrix-javanica</h2><p>使用完整的hystrix需要大量代码，可能需要花费大量时间写一个Hystrix命令。Javanica旨在通过引入注释来简化使用hystrix。Javanica通过在Spring中声明HystrixCommandAspect这个bean来实现，这里不再赘述AOP。</p>\n<p>Javanica 通过 ConfigurationManager 来管理属性配置。</p>\n<p>以下注解和代码效果等同。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@HystrixCommand</span>(commandProperties = &#123;</span><br><span class=\"line\">        <span class=\"meta\">@HystrixProperty</span>(name = <span class=\"string\">\"execution.isolation.thread.timeoutInMilliseconds\"</span>, value = <span class=\"string\">\"500\"</span>)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> User <span class=\"title\">getUserById</span><span class=\"params\">(String id)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> userResource.getUserById(id);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ConfigurationManager.getConfigInstance().setProperty(<span class=\"string\">\"hystrix.command.getUserById.execution.isolation.thread.timeoutInMilliseconds\"</span>, <span class=\"string\">\"500\"</span>);</span><br></pre></td></tr></table></figure>\n<h3 id=\"HystrixCommand-注解配置\"><a href=\"#HystrixCommand-注解配置\" class=\"headerlink\" title=\"HystrixCommand 注解配置\"></a>HystrixCommand 注解配置</h3><h4 id=\"隔离策略\"><a href=\"#隔离策略\" class=\"headerlink\" title=\"隔离策略\"></a>隔离策略</h4><ul>\n<li><p>ExecutionIsolationStrategy.THREAD</p>\n<p>在一个单独的线程上执行，并发请求受到线程池中线程数量的限制。推荐使用。</p>\n</li>\n<li><p>ExecutionIsolationStrategy.SEMAPHORE</p>\n<p>它在调用线程上执行，并发请求受到信号量计数的限制。开销太大，适用于非网络调用。</p>\n</li>\n</ul>\n<h4 id=\"HystrixCommand\"><a href=\"#HystrixCommand\" class=\"headerlink\" title=\"HystrixCommand\"></a>HystrixCommand</h4><table>\n<thead>\n<tr>\n<th style=\"text-align:center\">参数</th>\n<th style=\"text-align:center\">作用</th>\n<th style=\"text-align:center\">默认值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">groupKey</td>\n<td style=\"text-align:center\">所属分组，一个group共用一个线程池</td>\n<td style=\"text-align:center\">当前类名</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">commandKey</td>\n<td style=\"text-align:center\">业务key</td>\n<td style=\"text-align:center\">当前方法名</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">execution.isolation.strategy</td>\n<td style=\"text-align:center\">隔离策略</td>\n<td style=\"text-align:center\">ExecutionIsolationStrategy.THREAD</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">execution.isolation.thread.timeoutInMilliseconds</td>\n<td style=\"text-align:center\">超时时间</td>\n<td style=\"text-align:center\">1000ms</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">execution.timeout.enable</td>\n<td style=\"text-align:center\">超时开关</td>\n<td style=\"text-align:center\">true</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">execution.isolation.thread.interruptOnTimeout</td>\n<td style=\"text-align:center\">超时线程中断</td>\n<td style=\"text-align:center\">true，Thread模式有效</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">execution.isolation.thread.interruptOnCancel</td>\n<td style=\"text-align:center\">取消线程中断</td>\n<td style=\"text-align:center\">false，Thread模式有效</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">execution.isolation.semaphore.maxConcurrentRequests</td>\n<td style=\"text-align:center\">信号量最大并发度</td>\n<td style=\"text-align:center\">10，SEMAPHORE模式有效</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"Fallback\"><a href=\"#Fallback\" class=\"headerlink\" title=\"Fallback\"></a>Fallback</h4><table>\n<thead>\n<tr>\n<th style=\"text-align:center\">参数</th>\n<th style=\"text-align:center\">作用</th>\n<th style=\"text-align:center\">默认值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">fallback.isolation.semaphore.maxConcurrentRequests</td>\n<td style=\"text-align:center\">fallback最大并发度</td>\n<td style=\"text-align:center\">10</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">fallback.enabled</td>\n<td style=\"text-align:center\">fallback开关</td>\n<td style=\"text-align:center\">true</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"Circuit-Breaker\"><a href=\"#Circuit-Breaker\" class=\"headerlink\" title=\"Circuit Breaker\"></a>Circuit Breaker</h4><table>\n<thead>\n<tr>\n<th style=\"text-align:center\">参数</th>\n<th style=\"text-align:center\">作用</th>\n<th style=\"text-align:center\">默认值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">circuitBreaker.enabled</td>\n<td style=\"text-align:center\">熔断器开关</td>\n<td style=\"text-align:center\">true</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">circuitBreaker.requestVolumeThreshold</td>\n<td style=\"text-align:center\">触发熔断的最小个数/10s</td>\n<td style=\"text-align:center\">20</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">circuitBreaker.sleepWindowInMilliseconds</td>\n<td style=\"text-align:center\">熔断多长时间后去尝试请求</td>\n<td style=\"text-align:center\">5000ms</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">circuitBreaker.errorThresholdPercentage</td>\n<td style=\"text-align:center\">触发熔断的失败百分比</td>\n<td style=\"text-align:center\">50</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">circuitBreaker.forceOpen</td>\n<td style=\"text-align:center\">强制打开</td>\n<td style=\"text-align:center\">false，设为true会拒绝所有请求</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">circuitBreaker.forceClosed</td>\n<td style=\"text-align:center\">强制关闭</td>\n<td style=\"text-align:center\">false，设为true会允许所有请求通过</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"ThreadPool\"><a href=\"#ThreadPool\" class=\"headerlink\" title=\"ThreadPool\"></a>ThreadPool</h4><table>\n<thead>\n<tr>\n<th style=\"text-align:center\">参数</th>\n<th style=\"text-align:center\">作用</th>\n<th style=\"text-align:center\">默认值</th>\n<th style=\"text-align:center\">实时修改</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">coreSize</td>\n<td style=\"text-align:center\">线程池大小</td>\n<td style=\"text-align:center\">10</td>\n<td style=\"text-align:center\">支持</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">maximumSize</td>\n<td style=\"text-align:center\">队列大小</td>\n<td style=\"text-align:center\">10</td>\n<td style=\"text-align:center\">支持</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">maxQueueSize</td>\n<td style=\"text-align:center\">BlockingQueue的最大长度</td>\n<td style=\"text-align:center\">-1使用SynchronousQueue，否则使用LinkedBlockingQueue</td>\n<td style=\"text-align:center\">初始化时确定，不允许运行时修改</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">queueSizeRejectionThreshold</td>\n<td style=\"text-align:center\">队列大小拒绝阈值</td>\n<td style=\"text-align:center\">5</td>\n<td style=\"text-align:center\">支持，即使maxQueueSize没有达到，也会出现拒绝，因为允许动态更改拒绝队列的大小</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">keepAliveTimeMinutes</td>\n<td style=\"text-align:center\">线程释放的空闲时间</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">支持</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">allowMaximumSizeToDivergeFromCoreSize</td>\n<td style=\"text-align:center\">maximumSize大于coreSize时，线程空闲时是否释放资源</td>\n<td style=\"text-align:center\">false</td>\n<td style=\"text-align:center\">支持</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"SpringMVC\"><a href=\"#SpringMVC\" class=\"headerlink\" title=\"SpringMVC\"></a>SpringMVC</h3><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">aop:aspectj-autoproxy</span>/&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"hystrixAspect\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com.netflix.hystrix.contrib.javanica.aop.aspectj.HystrixCommandAspect\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"SpringBoot\"><a href=\"#SpringBoot\" class=\"headerlink\" title=\"SpringBoot\"></a>SpringBoot</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HystrixConfiguration</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Bean</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> HystrixCommandAspect <span class=\"title\">hystrixAspect</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> HystrixCommandAspect();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Sync-Execution\"><a href=\"#Sync-Execution\" class=\"headerlink\" title=\"Sync Execution\"></a>Sync Execution</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@HystrixCommand</span>(groupKey=<span class=\"string\">\"UserGroup\"</span>, commandKey = <span class=\"string\">\"GetUserByIdCommand\"</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> User <span class=\"title\">getUserById</span><span class=\"params\">(String id)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> userResource.getUserById(id);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Async-Execution\"><a href=\"#Async-Execution\" class=\"headerlink\" title=\"Async Execution\"></a>Async Execution</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@HystrixCommand</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Future&lt;User&gt; <span class=\"title\">getUserByIdAsync</span><span class=\"params\">(<span class=\"keyword\">final</span> String id)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> AsyncResult&lt;User&gt;() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> User <span class=\"title\">invoke</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> userResource.getUserById(id);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Reactive-Exection\"><a href=\"#Reactive-Exection\" class=\"headerlink\" title=\"Reactive Exection\"></a>Reactive Exection</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@HystrixCommand</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Observable&lt;User&gt; <span class=\"title\">getUserById</span><span class=\"params\">(<span class=\"keyword\">final</span> String id)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Observable.create(<span class=\"keyword\">new</span> Observable.OnSubscribe&lt;User&gt;() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">call</span><span class=\"params\">(Subscriber&lt;? <span class=\"keyword\">super</span> User&gt; observer)</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (!observer.isUnsubscribed()) &#123;</span><br><span class=\"line\">                        observer.onNext(<span class=\"keyword\">new</span> User(id, name + id));</span><br><span class=\"line\">                        observer.onCompleted();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                    observer.onError(e);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Fallback-1\"><a href=\"#Fallback-1\" class=\"headerlink\" title=\"Fallback\"></a>Fallback</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@HystrixCommand</span>(fallbackMethod = <span class=\"string\">\"defaultUser\"</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> User <span class=\"title\">getUserById</span><span class=\"params\">(String id)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> userResource.getUserById(id);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> User <span class=\"title\">defaultUser</span><span class=\"params\">(String id)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> User(<span class=\"string\">\"def\"</span>, <span class=\"string\">\"def\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>Hystrix命令和fallback应该在同一个类中，并且具有相同的方法签名(失败执行异常的可选参数)。</li>\n<li>如果需要异常，在末尾添加Throwable，对访问修饰符无要求。</li>\n<li>fallback方法可以继续添加fallback。</li>\n</ul>\n<h3 id=\"Fallback-Exception\"><a href=\"#Fallback-Exception\" class=\"headerlink\" title=\"Fallback Exception\"></a>Fallback Exception</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@HystrixCommand</span>(fallbackMethod = <span class=\"string\">\"fallback1\"</span>)</span><br><span class=\"line\"><span class=\"function\">User <span class=\"title\">getUserById</span><span class=\"params\">(String id)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"getUserById command failed\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@HystrixCommand</span>(fallbackMethod = <span class=\"string\">\"fallback2\"</span>)</span><br><span class=\"line\"><span class=\"function\">User <span class=\"title\">fallback1</span><span class=\"params\">(String id, Throwable e)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">assert</span> <span class=\"string\">\"getUserById command failed\"</span>.equals(e.getMessage());</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"fallback1 failed\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@HystrixCommand</span>(fallbackMethod = <span class=\"string\">\"fallback3\"</span>)</span><br><span class=\"line\"><span class=\"function\">User <span class=\"title\">fallback2</span><span class=\"params\">(String id)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"fallback2 failed\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@HystrixCommand</span>(fallbackMethod = <span class=\"string\">\"staticFallback\"</span>)</span><br><span class=\"line\"><span class=\"function\">User <span class=\"title\">fallback3</span><span class=\"params\">(String id, Throwable e)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">assert</span> <span class=\"string\">\"fallback2 failed\"</span>.equals(e.getMessage());</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"fallback3 failed\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">User <span class=\"title\">staticFallback</span><span class=\"params\">(String id, Throwable e)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">assert</span> <span class=\"string\">\"fallback3 failed\"</span>.equals(e.getMessage());</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> User(<span class=\"string\">\"def\"</span>, <span class=\"string\">\"def\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">// test</span></span><br><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tassertEquals(<span class=\"string\">\"def\"</span>, getUserById(<span class=\"string\">\"1\"</span>).getName());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Async-Sync-fallback\"><a href=\"#Async-Sync-fallback\" class=\"headerlink\" title=\"Async/Sync fallback\"></a>Async/Sync fallback</h3><ul>\n<li>sync command, sync fallback</li>\n<li>async command, sync fallback</li>\n<li>async command, async fallback</li>\n</ul>\n<h3 id=\"Default-fallback\"><a href=\"#Default-fallback\" class=\"headerlink\" title=\"Default fallback\"></a>Default fallback</h3><p>该特性允许为整个类或具体的命令定义默认的回退。如果你有一组具有完全相同的回滚逻辑的命令，那么仍然需要为每个命令定义一个fallback，因为fallback应该具有与命令相同的签名，如下所示:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Service</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping</span>(value = <span class=\"string\">\"/test1\"</span>)</span><br><span class=\"line\">    <span class=\"meta\">@HystrixCommand</span>(fallbackMethod = <span class=\"string\">\"fallback\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> APIResponse <span class=\"title\">test1</span><span class=\"params\">(String param1)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// some codes here</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> APIResponse.success(<span class=\"string\">\"success\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping</span>(value = <span class=\"string\">\"/test2\"</span>)</span><br><span class=\"line\">    <span class=\"meta\">@HystrixCommand</span>(fallbackMethod = <span class=\"string\">\"fallback\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> APIResponse <span class=\"title\">test2</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// some codes here</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> APIResponse.success(<span class=\"string\">\"success\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping</span>(value = <span class=\"string\">\"/test3\"</span>)</span><br><span class=\"line\">    <span class=\"meta\">@HystrixCommand</span>(fallbackMethod = <span class=\"string\">\"fallback\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> APIResponse <span class=\"title\">test3</span><span class=\"params\">(ObjectRequest obj)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// some codes here</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> APIResponse.success(<span class=\"string\">\"success\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> APIResponse <span class=\"title\">fallback</span><span class=\"params\">(String param1)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> APIResponse.failed(<span class=\"string\">\"Server is busy\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> APIResponse <span class=\"title\">fallback</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> APIResponse.failed(<span class=\"string\">\"Server is busy\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> APIResponse <span class=\"title\">fallback</span><span class=\"params\">(ObjectRequest obj)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> APIResponse.failed(<span class=\"string\">\"Server is busy\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>默认的fallback特性减少冗余方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@DefaultProperties</span>(defaultFallback = <span class=\"string\">\"fallback\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Service</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping</span>(value = <span class=\"string\">\"/test1\"</span>)</span><br><span class=\"line\">    <span class=\"meta\">@HystrixCommand</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> APIResponse <span class=\"title\">test1</span><span class=\"params\">(String param1)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// some codes here</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> APIResponse.success(<span class=\"string\">\"success\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping</span>(value = <span class=\"string\">\"/test2\"</span>)</span><br><span class=\"line\">    <span class=\"meta\">@HystrixCommand</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> APIResponse <span class=\"title\">test2</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// some codes here</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> APIResponse.success(<span class=\"string\">\"success\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping</span>(value = <span class=\"string\">\"/test3\"</span>)</span><br><span class=\"line\">    <span class=\"meta\">@HystrixCommand</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> APIResponse <span class=\"title\">test3</span><span class=\"params\">(ObjectRequest obj)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// some codes here</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> APIResponse.success(<span class=\"string\">\"success\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> APIResponse <span class=\"title\">fallback</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> APIResponse.failed(<span class=\"string\">\"Server is busy\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>默认的fallback不含任何参数，除了异常参数以获得执行异常，并且不应该抛出任何异常。以下是按下行优先级的顺序排列:</p>\n<ol>\n<li>@HystrixCommand 定义的 fallbackMethod。</li>\n<li>@HystrixCommand 定义的 defaultFallback。</li>\n<li>在 class 上 使用 @DefaultProperties 定义的 defaultFallback。</li>\n</ol>\n<h3 id=\"错误传播\"><a href=\"#错误传播\" class=\"headerlink\" title=\"错误传播\"></a>错误传播</h3><p>@HystrixCommand 提供忽略指定异常不触发fallback的功能。</p>\n<pre><code class=\"Java\"><span class=\"meta\">@HystrixCommand</span>(ignoreExceptions = {BadRequestException.class})\n<span class=\"function\"><span class=\"keyword\">public</span> User <span class=\"title\">getUserById</span><span class=\"params\">(String id)</span> </span>{\n    <span class=\"keyword\">return</span> userResource.getUserById(id);\n}\n</code></pre>\n<p>如果 userResource.getUserById(id) 抛出一个 BadRequestException，然后这个异常会裹着 HystrixBadRequestException 再抛出来，不会触发fallback。</p>\n"},{"title":"Java内存区域与内存溢出异常","date":"2016-05-06T16:00:00.000Z","_content":"\n##\t运行时数据区域\n*\t方法区（所有线程共享）\t\n* \t堆（所有线程共享）  \n*  虚拟机栈（线程隔离）  \n*  本地方法栈（线程隔离）  \n*  程序计数器（线程隔离）  \n\n##\t程序计数器  \n程序计数器可以看作是当前线程所执行字节码的行号指示器。虚拟机概念模型中，字节码解释器工作时就是通过改变中国计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖计数器。\n\n##\tJava虚拟机栈\n和程序计数器一样，线程私有。生命周期与线程相同。  \n虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧(Stack Frame)，用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈道出栈的过程。\n\n局部变量表存放了编译器可知的各种基本数据类型（boolean, byte, char, short, int, float, long, double）、对象引用。\n\n局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量是完全确定的，在方法运行期间不会改变局部变量表的大小。\n\nJava虚拟机规范中，对这个区域规定了2中异常情况：   \n1.\t线程请求栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；  \n2. 虚拟机栈可以动态扩展，当扩展式无法申请到足够内容，就会抛出OutOfMemoryError（OOM）异常。\n\n##\t本地方法栈\n与虚拟机栈作用相似。虚拟机栈执行Java方法，本地方法栈执行虚拟机用到的Native方法。不过，虚拟机规范中对本地方法栈中方法使用的语言、使用方式与数据结构并没有强制规定，因此虚拟机可自由实现。\n\n## Java堆\nJava堆（Java Heap）是Java虚拟机所管理的内存中最大的一块，Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区唯一目的就是存放对象实例，几乎所有对象实例都在这分配内存。  \n\n##\t方法区\n方法区与Java堆一样，是各个线程共享的内存区域。它存储已被虚拟机加载的类信息、常量、静态变量，即使编译器编译后的代码等数据。当方法区无法满足内存分配需求时，抛出OOM异常。\n\n##\t运行时常量池\n运行时常量池是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项是常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常亮池中存放。\n\n##\t直接内存\n直接内存并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域。但是这部分内存也被频繁地使用，也可能导致OOM出现。  \n在JDK1.4，新加了NIO（New Input/Output）类，引入了一种基于通道与缓冲区的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场合显著提高性能，因为避免了在Java堆中和Native堆中来回复制数据。  \n配置JVM参数时，会根据实际内存设置-Xmx等参数信息，但经常忽略直接内存。\n\n##\t对象的创建\n当虚拟机遇到一条new指令时，首先会检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过，如果没有，必须先执行相应的类加载过程。  \n1.\t类加载检查通过。  \n2. 为新生对象分配内存，对象所需内存大小在加载完毕后可完全确定。  \n*\tJava堆内存绝对规整时，采用“指针碰撞”分配：所有用过的内存在一边，没用过的在另一边，中间放着一个指针作为分界点的指示器。  \n*\tJava堆中内存不规整时，采用\"空闲列表\"分配：已使用的内存和未使用的会相互交错，虚拟机必须维护一个列表记录哪些内存快可用，在分配的时候从列表找到一块足够大的空间划分给对象实例，并更新列表记录。  \n3.\t内存分配完成后，虚拟机将分配到的内存空间都初始化为零值（不包括对象头）。这一步保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。  \n4. 虚拟机对对对象进行必要设置，例如对象是哪个类的实例，如何能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。这些信息存放在对象的对象头（Object Header）中。根据虚拟机当前运行状态不同，如是否启用偏向锁等，对象头会有不同的设置方式。  \n5. 上面工作完成之后，从虚拟机角度来看，一个新的对象已经产生，但从Java程序的角度来看，对象创建才刚刚开始----init方法还没有执行，所有的字段都还为零。一般来说，执行new指指令之后会接着执行init方法，把对象按照程序员的医院进行初始化，这样一个真正可用的对象才算完全产生出来。\n\n##\t对象内存布局\n在HotSpot虚拟机中，对象在内存中存储的布局可分为3块区域：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。  \n对象头包括2部分信息，第一部分用于存储对象自身的运行时数据，如哈希码、GC分代年龄、锁状态标识、线程持有的锁、偏向线程ID、偏向时间戳等。另一部分信息是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个来的实例。如果对象是一个Java数组，那在对象头中还必须有一块用于记录数组长度的数据，因为虚拟机可以通过普通Java对象的元数据信息确定Java对象大小，但是从数组的元数据却无法确定数组的大小。  \n\n##\t对象访问定位\nJava需要通过栈上的reference数据来操作堆上的具体对象，由于reference类型在Java虚拟机规范中只规定了一个指向对象的引用，并没有定义这个引用应该通过何种方式去定位、访问堆中对象的具体位置，所有对象访问方式也是取决于虚拟机实现而定。目前主流访问方式有使用句柄和直接指针两种。  \n*\t句柄访问，Java堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。  \n* 指针访问，Java堆对象布局就必须考虑如何放置访问类型数据的相关信息，而reference中存储的直接就是对象地址。  \n句柄访问最大好处是reference中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而reference本身不需要修改。  \n指针访问最大好处是速度更快，节省了一次指针定位的时间开销。\n\n##\tJVM参数\n*\t-Xms和-Xmx\t堆最小、最大值，大小值相同可避免自动扩展。\n*\t-XX:+HeapDumpOnOutOfMemoryError可以让虚拟机在出现内存溢出错误时Dump出当前的内存堆转存储快照以便事后进行分析。\n*\t-Xss\t栈大小\n* \t-XX:PermSize和-XX:MaxPermSize 方法区最小、最大值。\n*\t-XX: MaxDirectMemorySize，如不指定默认与-Xmx一样。\n\n## 方法区溢出\n```\tjava\n/**\n * VM args: -XX:PermSize=10M -XX:MaxPermSize=10M\n */\npublic static void main(String[] args){\n\tList<String> list = new ArrayList<String>();\n\tint i = 0;\n\twhile(true){\n\t\tlist.add(String.valueOf(i++).intern());\n\t}\n} \n```\n上述代码在JDK1.7之前方法区内存不足时提示信息为\"PermGen space\"，说明运行时常量池属于方法区（HotSpot JVM中永久代）。而在JDK1.7运行时while将一直进行下去，不受PermSize限制，因为1.7开始逐步“去永久代”。\n\n##\tString.intern()\n```\tjava\npublic static void main(String[] args){\n\tString str1 = new StringBuilder(\"abc\").append(\"xyz\").toString();\n\tSystem.out.println(str1.intern() == str1);\n\tString str2 = new StringBuilder(\"ja\").append(\"va\").toString();\n\tSystem.out.println(str2.intern() == str2);\n}\n```\n上述代码在JDK1.6中执行，会得到2个false。而在JDK1.7中执行，会得到一个true和一个false。  \n在JDK1.6中，intern()方法会把首次遇到的字符串实例复制到永久代中。返回的也是永久代中这个字符串实例的引用，而有StringBuilder创建的字符串实例在Java堆上，所以必然不是同一个引用，将返回false。\n在JDK1.7中，intern()的实现将不会再复制实例，只是在常量池中记录首次出现的实例引用，因此intern()返回的引用和由StringBuilder创建的那个字符串实例是同一个。对str2返回false是因为\"java\"这个字符串在执行StringBuilder.toString()之前已经出现过，字符串常量池中已经有它的引用了，不符合\"首次出现\"的原则。","source":"_posts/深入理解Java虚拟机/运行时数据区域.md","raw":"---\ntitle: Java内存区域与内存溢出异常\ndate: 2016-05-07\ncategories: 深入理解Java虚拟机\ntags: JVM\n---\n\n##\t运行时数据区域\n*\t方法区（所有线程共享）\t\n* \t堆（所有线程共享）  \n*  虚拟机栈（线程隔离）  \n*  本地方法栈（线程隔离）  \n*  程序计数器（线程隔离）  \n\n##\t程序计数器  \n程序计数器可以看作是当前线程所执行字节码的行号指示器。虚拟机概念模型中，字节码解释器工作时就是通过改变中国计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖计数器。\n\n##\tJava虚拟机栈\n和程序计数器一样，线程私有。生命周期与线程相同。  \n虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧(Stack Frame)，用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈道出栈的过程。\n\n局部变量表存放了编译器可知的各种基本数据类型（boolean, byte, char, short, int, float, long, double）、对象引用。\n\n局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量是完全确定的，在方法运行期间不会改变局部变量表的大小。\n\nJava虚拟机规范中，对这个区域规定了2中异常情况：   \n1.\t线程请求栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；  \n2. 虚拟机栈可以动态扩展，当扩展式无法申请到足够内容，就会抛出OutOfMemoryError（OOM）异常。\n\n##\t本地方法栈\n与虚拟机栈作用相似。虚拟机栈执行Java方法，本地方法栈执行虚拟机用到的Native方法。不过，虚拟机规范中对本地方法栈中方法使用的语言、使用方式与数据结构并没有强制规定，因此虚拟机可自由实现。\n\n## Java堆\nJava堆（Java Heap）是Java虚拟机所管理的内存中最大的一块，Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区唯一目的就是存放对象实例，几乎所有对象实例都在这分配内存。  \n\n##\t方法区\n方法区与Java堆一样，是各个线程共享的内存区域。它存储已被虚拟机加载的类信息、常量、静态变量，即使编译器编译后的代码等数据。当方法区无法满足内存分配需求时，抛出OOM异常。\n\n##\t运行时常量池\n运行时常量池是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项是常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常亮池中存放。\n\n##\t直接内存\n直接内存并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域。但是这部分内存也被频繁地使用，也可能导致OOM出现。  \n在JDK1.4，新加了NIO（New Input/Output）类，引入了一种基于通道与缓冲区的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场合显著提高性能，因为避免了在Java堆中和Native堆中来回复制数据。  \n配置JVM参数时，会根据实际内存设置-Xmx等参数信息，但经常忽略直接内存。\n\n##\t对象的创建\n当虚拟机遇到一条new指令时，首先会检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过，如果没有，必须先执行相应的类加载过程。  \n1.\t类加载检查通过。  \n2. 为新生对象分配内存，对象所需内存大小在加载完毕后可完全确定。  \n*\tJava堆内存绝对规整时，采用“指针碰撞”分配：所有用过的内存在一边，没用过的在另一边，中间放着一个指针作为分界点的指示器。  \n*\tJava堆中内存不规整时，采用\"空闲列表\"分配：已使用的内存和未使用的会相互交错，虚拟机必须维护一个列表记录哪些内存快可用，在分配的时候从列表找到一块足够大的空间划分给对象实例，并更新列表记录。  \n3.\t内存分配完成后，虚拟机将分配到的内存空间都初始化为零值（不包括对象头）。这一步保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。  \n4. 虚拟机对对对象进行必要设置，例如对象是哪个类的实例，如何能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。这些信息存放在对象的对象头（Object Header）中。根据虚拟机当前运行状态不同，如是否启用偏向锁等，对象头会有不同的设置方式。  \n5. 上面工作完成之后，从虚拟机角度来看，一个新的对象已经产生，但从Java程序的角度来看，对象创建才刚刚开始----init方法还没有执行，所有的字段都还为零。一般来说，执行new指指令之后会接着执行init方法，把对象按照程序员的医院进行初始化，这样一个真正可用的对象才算完全产生出来。\n\n##\t对象内存布局\n在HotSpot虚拟机中，对象在内存中存储的布局可分为3块区域：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。  \n对象头包括2部分信息，第一部分用于存储对象自身的运行时数据，如哈希码、GC分代年龄、锁状态标识、线程持有的锁、偏向线程ID、偏向时间戳等。另一部分信息是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个来的实例。如果对象是一个Java数组，那在对象头中还必须有一块用于记录数组长度的数据，因为虚拟机可以通过普通Java对象的元数据信息确定Java对象大小，但是从数组的元数据却无法确定数组的大小。  \n\n##\t对象访问定位\nJava需要通过栈上的reference数据来操作堆上的具体对象，由于reference类型在Java虚拟机规范中只规定了一个指向对象的引用，并没有定义这个引用应该通过何种方式去定位、访问堆中对象的具体位置，所有对象访问方式也是取决于虚拟机实现而定。目前主流访问方式有使用句柄和直接指针两种。  \n*\t句柄访问，Java堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。  \n* 指针访问，Java堆对象布局就必须考虑如何放置访问类型数据的相关信息，而reference中存储的直接就是对象地址。  \n句柄访问最大好处是reference中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而reference本身不需要修改。  \n指针访问最大好处是速度更快，节省了一次指针定位的时间开销。\n\n##\tJVM参数\n*\t-Xms和-Xmx\t堆最小、最大值，大小值相同可避免自动扩展。\n*\t-XX:+HeapDumpOnOutOfMemoryError可以让虚拟机在出现内存溢出错误时Dump出当前的内存堆转存储快照以便事后进行分析。\n*\t-Xss\t栈大小\n* \t-XX:PermSize和-XX:MaxPermSize 方法区最小、最大值。\n*\t-XX: MaxDirectMemorySize，如不指定默认与-Xmx一样。\n\n## 方法区溢出\n```\tjava\n/**\n * VM args: -XX:PermSize=10M -XX:MaxPermSize=10M\n */\npublic static void main(String[] args){\n\tList<String> list = new ArrayList<String>();\n\tint i = 0;\n\twhile(true){\n\t\tlist.add(String.valueOf(i++).intern());\n\t}\n} \n```\n上述代码在JDK1.7之前方法区内存不足时提示信息为\"PermGen space\"，说明运行时常量池属于方法区（HotSpot JVM中永久代）。而在JDK1.7运行时while将一直进行下去，不受PermSize限制，因为1.7开始逐步“去永久代”。\n\n##\tString.intern()\n```\tjava\npublic static void main(String[] args){\n\tString str1 = new StringBuilder(\"abc\").append(\"xyz\").toString();\n\tSystem.out.println(str1.intern() == str1);\n\tString str2 = new StringBuilder(\"ja\").append(\"va\").toString();\n\tSystem.out.println(str2.intern() == str2);\n}\n```\n上述代码在JDK1.6中执行，会得到2个false。而在JDK1.7中执行，会得到一个true和一个false。  \n在JDK1.6中，intern()方法会把首次遇到的字符串实例复制到永久代中。返回的也是永久代中这个字符串实例的引用，而有StringBuilder创建的字符串实例在Java堆上，所以必然不是同一个引用，将返回false。\n在JDK1.7中，intern()的实现将不会再复制实例，只是在常量池中记录首次出现的实例引用，因此intern()返回的引用和由StringBuilder创建的那个字符串实例是同一个。对str2返回false是因为\"java\"这个字符串在执行StringBuilder.toString()之前已经出现过，字符串常量池中已经有它的引用了，不符合\"首次出现\"的原则。","slug":"深入理解Java虚拟机/运行时数据区域","published":1,"updated":"2019-05-17T05:57:58.583Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1j8f2is001s7h9mqrcd1xvi","content":"<h2 id=\"运行时数据区域\"><a href=\"#运行时数据区域\" class=\"headerlink\" title=\"运行时数据区域\"></a>运行时数据区域</h2><ul>\n<li>方法区（所有线程共享）    </li>\n<li>堆（所有线程共享）  </li>\n<li>虚拟机栈（线程隔离）  </li>\n<li>本地方法栈（线程隔离）  </li>\n<li>程序计数器（线程隔离）  </li>\n</ul>\n<h2 id=\"程序计数器\"><a href=\"#程序计数器\" class=\"headerlink\" title=\"程序计数器\"></a>程序计数器</h2><p>程序计数器可以看作是当前线程所执行字节码的行号指示器。虚拟机概念模型中，字节码解释器工作时就是通过改变中国计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖计数器。</p>\n<h2 id=\"Java虚拟机栈\"><a href=\"#Java虚拟机栈\" class=\"headerlink\" title=\"Java虚拟机栈\"></a>Java虚拟机栈</h2><p>和程序计数器一样，线程私有。生命周期与线程相同。<br>虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧(Stack Frame)，用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈道出栈的过程。</p>\n<p>局部变量表存放了编译器可知的各种基本数据类型（boolean, byte, char, short, int, float, long, double）、对象引用。</p>\n<p>局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量是完全确定的，在方法运行期间不会改变局部变量表的大小。</p>\n<p>Java虚拟机规范中，对这个区域规定了2中异常情况：   </p>\n<ol>\n<li>线程请求栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；  </li>\n<li>虚拟机栈可以动态扩展，当扩展式无法申请到足够内容，就会抛出OutOfMemoryError（OOM）异常。</li>\n</ol>\n<h2 id=\"本地方法栈\"><a href=\"#本地方法栈\" class=\"headerlink\" title=\"本地方法栈\"></a>本地方法栈</h2><p>与虚拟机栈作用相似。虚拟机栈执行Java方法，本地方法栈执行虚拟机用到的Native方法。不过，虚拟机规范中对本地方法栈中方法使用的语言、使用方式与数据结构并没有强制规定，因此虚拟机可自由实现。</p>\n<h2 id=\"Java堆\"><a href=\"#Java堆\" class=\"headerlink\" title=\"Java堆\"></a>Java堆</h2><p>Java堆（Java Heap）是Java虚拟机所管理的内存中最大的一块，Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区唯一目的就是存放对象实例，几乎所有对象实例都在这分配内存。  </p>\n<h2 id=\"方法区\"><a href=\"#方法区\" class=\"headerlink\" title=\"方法区\"></a>方法区</h2><p>方法区与Java堆一样，是各个线程共享的内存区域。它存储已被虚拟机加载的类信息、常量、静态变量，即使编译器编译后的代码等数据。当方法区无法满足内存分配需求时，抛出OOM异常。</p>\n<h2 id=\"运行时常量池\"><a href=\"#运行时常量池\" class=\"headerlink\" title=\"运行时常量池\"></a>运行时常量池</h2><p>运行时常量池是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项是常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常亮池中存放。</p>\n<h2 id=\"直接内存\"><a href=\"#直接内存\" class=\"headerlink\" title=\"直接内存\"></a>直接内存</h2><p>直接内存并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域。但是这部分内存也被频繁地使用，也可能导致OOM出现。<br>在JDK1.4，新加了NIO（New Input/Output）类，引入了一种基于通道与缓冲区的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场合显著提高性能，因为避免了在Java堆中和Native堆中来回复制数据。<br>配置JVM参数时，会根据实际内存设置-Xmx等参数信息，但经常忽略直接内存。</p>\n<h2 id=\"对象的创建\"><a href=\"#对象的创建\" class=\"headerlink\" title=\"对象的创建\"></a>对象的创建</h2><p>当虚拟机遇到一条new指令时，首先会检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过，如果没有，必须先执行相应的类加载过程。  </p>\n<ol>\n<li>类加载检查通过。  </li>\n<li>为新生对象分配内存，对象所需内存大小在加载完毕后可完全确定。  </li>\n</ol>\n<ul>\n<li>Java堆内存绝对规整时，采用“指针碰撞”分配：所有用过的内存在一边，没用过的在另一边，中间放着一个指针作为分界点的指示器。  </li>\n<li>Java堆中内存不规整时，采用”空闲列表”分配：已使用的内存和未使用的会相互交错，虚拟机必须维护一个列表记录哪些内存快可用，在分配的时候从列表找到一块足够大的空间划分给对象实例，并更新列表记录。  </li>\n</ul>\n<ol>\n<li>内存分配完成后，虚拟机将分配到的内存空间都初始化为零值（不包括对象头）。这一步保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。  </li>\n<li>虚拟机对对对象进行必要设置，例如对象是哪个类的实例，如何能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。这些信息存放在对象的对象头（Object Header）中。根据虚拟机当前运行状态不同，如是否启用偏向锁等，对象头会有不同的设置方式。  </li>\n<li>上面工作完成之后，从虚拟机角度来看，一个新的对象已经产生，但从Java程序的角度来看，对象创建才刚刚开始—-init方法还没有执行，所有的字段都还为零。一般来说，执行new指指令之后会接着执行init方法，把对象按照程序员的医院进行初始化，这样一个真正可用的对象才算完全产生出来。</li>\n</ol>\n<h2 id=\"对象内存布局\"><a href=\"#对象内存布局\" class=\"headerlink\" title=\"对象内存布局\"></a>对象内存布局</h2><p>在HotSpot虚拟机中，对象在内存中存储的布局可分为3块区域：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。<br>对象头包括2部分信息，第一部分用于存储对象自身的运行时数据，如哈希码、GC分代年龄、锁状态标识、线程持有的锁、偏向线程ID、偏向时间戳等。另一部分信息是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个来的实例。如果对象是一个Java数组，那在对象头中还必须有一块用于记录数组长度的数据，因为虚拟机可以通过普通Java对象的元数据信息确定Java对象大小，但是从数组的元数据却无法确定数组的大小。  </p>\n<h2 id=\"对象访问定位\"><a href=\"#对象访问定位\" class=\"headerlink\" title=\"对象访问定位\"></a>对象访问定位</h2><p>Java需要通过栈上的reference数据来操作堆上的具体对象，由于reference类型在Java虚拟机规范中只规定了一个指向对象的引用，并没有定义这个引用应该通过何种方式去定位、访问堆中对象的具体位置，所有对象访问方式也是取决于虚拟机实现而定。目前主流访问方式有使用句柄和直接指针两种。  </p>\n<ul>\n<li>句柄访问，Java堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。  </li>\n<li>指针访问，Java堆对象布局就必须考虑如何放置访问类型数据的相关信息，而reference中存储的直接就是对象地址。<br>句柄访问最大好处是reference中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而reference本身不需要修改。<br>指针访问最大好处是速度更快，节省了一次指针定位的时间开销。</li>\n</ul>\n<h2 id=\"JVM参数\"><a href=\"#JVM参数\" class=\"headerlink\" title=\"JVM参数\"></a>JVM参数</h2><ul>\n<li>-Xms和-Xmx    堆最小、最大值，大小值相同可避免自动扩展。</li>\n<li>-XX:+HeapDumpOnOutOfMemoryError可以让虚拟机在出现内存溢出错误时Dump出当前的内存堆转存储快照以便事后进行分析。</li>\n<li>-Xss    栈大小</li>\n<li>-XX:PermSize和-XX:MaxPermSize 方法区最小、最大值。</li>\n<li>-XX: MaxDirectMemorySize，如不指定默认与-Xmx一样。</li>\n</ul>\n<h2 id=\"方法区溢出\"><a href=\"#方法区溢出\" class=\"headerlink\" title=\"方法区溢出\"></a>方法区溢出</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * VM args: -XX:PermSize=10M -XX:MaxPermSize=10M</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">\tList&lt;String&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;String&gt;();</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(<span class=\"keyword\">true</span>)&#123;</span><br><span class=\"line\">\t\tlist.add(String.valueOf(i++).intern());</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上述代码在JDK1.7之前方法区内存不足时提示信息为”PermGen space”，说明运行时常量池属于方法区（HotSpot JVM中永久代）。而在JDK1.7运行时while将一直进行下去，不受PermSize限制，因为1.7开始逐步“去永久代”。</p>\n<h2 id=\"String-intern\"><a href=\"#String-intern\" class=\"headerlink\" title=\"String.intern()\"></a>String.intern()</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">\tString str1 = <span class=\"keyword\">new</span> StringBuilder(<span class=\"string\">\"abc\"</span>).append(<span class=\"string\">\"xyz\"</span>).toString();</span><br><span class=\"line\">\tSystem.out.println(str1.intern() == str1);</span><br><span class=\"line\">\tString str2 = <span class=\"keyword\">new</span> StringBuilder(<span class=\"string\">\"ja\"</span>).append(<span class=\"string\">\"va\"</span>).toString();</span><br><span class=\"line\">\tSystem.out.println(str2.intern() == str2);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上述代码在JDK1.6中执行，会得到2个false。而在JDK1.7中执行，会得到一个true和一个false。<br>在JDK1.6中，intern()方法会把首次遇到的字符串实例复制到永久代中。返回的也是永久代中这个字符串实例的引用，而有StringBuilder创建的字符串实例在Java堆上，所以必然不是同一个引用，将返回false。<br>在JDK1.7中，intern()的实现将不会再复制实例，只是在常量池中记录首次出现的实例引用，因此intern()返回的引用和由StringBuilder创建的那个字符串实例是同一个。对str2返回false是因为”java”这个字符串在执行StringBuilder.toString()之前已经出现过，字符串常量池中已经有它的引用了，不符合”首次出现”的原则。</p>\n","excerpt":"","more":"<h2 id=\"运行时数据区域\"><a href=\"#运行时数据区域\" class=\"headerlink\" title=\"运行时数据区域\"></a>运行时数据区域</h2><ul>\n<li>方法区（所有线程共享）    </li>\n<li>堆（所有线程共享）  </li>\n<li>虚拟机栈（线程隔离）  </li>\n<li>本地方法栈（线程隔离）  </li>\n<li>程序计数器（线程隔离）  </li>\n</ul>\n<h2 id=\"程序计数器\"><a href=\"#程序计数器\" class=\"headerlink\" title=\"程序计数器\"></a>程序计数器</h2><p>程序计数器可以看作是当前线程所执行字节码的行号指示器。虚拟机概念模型中，字节码解释器工作时就是通过改变中国计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖计数器。</p>\n<h2 id=\"Java虚拟机栈\"><a href=\"#Java虚拟机栈\" class=\"headerlink\" title=\"Java虚拟机栈\"></a>Java虚拟机栈</h2><p>和程序计数器一样，线程私有。生命周期与线程相同。<br>虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧(Stack Frame)，用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈道出栈的过程。</p>\n<p>局部变量表存放了编译器可知的各种基本数据类型（boolean, byte, char, short, int, float, long, double）、对象引用。</p>\n<p>局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量是完全确定的，在方法运行期间不会改变局部变量表的大小。</p>\n<p>Java虚拟机规范中，对这个区域规定了2中异常情况：   </p>\n<ol>\n<li>线程请求栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；  </li>\n<li>虚拟机栈可以动态扩展，当扩展式无法申请到足够内容，就会抛出OutOfMemoryError（OOM）异常。</li>\n</ol>\n<h2 id=\"本地方法栈\"><a href=\"#本地方法栈\" class=\"headerlink\" title=\"本地方法栈\"></a>本地方法栈</h2><p>与虚拟机栈作用相似。虚拟机栈执行Java方法，本地方法栈执行虚拟机用到的Native方法。不过，虚拟机规范中对本地方法栈中方法使用的语言、使用方式与数据结构并没有强制规定，因此虚拟机可自由实现。</p>\n<h2 id=\"Java堆\"><a href=\"#Java堆\" class=\"headerlink\" title=\"Java堆\"></a>Java堆</h2><p>Java堆（Java Heap）是Java虚拟机所管理的内存中最大的一块，Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区唯一目的就是存放对象实例，几乎所有对象实例都在这分配内存。  </p>\n<h2 id=\"方法区\"><a href=\"#方法区\" class=\"headerlink\" title=\"方法区\"></a>方法区</h2><p>方法区与Java堆一样，是各个线程共享的内存区域。它存储已被虚拟机加载的类信息、常量、静态变量，即使编译器编译后的代码等数据。当方法区无法满足内存分配需求时，抛出OOM异常。</p>\n<h2 id=\"运行时常量池\"><a href=\"#运行时常量池\" class=\"headerlink\" title=\"运行时常量池\"></a>运行时常量池</h2><p>运行时常量池是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项是常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常亮池中存放。</p>\n<h2 id=\"直接内存\"><a href=\"#直接内存\" class=\"headerlink\" title=\"直接内存\"></a>直接内存</h2><p>直接内存并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域。但是这部分内存也被频繁地使用，也可能导致OOM出现。<br>在JDK1.4，新加了NIO（New Input/Output）类，引入了一种基于通道与缓冲区的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场合显著提高性能，因为避免了在Java堆中和Native堆中来回复制数据。<br>配置JVM参数时，会根据实际内存设置-Xmx等参数信息，但经常忽略直接内存。</p>\n<h2 id=\"对象的创建\"><a href=\"#对象的创建\" class=\"headerlink\" title=\"对象的创建\"></a>对象的创建</h2><p>当虚拟机遇到一条new指令时，首先会检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过，如果没有，必须先执行相应的类加载过程。  </p>\n<ol>\n<li>类加载检查通过。  </li>\n<li>为新生对象分配内存，对象所需内存大小在加载完毕后可完全确定。  </li>\n</ol>\n<ul>\n<li>Java堆内存绝对规整时，采用“指针碰撞”分配：所有用过的内存在一边，没用过的在另一边，中间放着一个指针作为分界点的指示器。  </li>\n<li>Java堆中内存不规整时，采用”空闲列表”分配：已使用的内存和未使用的会相互交错，虚拟机必须维护一个列表记录哪些内存快可用，在分配的时候从列表找到一块足够大的空间划分给对象实例，并更新列表记录。  </li>\n</ul>\n<ol>\n<li>内存分配完成后，虚拟机将分配到的内存空间都初始化为零值（不包括对象头）。这一步保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。  </li>\n<li>虚拟机对对对象进行必要设置，例如对象是哪个类的实例，如何能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。这些信息存放在对象的对象头（Object Header）中。根据虚拟机当前运行状态不同，如是否启用偏向锁等，对象头会有不同的设置方式。  </li>\n<li>上面工作完成之后，从虚拟机角度来看，一个新的对象已经产生，但从Java程序的角度来看，对象创建才刚刚开始—-init方法还没有执行，所有的字段都还为零。一般来说，执行new指指令之后会接着执行init方法，把对象按照程序员的医院进行初始化，这样一个真正可用的对象才算完全产生出来。</li>\n</ol>\n<h2 id=\"对象内存布局\"><a href=\"#对象内存布局\" class=\"headerlink\" title=\"对象内存布局\"></a>对象内存布局</h2><p>在HotSpot虚拟机中，对象在内存中存储的布局可分为3块区域：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。<br>对象头包括2部分信息，第一部分用于存储对象自身的运行时数据，如哈希码、GC分代年龄、锁状态标识、线程持有的锁、偏向线程ID、偏向时间戳等。另一部分信息是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个来的实例。如果对象是一个Java数组，那在对象头中还必须有一块用于记录数组长度的数据，因为虚拟机可以通过普通Java对象的元数据信息确定Java对象大小，但是从数组的元数据却无法确定数组的大小。  </p>\n<h2 id=\"对象访问定位\"><a href=\"#对象访问定位\" class=\"headerlink\" title=\"对象访问定位\"></a>对象访问定位</h2><p>Java需要通过栈上的reference数据来操作堆上的具体对象，由于reference类型在Java虚拟机规范中只规定了一个指向对象的引用，并没有定义这个引用应该通过何种方式去定位、访问堆中对象的具体位置，所有对象访问方式也是取决于虚拟机实现而定。目前主流访问方式有使用句柄和直接指针两种。  </p>\n<ul>\n<li>句柄访问，Java堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。  </li>\n<li>指针访问，Java堆对象布局就必须考虑如何放置访问类型数据的相关信息，而reference中存储的直接就是对象地址。<br>句柄访问最大好处是reference中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而reference本身不需要修改。<br>指针访问最大好处是速度更快，节省了一次指针定位的时间开销。</li>\n</ul>\n<h2 id=\"JVM参数\"><a href=\"#JVM参数\" class=\"headerlink\" title=\"JVM参数\"></a>JVM参数</h2><ul>\n<li>-Xms和-Xmx    堆最小、最大值，大小值相同可避免自动扩展。</li>\n<li>-XX:+HeapDumpOnOutOfMemoryError可以让虚拟机在出现内存溢出错误时Dump出当前的内存堆转存储快照以便事后进行分析。</li>\n<li>-Xss    栈大小</li>\n<li>-XX:PermSize和-XX:MaxPermSize 方法区最小、最大值。</li>\n<li>-XX: MaxDirectMemorySize，如不指定默认与-Xmx一样。</li>\n</ul>\n<h2 id=\"方法区溢出\"><a href=\"#方法区溢出\" class=\"headerlink\" title=\"方法区溢出\"></a>方法区溢出</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * VM args: -XX:PermSize=10M -XX:MaxPermSize=10M</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">\tList&lt;String&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;String&gt;();</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(<span class=\"keyword\">true</span>)&#123;</span><br><span class=\"line\">\t\tlist.add(String.valueOf(i++).intern());</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上述代码在JDK1.7之前方法区内存不足时提示信息为”PermGen space”，说明运行时常量池属于方法区（HotSpot JVM中永久代）。而在JDK1.7运行时while将一直进行下去，不受PermSize限制，因为1.7开始逐步“去永久代”。</p>\n<h2 id=\"String-intern\"><a href=\"#String-intern\" class=\"headerlink\" title=\"String.intern()\"></a>String.intern()</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">\tString str1 = <span class=\"keyword\">new</span> StringBuilder(<span class=\"string\">\"abc\"</span>).append(<span class=\"string\">\"xyz\"</span>).toString();</span><br><span class=\"line\">\tSystem.out.println(str1.intern() == str1);</span><br><span class=\"line\">\tString str2 = <span class=\"keyword\">new</span> StringBuilder(<span class=\"string\">\"ja\"</span>).append(<span class=\"string\">\"va\"</span>).toString();</span><br><span class=\"line\">\tSystem.out.println(str2.intern() == str2);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上述代码在JDK1.6中执行，会得到2个false。而在JDK1.7中执行，会得到一个true和一个false。<br>在JDK1.6中，intern()方法会把首次遇到的字符串实例复制到永久代中。返回的也是永久代中这个字符串实例的引用，而有StringBuilder创建的字符串实例在Java堆上，所以必然不是同一个引用，将返回false。<br>在JDK1.7中，intern()的实现将不会再复制实例，只是在常量池中记录首次出现的实例引用，因此intern()返回的引用和由StringBuilder创建的那个字符串实例是同一个。对str2返回false是因为”java”这个字符串在执行StringBuilder.toString()之前已经出现过，字符串常量池中已经有它的引用了，不符合”首次出现”的原则。</p>\n"},{"title":"数组和集合","date":"2017-06-10T16:00:00.000Z","_content":"\n*\t[不同的列表选择不同的遍历方法](#不同的列表选择不同的遍历方法)\n* \t[子列表只是原列表的一个视图](#子列表只是原列表的一个视图)\n*  \t[优雅的集合运算](#优雅的集合运算)\n\n##\t不同的列表选择不同的遍历方法\n\n案例：统计一个省的各科高考平均值，比如数学平均分，使用纯 Java 算法来解决，看代码：\n\n```Java\n    public static void main(String[] args) {\n        int stuNum = 80 * 10000;\n        List<Integer> scores = new ArrayList<Integer>(stuNum);\n\n        for (int i = 0; i < stuNum; i++) {\n            scores.add(new Random().nextInt(150));\n        }\n\n        foreach(scores);\n        get(scores);\n    }\n\n    private static void foreach(List<Integer> list) {\n        Long start = System.currentTimeMillis();\n\n        Integer sum = 0;\n        for (Integer i : list) {\n            sum += i;\n        }\n        System.out.println(\"avg score: \" + sum / list.size());\n\n        Long end = System.currentTimeMillis();\n        System.out.println(end - start);\n\n    }\n\n    private static void get(List<Integer> list) {\n        Long start = System.currentTimeMillis();\n\n        Integer sum = 0;\n        for (int i = 0; i < list.size(); i++) {\n            sum += list.get(i);\n        }\n        System.out.println(\"avg score: \" + sum / list.size());\n\n        Long end = System.currentTimeMillis();\n        System.out.println(end - start);\n    }\n```\n\n执行结果：\n\n```\navg score: 74\n42\navg score: 74\n19\n```\n\n发现不使用 foreach 方式遍历列表，采用下标方式遍历，效率翻倍提高，这是为什么？\n\n这是因为 ArrayList 数组实现了 RandomAccess 接口（随机存取接口），这也就标志着 ArrayList 是一个可以随机存取的列表。在 Java 中，RandomAccess 和 Cloneable、Serializable 一样，都是标志性接口，一般不需要实现，只是用来表明其实现类具有某种特质，实现了 RandomAccess 表明这个类可以随机存取，对我们的 ArrayList 来说也就标志着其数据元素之间没有关联，即两个位置相邻的元素之间没有相互依赖和索引关系，可以随机访问和存储。\n\n 我们知道，Java 中的 foreach 语法是 iterator 的变形用法，也就是说上面的 foreach 与下面的代码等价：\n\n```Java\nfor (Iterator<Integer> i = list.iterator(); i.hasNext();){\n  sum += i.next();\n}\n```\n\n我们再想想什么是迭代器，迭代器是 23 个设计模式中的一种，“提供一种方法访问同一个容器对象中的各个元素、同时又无须暴露该对象的内部细节”，也就是说对于 ArrayList，需要先创建一个迭代器容器、然后屏蔽内部遍历细节，对外提供 hasNext、next 等方法。问题是 ArrayList 实现了 RandomAccess 接口，已表明元素之间本来没有关系，可是为了使用迭代器就需要强制建立一种互相”知晓“的关系，比如上一个元素可以判断是否有下一个元素，以及与下一个元素是什么关系等，这也就是通过 foreach 遍历耗时的原因。\n\nJava 为 ArrayList 加上了 RandomAccess 接口，就是在告诉我们要使用下标方式遍历会更快，接着又有一个问题：为什么不把 RandomAccess 加到所有 List 实现上呢？\n\n因为有些 List 实现类不是随机存取的，而是有序存取的，比如 LinkedList，它实现了双向链表。LinkedList 中的两个元素本来就是有关联的，我知道你的存在，你也知道我的存在。既然元素之间已经有关联关系了，使用 foreach 也就是迭代器方式必然效率更高。\n\n可能大家还想测试一下下标方式遍历 LinkedList 元素的情况，其实不用测试也能想到效率非常低下，我们看源码：\n\n```Java\n    Node<E> node(int index) {\n        // assert isElementIndex(index);\n\n        if (index < (size >> 1)) {\n            Node<E> x = first;\n            for (int i = 0; i < index; i++)\n                x = x.next;\n            return x;\n        } else {\n            Node<E> x = last;\n            for (int i = size - 1; i > index; i--)\n                x = x.prev;\n            return x;\n        }\n    }\n```\n\n程序会先判断输入的下标与中间值（size 右移一位，也就是除以2了）的关系，小于中间值则从头开始正向搜索，大于中间值则从尾节点反向搜索，想想看，每次的 get 方法都是一个遍历，”性能“从何说起。\n\n明白了随机存起列表和有序存取列表的区别，我们的 average 方法就必须重构了，以便实现不同的列表采用不同的遍历方式：\n\n```Java\n\t\tint sum = 0;\n        if (list instanceof RandomAccess) {\n            for (int i = 0; i < list.size(); i++) {\n                sum += list.get(i);\n            }\n        } else {\n            for (Integer i : list) {\n                sum += i;\n            }\n        }\n        System.out.println(\"avg score: \" + sum / list.size());\n```\n\n##\t子列表只是原列表的一个视图\n\nList 接口提供了 subList 方法，返回一个列表的子列表，看代码：\n\n```Java\n    public static void main(String[] args) {\n        List<String> c = new ArrayList<>();\n        c.add(\"A\");\n        c.add(\"B\");\n        List<String> c1 = new ArrayList<>(c);\n        List<String> c2 = c.subList(0, c.size());\n        c2.add(\"C\");\n        System.out.println(\"c == c1 ? \" + c.equals(c1));\n        System.out.println(\"c == c2 ? \" + c.equals(c2));\n    }\n```\n\n输出结果：\n\n```\nc == c1 ? false\nc == c2 ? true\n```\n\n这和 String 类的 subString 刚好相反，我们从源代码来分析，subList 源码：\n\n```Java\n    public List<E> subList(int fromIndex, int toIndex) {\n        return (this instanceof RandomAccess ?\n                new RandomAccessSubList<>(this, fromIndex, toIndex) :\n                new SubList<>(this, fromIndex, toIndex));\n    }\n```\n\nsubList 方法是由 AbstractList 实现的，它会根据是不是 RandomAccess 来提供不同的 SubList 实现。再看看 SubList 代码：\n\n```Java\n    SubList(AbstractList<E> list, int fromIndex, int toIndex) {\n        if (fromIndex < 0)\n            throw new IndexOutOfBoundsException(\"fromIndex = \" + fromIndex);\n        if (toIndex > list.size())\n            throw new IndexOutOfBoundsException(\"toIndex = \" + toIndex);\n        if (fromIndex > toIndex)\n            throw new IllegalArgumentException(\"fromIndex(\" + fromIndex +\n                                               \") > toIndex(\" + toIndex + \")\");\n        l = list;\n        offset = fromIndex;\n        size = toIndex - fromIndex;\n        this.modCount = l.modCount;\n    }\n    \n    public E set(int index, E element) {\n        rangeCheck(index);\n        checkForComodification();\n        return l.set(index+offset, element);\n    }\n\n    public E get(int index) {\n        rangeCheck(index);\n        checkForComodification();\n        return l.get(index+offset);\n    }\n    \n    public void add(int index, E element) {\n        rangeCheckForAdd(index);\n        checkForComodification();\n        l.add(index+offset, element);\n        this.modCount = l.modCount;\n        size++;\n    }\n\n    public E remove(int index) {\n        rangeCheck(index);\n        checkForComodification();\n        E result = l.remove(index+offset);\n        this.modCount = l.modCount;\n        size--;\n        return result;\n    }\n```\n\n通过这段代码，了解了 subList 方法实现原理：它返回的 SubList 类也是 AbstractList 子类，其所有方法如 get、set、add、remove 等都是在原始列表上的操作，它自身并没有生成一个数组或是链表，也就是子列表只是原列表的一个视图，所有的修改动作都反映在了原列表上。\n\n##\t优雅的集合运算\n\n###\t并集\n\n```Java\nlist1.addAll(list2);\n```\n\n###\t交集\n\n```Java\nlist1.retainAll(list2);\n```\n\n该方法会删除 list1 中没有出现在 list2 中的元素。\n\n###\t差集\n\n```Java\nlist1.removeAll(list2);\n```\n\n###\t无重复的并集\n\n什么叫无重复的并集？并集是集合 A 加集合 B，如果集合 A 和集合 B 有交集（也就是并集的元素数量大于0），就需要确保并集的结果中只有一份交集，此为无重复的并集。\n\n```Java\nlist2.removeAll(list1);\nlist1.addAll(list2);\n```\n\n有人可能有疑问，求出两个集合的并集，转变为 HashSet 剔除重复元素不就解决问题了吗？其实是不行的，比如集合 A 有 10 个元素（其中有两个元素值相同），集合 B 有 8 个元素，它们的交集有 2 个元素，我们可以计算出它们的并集是 18 个元素，而无重复的并集有 16 个元素，但是如果使用 HashSet，算出来则只有 15 个元素，因为把集合 A 中原本重复的元素也剔除掉了。\n\n","source":"_posts/编写高质量代码/数组和集合.md","raw":"---\ntitle: 数组和集合\ndate: 2017-06-11\ncategories: 编写高质量代码\ntags:\n- Java\n---\n\n*\t[不同的列表选择不同的遍历方法](#不同的列表选择不同的遍历方法)\n* \t[子列表只是原列表的一个视图](#子列表只是原列表的一个视图)\n*  \t[优雅的集合运算](#优雅的集合运算)\n\n##\t不同的列表选择不同的遍历方法\n\n案例：统计一个省的各科高考平均值，比如数学平均分，使用纯 Java 算法来解决，看代码：\n\n```Java\n    public static void main(String[] args) {\n        int stuNum = 80 * 10000;\n        List<Integer> scores = new ArrayList<Integer>(stuNum);\n\n        for (int i = 0; i < stuNum; i++) {\n            scores.add(new Random().nextInt(150));\n        }\n\n        foreach(scores);\n        get(scores);\n    }\n\n    private static void foreach(List<Integer> list) {\n        Long start = System.currentTimeMillis();\n\n        Integer sum = 0;\n        for (Integer i : list) {\n            sum += i;\n        }\n        System.out.println(\"avg score: \" + sum / list.size());\n\n        Long end = System.currentTimeMillis();\n        System.out.println(end - start);\n\n    }\n\n    private static void get(List<Integer> list) {\n        Long start = System.currentTimeMillis();\n\n        Integer sum = 0;\n        for (int i = 0; i < list.size(); i++) {\n            sum += list.get(i);\n        }\n        System.out.println(\"avg score: \" + sum / list.size());\n\n        Long end = System.currentTimeMillis();\n        System.out.println(end - start);\n    }\n```\n\n执行结果：\n\n```\navg score: 74\n42\navg score: 74\n19\n```\n\n发现不使用 foreach 方式遍历列表，采用下标方式遍历，效率翻倍提高，这是为什么？\n\n这是因为 ArrayList 数组实现了 RandomAccess 接口（随机存取接口），这也就标志着 ArrayList 是一个可以随机存取的列表。在 Java 中，RandomAccess 和 Cloneable、Serializable 一样，都是标志性接口，一般不需要实现，只是用来表明其实现类具有某种特质，实现了 RandomAccess 表明这个类可以随机存取，对我们的 ArrayList 来说也就标志着其数据元素之间没有关联，即两个位置相邻的元素之间没有相互依赖和索引关系，可以随机访问和存储。\n\n 我们知道，Java 中的 foreach 语法是 iterator 的变形用法，也就是说上面的 foreach 与下面的代码等价：\n\n```Java\nfor (Iterator<Integer> i = list.iterator(); i.hasNext();){\n  sum += i.next();\n}\n```\n\n我们再想想什么是迭代器，迭代器是 23 个设计模式中的一种，“提供一种方法访问同一个容器对象中的各个元素、同时又无须暴露该对象的内部细节”，也就是说对于 ArrayList，需要先创建一个迭代器容器、然后屏蔽内部遍历细节，对外提供 hasNext、next 等方法。问题是 ArrayList 实现了 RandomAccess 接口，已表明元素之间本来没有关系，可是为了使用迭代器就需要强制建立一种互相”知晓“的关系，比如上一个元素可以判断是否有下一个元素，以及与下一个元素是什么关系等，这也就是通过 foreach 遍历耗时的原因。\n\nJava 为 ArrayList 加上了 RandomAccess 接口，就是在告诉我们要使用下标方式遍历会更快，接着又有一个问题：为什么不把 RandomAccess 加到所有 List 实现上呢？\n\n因为有些 List 实现类不是随机存取的，而是有序存取的，比如 LinkedList，它实现了双向链表。LinkedList 中的两个元素本来就是有关联的，我知道你的存在，你也知道我的存在。既然元素之间已经有关联关系了，使用 foreach 也就是迭代器方式必然效率更高。\n\n可能大家还想测试一下下标方式遍历 LinkedList 元素的情况，其实不用测试也能想到效率非常低下，我们看源码：\n\n```Java\n    Node<E> node(int index) {\n        // assert isElementIndex(index);\n\n        if (index < (size >> 1)) {\n            Node<E> x = first;\n            for (int i = 0; i < index; i++)\n                x = x.next;\n            return x;\n        } else {\n            Node<E> x = last;\n            for (int i = size - 1; i > index; i--)\n                x = x.prev;\n            return x;\n        }\n    }\n```\n\n程序会先判断输入的下标与中间值（size 右移一位，也就是除以2了）的关系，小于中间值则从头开始正向搜索，大于中间值则从尾节点反向搜索，想想看，每次的 get 方法都是一个遍历，”性能“从何说起。\n\n明白了随机存起列表和有序存取列表的区别，我们的 average 方法就必须重构了，以便实现不同的列表采用不同的遍历方式：\n\n```Java\n\t\tint sum = 0;\n        if (list instanceof RandomAccess) {\n            for (int i = 0; i < list.size(); i++) {\n                sum += list.get(i);\n            }\n        } else {\n            for (Integer i : list) {\n                sum += i;\n            }\n        }\n        System.out.println(\"avg score: \" + sum / list.size());\n```\n\n##\t子列表只是原列表的一个视图\n\nList 接口提供了 subList 方法，返回一个列表的子列表，看代码：\n\n```Java\n    public static void main(String[] args) {\n        List<String> c = new ArrayList<>();\n        c.add(\"A\");\n        c.add(\"B\");\n        List<String> c1 = new ArrayList<>(c);\n        List<String> c2 = c.subList(0, c.size());\n        c2.add(\"C\");\n        System.out.println(\"c == c1 ? \" + c.equals(c1));\n        System.out.println(\"c == c2 ? \" + c.equals(c2));\n    }\n```\n\n输出结果：\n\n```\nc == c1 ? false\nc == c2 ? true\n```\n\n这和 String 类的 subString 刚好相反，我们从源代码来分析，subList 源码：\n\n```Java\n    public List<E> subList(int fromIndex, int toIndex) {\n        return (this instanceof RandomAccess ?\n                new RandomAccessSubList<>(this, fromIndex, toIndex) :\n                new SubList<>(this, fromIndex, toIndex));\n    }\n```\n\nsubList 方法是由 AbstractList 实现的，它会根据是不是 RandomAccess 来提供不同的 SubList 实现。再看看 SubList 代码：\n\n```Java\n    SubList(AbstractList<E> list, int fromIndex, int toIndex) {\n        if (fromIndex < 0)\n            throw new IndexOutOfBoundsException(\"fromIndex = \" + fromIndex);\n        if (toIndex > list.size())\n            throw new IndexOutOfBoundsException(\"toIndex = \" + toIndex);\n        if (fromIndex > toIndex)\n            throw new IllegalArgumentException(\"fromIndex(\" + fromIndex +\n                                               \") > toIndex(\" + toIndex + \")\");\n        l = list;\n        offset = fromIndex;\n        size = toIndex - fromIndex;\n        this.modCount = l.modCount;\n    }\n    \n    public E set(int index, E element) {\n        rangeCheck(index);\n        checkForComodification();\n        return l.set(index+offset, element);\n    }\n\n    public E get(int index) {\n        rangeCheck(index);\n        checkForComodification();\n        return l.get(index+offset);\n    }\n    \n    public void add(int index, E element) {\n        rangeCheckForAdd(index);\n        checkForComodification();\n        l.add(index+offset, element);\n        this.modCount = l.modCount;\n        size++;\n    }\n\n    public E remove(int index) {\n        rangeCheck(index);\n        checkForComodification();\n        E result = l.remove(index+offset);\n        this.modCount = l.modCount;\n        size--;\n        return result;\n    }\n```\n\n通过这段代码，了解了 subList 方法实现原理：它返回的 SubList 类也是 AbstractList 子类，其所有方法如 get、set、add、remove 等都是在原始列表上的操作，它自身并没有生成一个数组或是链表，也就是子列表只是原列表的一个视图，所有的修改动作都反映在了原列表上。\n\n##\t优雅的集合运算\n\n###\t并集\n\n```Java\nlist1.addAll(list2);\n```\n\n###\t交集\n\n```Java\nlist1.retainAll(list2);\n```\n\n该方法会删除 list1 中没有出现在 list2 中的元素。\n\n###\t差集\n\n```Java\nlist1.removeAll(list2);\n```\n\n###\t无重复的并集\n\n什么叫无重复的并集？并集是集合 A 加集合 B，如果集合 A 和集合 B 有交集（也就是并集的元素数量大于0），就需要确保并集的结果中只有一份交集，此为无重复的并集。\n\n```Java\nlist2.removeAll(list1);\nlist1.addAll(list2);\n```\n\n有人可能有疑问，求出两个集合的并集，转变为 HashSet 剔除重复元素不就解决问题了吗？其实是不行的，比如集合 A 有 10 个元素（其中有两个元素值相同），集合 B 有 8 个元素，它们的交集有 2 个元素，我们可以计算出它们的并集是 18 个元素，而无重复的并集有 16 个元素，但是如果使用 HashSet，算出来则只有 15 个元素，因为把集合 A 中原本重复的元素也剔除掉了。\n\n","slug":"编写高质量代码/数组和集合","published":1,"updated":"2019-05-17T05:57:58.586Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1j8f2iu001w7h9mvyxq8kgs","content":"<ul>\n<li><a href=\"#不同的列表选择不同的遍历方法\">不同的列表选择不同的遍历方法</a></li>\n<li><a href=\"#子列表只是原列表的一个视图\">子列表只是原列表的一个视图</a></li>\n<li><a href=\"#优雅的集合运算\">优雅的集合运算</a></li>\n</ul>\n<h2 id=\"不同的列表选择不同的遍历方法\"><a href=\"#不同的列表选择不同的遍历方法\" class=\"headerlink\" title=\"不同的列表选择不同的遍历方法\"></a>不同的列表选择不同的遍历方法</h2><p>案例：统计一个省的各科高考平均值，比如数学平均分，使用纯 Java 算法来解决，看代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> stuNum = <span class=\"number\">80</span> * <span class=\"number\">10000</span>;</span><br><span class=\"line\">    List&lt;Integer&gt; scores = <span class=\"keyword\">new</span> ArrayList&lt;Integer&gt;(stuNum);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; stuNum; i++) &#123;</span><br><span class=\"line\">        scores.add(<span class=\"keyword\">new</span> Random().nextInt(<span class=\"number\">150</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    foreach(scores);</span><br><span class=\"line\">    get(scores);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">foreach</span><span class=\"params\">(List&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class=\"line\">    Long start = System.currentTimeMillis();</span><br><span class=\"line\"></span><br><span class=\"line\">    Integer sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Integer i : list) &#123;</span><br><span class=\"line\">        sum += i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"avg score: \"</span> + sum / list.size());</span><br><span class=\"line\"></span><br><span class=\"line\">    Long end = System.currentTimeMillis();</span><br><span class=\"line\">    System.out.println(end - start);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">get</span><span class=\"params\">(List&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class=\"line\">    Long start = System.currentTimeMillis();</span><br><span class=\"line\"></span><br><span class=\"line\">    Integer sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class=\"line\">        sum += list.get(i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"avg score: \"</span> + sum / list.size());</span><br><span class=\"line\"></span><br><span class=\"line\">    Long end = System.currentTimeMillis();</span><br><span class=\"line\">    System.out.println(end - start);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>执行结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">avg score: 74</span><br><span class=\"line\">42</span><br><span class=\"line\">avg score: 74</span><br><span class=\"line\">19</span><br></pre></td></tr></table></figure>\n<p>发现不使用 foreach 方式遍历列表，采用下标方式遍历，效率翻倍提高，这是为什么？</p>\n<p>这是因为 ArrayList 数组实现了 RandomAccess 接口（随机存取接口），这也就标志着 ArrayList 是一个可以随机存取的列表。在 Java 中，RandomAccess 和 Cloneable、Serializable 一样，都是标志性接口，一般不需要实现，只是用来表明其实现类具有某种特质，实现了 RandomAccess 表明这个类可以随机存取，对我们的 ArrayList 来说也就标志着其数据元素之间没有关联，即两个位置相邻的元素之间没有相互依赖和索引关系，可以随机访问和存储。</p>\n<p> 我们知道，Java 中的 foreach 语法是 iterator 的变形用法，也就是说上面的 foreach 与下面的代码等价：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (Iterator&lt;Integer&gt; i = list.iterator(); i.hasNext();)&#123;</span><br><span class=\"line\">  sum += i.next();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们再想想什么是迭代器，迭代器是 23 个设计模式中的一种，“提供一种方法访问同一个容器对象中的各个元素、同时又无须暴露该对象的内部细节”，也就是说对于 ArrayList，需要先创建一个迭代器容器、然后屏蔽内部遍历细节，对外提供 hasNext、next 等方法。问题是 ArrayList 实现了 RandomAccess 接口，已表明元素之间本来没有关系，可是为了使用迭代器就需要强制建立一种互相”知晓“的关系，比如上一个元素可以判断是否有下一个元素，以及与下一个元素是什么关系等，这也就是通过 foreach 遍历耗时的原因。</p>\n<p>Java 为 ArrayList 加上了 RandomAccess 接口，就是在告诉我们要使用下标方式遍历会更快，接着又有一个问题：为什么不把 RandomAccess 加到所有 List 实现上呢？</p>\n<p>因为有些 List 实现类不是随机存取的，而是有序存取的，比如 LinkedList，它实现了双向链表。LinkedList 中的两个元素本来就是有关联的，我知道你的存在，你也知道我的存在。既然元素之间已经有关联关系了，使用 foreach 也就是迭代器方式必然效率更高。</p>\n<p>可能大家还想测试一下下标方式遍历 LinkedList 元素的情况，其实不用测试也能想到效率非常低下，我们看源码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Node&lt;E&gt; <span class=\"title\">node</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// assert isElementIndex(index);</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (index &lt; (size &gt;&gt; <span class=\"number\">1</span>)) &#123;</span><br><span class=\"line\">        Node&lt;E&gt; x = first;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; index; i++)</span><br><span class=\"line\">            x = x.next;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        Node&lt;E&gt; x = last;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = size - <span class=\"number\">1</span>; i &gt; index; i--)</span><br><span class=\"line\">            x = x.prev;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>程序会先判断输入的下标与中间值（size 右移一位，也就是除以2了）的关系，小于中间值则从头开始正向搜索，大于中间值则从尾节点反向搜索，想想看，每次的 get 方法都是一个遍历，”性能“从何说起。</p>\n<p>明白了随机存起列表和有序存取列表的区别，我们的 average 方法就必须重构了，以便实现不同的列表采用不同的遍历方式：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (list <span class=\"keyword\">instanceof</span> RandomAccess) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class=\"line\">              sum += list.get(i);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">          <span class=\"keyword\">for</span> (Integer i : list) &#123;</span><br><span class=\"line\">              sum += i;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      System.out.println(<span class=\"string\">\"avg score: \"</span> + sum / list.size());</span><br></pre></td></tr></table></figure>\n<h2 id=\"子列表只是原列表的一个视图\"><a href=\"#子列表只是原列表的一个视图\" class=\"headerlink\" title=\"子列表只是原列表的一个视图\"></a>子列表只是原列表的一个视图</h2><p>List 接口提供了 subList 方法，返回一个列表的子列表，看代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    List&lt;String&gt; c = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">    c.add(<span class=\"string\">\"A\"</span>);</span><br><span class=\"line\">    c.add(<span class=\"string\">\"B\"</span>);</span><br><span class=\"line\">    List&lt;String&gt; c1 = <span class=\"keyword\">new</span> ArrayList&lt;&gt;(c);</span><br><span class=\"line\">    List&lt;String&gt; c2 = c.subList(<span class=\"number\">0</span>, c.size());</span><br><span class=\"line\">    c2.add(<span class=\"string\">\"C\"</span>);</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"c == c1 ? \"</span> + c.equals(c1));</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"c == c2 ? \"</span> + c.equals(c2));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">c == c1 ? false</span><br><span class=\"line\">c == c2 ? true</span><br></pre></td></tr></table></figure>\n<p>这和 String 类的 subString 刚好相反，我们从源代码来分析，subList 源码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> List&lt;E&gt; <span class=\"title\">subList</span><span class=\"params\">(<span class=\"keyword\">int</span> fromIndex, <span class=\"keyword\">int</span> toIndex)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (<span class=\"keyword\">this</span> <span class=\"keyword\">instanceof</span> RandomAccess ?</span><br><span class=\"line\">            <span class=\"keyword\">new</span> RandomAccessSubList&lt;&gt;(<span class=\"keyword\">this</span>, fromIndex, toIndex) :</span><br><span class=\"line\">            <span class=\"keyword\">new</span> SubList&lt;&gt;(<span class=\"keyword\">this</span>, fromIndex, toIndex));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>subList 方法是由 AbstractList 实现的，它会根据是不是 RandomAccess 来提供不同的 SubList 实现。再看看 SubList 代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SubList(AbstractList&lt;E&gt; list, <span class=\"keyword\">int</span> fromIndex, <span class=\"keyword\">int</span> toIndex) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (fromIndex &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IndexOutOfBoundsException(<span class=\"string\">\"fromIndex = \"</span> + fromIndex);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (toIndex &gt; list.size())</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IndexOutOfBoundsException(<span class=\"string\">\"toIndex = \"</span> + toIndex);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (fromIndex &gt; toIndex)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"fromIndex(\"</span> + fromIndex +</span><br><span class=\"line\">                                           <span class=\"string\">\") &gt; toIndex(\"</span> + toIndex + <span class=\"string\">\")\"</span>);</span><br><span class=\"line\">    l = list;</span><br><span class=\"line\">    offset = fromIndex;</span><br><span class=\"line\">    size = toIndex - fromIndex;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.modCount = l.modCount;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">set</span><span class=\"params\">(<span class=\"keyword\">int</span> index, E element)</span> </span>&#123;</span><br><span class=\"line\">    rangeCheck(index);</span><br><span class=\"line\">    checkForComodification();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> l.set(index+offset, element);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">get</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">    rangeCheck(index);</span><br><span class=\"line\">    checkForComodification();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> l.get(index+offset);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> index, E element)</span> </span>&#123;</span><br><span class=\"line\">    rangeCheckForAdd(index);</span><br><span class=\"line\">    checkForComodification();</span><br><span class=\"line\">    l.add(index+offset, element);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.modCount = l.modCount;</span><br><span class=\"line\">    size++;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">remove</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">    rangeCheck(index);</span><br><span class=\"line\">    checkForComodification();</span><br><span class=\"line\">    E result = l.remove(index+offset);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.modCount = l.modCount;</span><br><span class=\"line\">    size--;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过这段代码，了解了 subList 方法实现原理：它返回的 SubList 类也是 AbstractList 子类，其所有方法如 get、set、add、remove 等都是在原始列表上的操作，它自身并没有生成一个数组或是链表，也就是子列表只是原列表的一个视图，所有的修改动作都反映在了原列表上。</p>\n<h2 id=\"优雅的集合运算\"><a href=\"#优雅的集合运算\" class=\"headerlink\" title=\"优雅的集合运算\"></a>优雅的集合运算</h2><h3 id=\"并集\"><a href=\"#并集\" class=\"headerlink\" title=\"并集\"></a>并集</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">list1.addAll(list2);</span><br></pre></td></tr></table></figure>\n<h3 id=\"交集\"><a href=\"#交集\" class=\"headerlink\" title=\"交集\"></a>交集</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">list1.retainAll(list2);</span><br></pre></td></tr></table></figure>\n<p>该方法会删除 list1 中没有出现在 list2 中的元素。</p>\n<h3 id=\"差集\"><a href=\"#差集\" class=\"headerlink\" title=\"差集\"></a>差集</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">list1.removeAll(list2);</span><br></pre></td></tr></table></figure>\n<h3 id=\"无重复的并集\"><a href=\"#无重复的并集\" class=\"headerlink\" title=\"无重复的并集\"></a>无重复的并集</h3><p>什么叫无重复的并集？并集是集合 A 加集合 B，如果集合 A 和集合 B 有交集（也就是并集的元素数量大于0），就需要确保并集的结果中只有一份交集，此为无重复的并集。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">list2.removeAll(list1);</span><br><span class=\"line\">list1.addAll(list2);</span><br></pre></td></tr></table></figure>\n<p>有人可能有疑问，求出两个集合的并集，转变为 HashSet 剔除重复元素不就解决问题了吗？其实是不行的，比如集合 A 有 10 个元素（其中有两个元素值相同），集合 B 有 8 个元素，它们的交集有 2 个元素，我们可以计算出它们的并集是 18 个元素，而无重复的并集有 16 个元素，但是如果使用 HashSet，算出来则只有 15 个元素，因为把集合 A 中原本重复的元素也剔除掉了。</p>\n","excerpt":"","more":"<ul>\n<li><a href=\"#不同的列表选择不同的遍历方法\">不同的列表选择不同的遍历方法</a></li>\n<li><a href=\"#子列表只是原列表的一个视图\">子列表只是原列表的一个视图</a></li>\n<li><a href=\"#优雅的集合运算\">优雅的集合运算</a></li>\n</ul>\n<h2 id=\"不同的列表选择不同的遍历方法\"><a href=\"#不同的列表选择不同的遍历方法\" class=\"headerlink\" title=\"不同的列表选择不同的遍历方法\"></a>不同的列表选择不同的遍历方法</h2><p>案例：统计一个省的各科高考平均值，比如数学平均分，使用纯 Java 算法来解决，看代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> stuNum = <span class=\"number\">80</span> * <span class=\"number\">10000</span>;</span><br><span class=\"line\">    List&lt;Integer&gt; scores = <span class=\"keyword\">new</span> ArrayList&lt;Integer&gt;(stuNum);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; stuNum; i++) &#123;</span><br><span class=\"line\">        scores.add(<span class=\"keyword\">new</span> Random().nextInt(<span class=\"number\">150</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    foreach(scores);</span><br><span class=\"line\">    get(scores);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">foreach</span><span class=\"params\">(List&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class=\"line\">    Long start = System.currentTimeMillis();</span><br><span class=\"line\"></span><br><span class=\"line\">    Integer sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Integer i : list) &#123;</span><br><span class=\"line\">        sum += i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"avg score: \"</span> + sum / list.size());</span><br><span class=\"line\"></span><br><span class=\"line\">    Long end = System.currentTimeMillis();</span><br><span class=\"line\">    System.out.println(end - start);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">get</span><span class=\"params\">(List&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class=\"line\">    Long start = System.currentTimeMillis();</span><br><span class=\"line\"></span><br><span class=\"line\">    Integer sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class=\"line\">        sum += list.get(i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"avg score: \"</span> + sum / list.size());</span><br><span class=\"line\"></span><br><span class=\"line\">    Long end = System.currentTimeMillis();</span><br><span class=\"line\">    System.out.println(end - start);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>执行结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">avg score: 74</span><br><span class=\"line\">42</span><br><span class=\"line\">avg score: 74</span><br><span class=\"line\">19</span><br></pre></td></tr></table></figure>\n<p>发现不使用 foreach 方式遍历列表，采用下标方式遍历，效率翻倍提高，这是为什么？</p>\n<p>这是因为 ArrayList 数组实现了 RandomAccess 接口（随机存取接口），这也就标志着 ArrayList 是一个可以随机存取的列表。在 Java 中，RandomAccess 和 Cloneable、Serializable 一样，都是标志性接口，一般不需要实现，只是用来表明其实现类具有某种特质，实现了 RandomAccess 表明这个类可以随机存取，对我们的 ArrayList 来说也就标志着其数据元素之间没有关联，即两个位置相邻的元素之间没有相互依赖和索引关系，可以随机访问和存储。</p>\n<p> 我们知道，Java 中的 foreach 语法是 iterator 的变形用法，也就是说上面的 foreach 与下面的代码等价：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (Iterator&lt;Integer&gt; i = list.iterator(); i.hasNext();)&#123;</span><br><span class=\"line\">  sum += i.next();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们再想想什么是迭代器，迭代器是 23 个设计模式中的一种，“提供一种方法访问同一个容器对象中的各个元素、同时又无须暴露该对象的内部细节”，也就是说对于 ArrayList，需要先创建一个迭代器容器、然后屏蔽内部遍历细节，对外提供 hasNext、next 等方法。问题是 ArrayList 实现了 RandomAccess 接口，已表明元素之间本来没有关系，可是为了使用迭代器就需要强制建立一种互相”知晓“的关系，比如上一个元素可以判断是否有下一个元素，以及与下一个元素是什么关系等，这也就是通过 foreach 遍历耗时的原因。</p>\n<p>Java 为 ArrayList 加上了 RandomAccess 接口，就是在告诉我们要使用下标方式遍历会更快，接着又有一个问题：为什么不把 RandomAccess 加到所有 List 实现上呢？</p>\n<p>因为有些 List 实现类不是随机存取的，而是有序存取的，比如 LinkedList，它实现了双向链表。LinkedList 中的两个元素本来就是有关联的，我知道你的存在，你也知道我的存在。既然元素之间已经有关联关系了，使用 foreach 也就是迭代器方式必然效率更高。</p>\n<p>可能大家还想测试一下下标方式遍历 LinkedList 元素的情况，其实不用测试也能想到效率非常低下，我们看源码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Node&lt;E&gt; <span class=\"title\">node</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// assert isElementIndex(index);</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (index &lt; (size &gt;&gt; <span class=\"number\">1</span>)) &#123;</span><br><span class=\"line\">        Node&lt;E&gt; x = first;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; index; i++)</span><br><span class=\"line\">            x = x.next;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        Node&lt;E&gt; x = last;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = size - <span class=\"number\">1</span>; i &gt; index; i--)</span><br><span class=\"line\">            x = x.prev;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>程序会先判断输入的下标与中间值（size 右移一位，也就是除以2了）的关系，小于中间值则从头开始正向搜索，大于中间值则从尾节点反向搜索，想想看，每次的 get 方法都是一个遍历，”性能“从何说起。</p>\n<p>明白了随机存起列表和有序存取列表的区别，我们的 average 方法就必须重构了，以便实现不同的列表采用不同的遍历方式：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (list <span class=\"keyword\">instanceof</span> RandomAccess) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class=\"line\">              sum += list.get(i);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">          <span class=\"keyword\">for</span> (Integer i : list) &#123;</span><br><span class=\"line\">              sum += i;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      System.out.println(<span class=\"string\">\"avg score: \"</span> + sum / list.size());</span><br></pre></td></tr></table></figure>\n<h2 id=\"子列表只是原列表的一个视图\"><a href=\"#子列表只是原列表的一个视图\" class=\"headerlink\" title=\"子列表只是原列表的一个视图\"></a>子列表只是原列表的一个视图</h2><p>List 接口提供了 subList 方法，返回一个列表的子列表，看代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    List&lt;String&gt; c = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">    c.add(<span class=\"string\">\"A\"</span>);</span><br><span class=\"line\">    c.add(<span class=\"string\">\"B\"</span>);</span><br><span class=\"line\">    List&lt;String&gt; c1 = <span class=\"keyword\">new</span> ArrayList&lt;&gt;(c);</span><br><span class=\"line\">    List&lt;String&gt; c2 = c.subList(<span class=\"number\">0</span>, c.size());</span><br><span class=\"line\">    c2.add(<span class=\"string\">\"C\"</span>);</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"c == c1 ? \"</span> + c.equals(c1));</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"c == c2 ? \"</span> + c.equals(c2));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">c == c1 ? false</span><br><span class=\"line\">c == c2 ? true</span><br></pre></td></tr></table></figure>\n<p>这和 String 类的 subString 刚好相反，我们从源代码来分析，subList 源码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> List&lt;E&gt; <span class=\"title\">subList</span><span class=\"params\">(<span class=\"keyword\">int</span> fromIndex, <span class=\"keyword\">int</span> toIndex)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (<span class=\"keyword\">this</span> <span class=\"keyword\">instanceof</span> RandomAccess ?</span><br><span class=\"line\">            <span class=\"keyword\">new</span> RandomAccessSubList&lt;&gt;(<span class=\"keyword\">this</span>, fromIndex, toIndex) :</span><br><span class=\"line\">            <span class=\"keyword\">new</span> SubList&lt;&gt;(<span class=\"keyword\">this</span>, fromIndex, toIndex));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>subList 方法是由 AbstractList 实现的，它会根据是不是 RandomAccess 来提供不同的 SubList 实现。再看看 SubList 代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SubList(AbstractList&lt;E&gt; list, <span class=\"keyword\">int</span> fromIndex, <span class=\"keyword\">int</span> toIndex) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (fromIndex &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IndexOutOfBoundsException(<span class=\"string\">\"fromIndex = \"</span> + fromIndex);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (toIndex &gt; list.size())</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IndexOutOfBoundsException(<span class=\"string\">\"toIndex = \"</span> + toIndex);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (fromIndex &gt; toIndex)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"fromIndex(\"</span> + fromIndex +</span><br><span class=\"line\">                                           <span class=\"string\">\") &gt; toIndex(\"</span> + toIndex + <span class=\"string\">\")\"</span>);</span><br><span class=\"line\">    l = list;</span><br><span class=\"line\">    offset = fromIndex;</span><br><span class=\"line\">    size = toIndex - fromIndex;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.modCount = l.modCount;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">set</span><span class=\"params\">(<span class=\"keyword\">int</span> index, E element)</span> </span>&#123;</span><br><span class=\"line\">    rangeCheck(index);</span><br><span class=\"line\">    checkForComodification();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> l.set(index+offset, element);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">get</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">    rangeCheck(index);</span><br><span class=\"line\">    checkForComodification();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> l.get(index+offset);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> index, E element)</span> </span>&#123;</span><br><span class=\"line\">    rangeCheckForAdd(index);</span><br><span class=\"line\">    checkForComodification();</span><br><span class=\"line\">    l.add(index+offset, element);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.modCount = l.modCount;</span><br><span class=\"line\">    size++;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">remove</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">    rangeCheck(index);</span><br><span class=\"line\">    checkForComodification();</span><br><span class=\"line\">    E result = l.remove(index+offset);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.modCount = l.modCount;</span><br><span class=\"line\">    size--;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过这段代码，了解了 subList 方法实现原理：它返回的 SubList 类也是 AbstractList 子类，其所有方法如 get、set、add、remove 等都是在原始列表上的操作，它自身并没有生成一个数组或是链表，也就是子列表只是原列表的一个视图，所有的修改动作都反映在了原列表上。</p>\n<h2 id=\"优雅的集合运算\"><a href=\"#优雅的集合运算\" class=\"headerlink\" title=\"优雅的集合运算\"></a>优雅的集合运算</h2><h3 id=\"并集\"><a href=\"#并集\" class=\"headerlink\" title=\"并集\"></a>并集</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">list1.addAll(list2);</span><br></pre></td></tr></table></figure>\n<h3 id=\"交集\"><a href=\"#交集\" class=\"headerlink\" title=\"交集\"></a>交集</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">list1.retainAll(list2);</span><br></pre></td></tr></table></figure>\n<p>该方法会删除 list1 中没有出现在 list2 中的元素。</p>\n<h3 id=\"差集\"><a href=\"#差集\" class=\"headerlink\" title=\"差集\"></a>差集</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">list1.removeAll(list2);</span><br></pre></td></tr></table></figure>\n<h3 id=\"无重复的并集\"><a href=\"#无重复的并集\" class=\"headerlink\" title=\"无重复的并集\"></a>无重复的并集</h3><p>什么叫无重复的并集？并集是集合 A 加集合 B，如果集合 A 和集合 B 有交集（也就是并集的元素数量大于0），就需要确保并集的结果中只有一份交集，此为无重复的并集。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">list2.removeAll(list1);</span><br><span class=\"line\">list1.addAll(list2);</span><br></pre></td></tr></table></figure>\n<p>有人可能有疑问，求出两个集合的并集，转变为 HashSet 剔除重复元素不就解决问题了吗？其实是不行的，比如集合 A 有 10 个元素（其中有两个元素值相同），集合 B 有 8 个元素，它们的交集有 2 个元素，我们可以计算出它们的并集是 18 个元素，而无重复的并集有 16 个元素，但是如果使用 HashSet，算出来则只有 15 个元素，因为把集合 A 中原本重复的元素也剔除掉了。</p>\n"},{"title":"Java8 -- StreamAPI","date":"2016-12-18T16:00:00.000Z","_content":"\n#\tJava8新特性 -- StreamAPI\n\nStream 是 Java 8 中处理集合的关键抽象概念，它可以指定你希望对集合进行的操作，但是将执行操作的时间交给具体实现来决定。\n\n*\t迭代器遍历策略特定，不能并发执行。\n*\t集合、数组、生成器、迭代器均和创建 Stream。\n* \t过滤器 filter 选择元素，map 改变元素。\n*  \t改变 Stream 的操作包括 limit、distinct 和 sorted。\n*\t从Stream中获得结果，使用 reduction 操作符，例如 count、max、min、findFirst 或 findAny。其中一些方法返回 Optional 值。\n* \tOptional 类型为了安全地替代使用 null 值，需要借助 ifPresent 和 orElse 方法。\n*  \tCollectors 类的 groupingBy 和 partitioningBy 方法允许你对 Stream 中内容分组。\n*\tJava 8 对原始类型 int、long 和 double 提供专门的 Stream。\n* \t并行 Stream，放弃排序约束。\n\n##\t从迭代器到 Stream 操作\n\n处理集合时，通常会迭代所有元素并对其中的每一个进行处理。\n\n```Java\npublic class Sample1 {\n\n    public static void main(String[] args) {\n        List<String> list = letters();\n        list.forEach(System.out::println);\n\n        countWord(list);\n        filterCountWord(list);\n        parallelFilterCountWord(list);\n\n    }\n\n    private static List<String> letters() {\n        List<String> list = new ArrayList<>();\n        list.add(\"Tommy\");\n        list.add(\"Focus\");\n        list.add(\"Tim\");\n        list.add(\"Jack\");\n        return list;\n    }\n\n    private static void countWord(List<String> list) {\n        int count = 0;\n        for (String str : list) {\n            if (str.length() > 4)\n                count++;\n        }\n        System.out.println(\"countWord: \" + count);\n    }\n\n    private static void filterCountWord(List<String> list) {\n        long count = list.stream().filter(w -> w.length() > 4).count();\n        System.out.println(\"filterCountWord: \" + count);\n    }\n\n    private static void parallelFilterCountWord(List<String> list) {\n        long count = list.parallelStream().filter(w -> w.length() > 4).count();\n        System.out.println(\"parallelFilterCountWord: \" + count);\n    }\n\n}\n```\n\n1.\tStream 不存储元素。元素可能被存储在底层的集合中，或根据需要产生出来。\n2. \tStream 操作符不改变源对象。它们返回一个持有结果的新 Stream。\n3. \tStream 操作符可能延迟执行。\n\n##\t创建 Stream\n\n###\tAPI\n\n```Java\n    /**\n     * Returns a sequential {@code Stream} containing a single element.\n     *\n     * @param t the single element\n     * @param <T> the type of stream elements\n     * @return a singleton sequential stream\n     */\n    public static<T> Stream<T> of(T t) {\n        return StreamSupport.stream(new Streams.StreamBuilderImpl<>(t), false);\n    }\n```\n\n```Java\n    /**\n     * Returns a sequential ordered stream whose elements are the specified values.\n     *\n     * @param <T> the type of stream elements\n     * @param values the elements of the new stream\n     * @return the new stream\n     */\n    @SafeVarargs\n    @SuppressWarnings(\"varargs\") // Creating a stream from an array is safe\n    public static<T> Stream<T> of(T... values) {\n        return Arrays.stream(values);\n    }\n```\n\ngenerate 和 iterate 是两个用来创建无限 Stream 的静态方法。\n\n```Java\npublic class Sample2 {\n\n    public static void main(String[] args) {\n        Stream<String> echos = Stream.generate(() -> \"Echo\");\n        Stream<Double> randoms = Stream.generate(Math::random);\n        Stream<BigInteger> integers = Stream.iterate(BigInteger.ZERO, n -> n.add(BigInteger.ONE));\n\n        Object[] powers = Stream.iterate(1.0, p -> p * 2).peek(e -> System.out.println(\"Fetching \" + e)).limit(20).toArray();\n\n        System.out.println(\"well done ...\");\n\n    }\n}\n\n```\n\n###\tfilter、map 和 flatMap\n\n流转换指从一个流中读取数据，并将转换后的数据写入另一个流。\n\n```Java\npublic class Sample3 {\n\n    public static void main(String[] args) {\n        List<String> list = letters();\n        Stream<String> lowerString = list.stream().map(String::toLowerCase);\n        lowerString.forEach(System.out::println);\n\n        Stream<Character> characterStream = list.stream().flatMap(Sample3::characterStream);\n        characterStream.forEach(System.out::println);\n    }\n\n    private static List<String> letters() {\n        List<String> list = new ArrayList<>();\n        list.add(\"Tommy\");\n        list.add(\"Focus\");\n        list.add(\"Tim\");\n        list.add(\"Jack\");\n        return list;\n    }\n\n    public static Stream<Character> characterStream(String s) {\n        List<Character> result = new ArrayList<>();\n        for (char c : s.toCharArray()) {\n            result.add(c);\n        }\n        return result.stream();\n    }\n}\n```\n\n1.\tmap 方法，会对每个元素应用一个函数，将返回值收集到一个新的流中。\n2. \tflatMap 方法，完成从 T 到 G\\<U> 的 f 函数和从 U 到 G\\<U> 的 g 方法，这是 monads 理论的一个关键概念。\n\n###\t提取子流和组合流\n\nStream.limit(n) 返回一个 n 个元素的新流（如果原始流的长度小于n，则返回原始的流）。\n\n```Java\npublic class Sample5 {\n\n    public static void main(String[] args) {\n        unique();\n\n        sort();\n\n    }\n\n    public static void unique(){\n        Stream<String> uniqueWords = Stream.of(\"zhuxh\", \"zhuxh\", \"zhuxh\", \"focus\").distinct();\n        uniqueWords.forEach(System.out::println);\n    }\n\n    public static void sort(){\n        List<String> list = letters();\n        Stream<String> stringStream = list.stream();\n\n        Stream<String> longestFirst = stringStream.sorted(Comparator.comparing(String::length).reversed());\n        longestFirst.forEach(System.out::println);\n\n    }\n\n    private static List<String> letters() {\n        List<String> list = new ArrayList<>();\n        list.add(\"Tommy\");\n        list.add(\"Focus\");\n        list.add(\"Tim\");\n        list.add(\"Jack\");\n        return list;\n    }\n}\n```\n\n###\t简单的聚合方法\n\n聚合方法都是*终止操作*，当一个流应用了终止操作后，不能再应用其他操作。\n\n聚合方法，count、max、min，返回一个 Optional<T> 值，可能封装返回值，也可能没有返回值。\n\n```Java\npublic class Sample6 {\n\n    public static void main(String[] args) {\n        Stream<String> stringStream = letters().stream();\n\n        Optional<String> largestString = stringStream.max(String::compareToIgnoreCase);\n\n        if(largestString.isPresent()){\n            System.out.println(largestString.get());\n        }\n    }\n\n    private static List<String> letters() {\n        List<String> list = new ArrayList<>();\n        list.add(\"Tommy\");\n        list.add(\"Focus\");\n        list.add(\"Tim\");\n        list.add(\"Jack\");\n        return list;\n    }\n\n}\n```\n\n类似的API还有 findFirst(), findAny()。\n\n还提供了 anyMatch(), allMatch 和 noneMatch()，这些方法总是会检查整个流，但仍可以通过并行执行来提高速度。\n\n###\tOptional 类型\n\njava.util.Optional\\<T\\>\n\nOptional\\<T\\> 对象是对一个 T 类型对象的封装，或者表示不是任何对象。它比一般指向 T 类型引用更安全，不会反悔null--前提是你正确使用。\n\n创建 Optional 对象\n\n```Java\n    public static <T> Optional<T> of(T value) {\n        return new Optional<>(value);\n    }\n    \n    public static <T> Optional<T> ofNullable(T value) {\n        return value == null ? empty() : of(value);\n    }\n    \n    public static<T> Optional<T> empty() {\n        @SuppressWarnings(\"unchecked\")\n        Optional<T> t = (Optional<T>) EMPTY;\n        return t;\n    }\n\n```\n\n获取值\n\n```Java\n   public T get() {\n        if (value == null) {\n            throw new NoSuchElementException(\"No value present\");\n        }\n        return value;\n    }\n```\n\nifPresent 方法另一种形式可以接受一个函数，如存在可选值，它会将该值传递给函数，否则不进行任何操作。\n\n```Java\n    public boolean isPresent() {\n        return value != null;\n    }\n    \n    public void ifPresent(Consumer<? super T> consumer) {\n        if (value != null)\n            consumer.accept(value);\n    }\n```\n\n####\tflatMap\n\n组合可选值函数\n\n```Java\npublic class MyMath {\n\n    public static Optional<Double> inverse(Double x) {\n        return x == 0 ? Optional.empty() : Optional.of(1 / x);\n    }\n\n    public static Optional<Double> squareRoot(Double x) {\n        return x < 0 ? Optional.empty() : Optional.of(Math.sqrt(x));\n    }\n}\n\n\n\n    public static void main(String[] args) {\n        Double x = 1d;\n\n        Optional<Double> result = MyMath.inverse(x).flatMap(MyMath::squareRoot);\n\n        Optional<Double> res2 = Optional.of(-4d).flatMap(MyMath::inverse).flatMap(MyMath::squareRoot);\n    }\n```\n\n###\t聚合\n\n元素求和\n\n```Java\npublic class Sample2 {\n\n    public static void main(String[] args) {\n        List<Integer> intList = new ArrayList<>();\n        for (int i = 0; i < 100; i++) {\n            intList.add(i);\n        }\n        Stream<Integer> stream = intList.stream();\n\n        Optional<Integer> sum = stream.reduce(Integer::sum);\n\n        System.out.println(sum.get());\n    }\n}\n```\n\n字符串长度求和\n\n```Java\npublic class Sample7 {\n\n    public static void main(String[] args) {\n        List<String> list = letters();\n        \n        Stream<String> stream = list.stream();\n        int res = stream.reduce(0, (total, word) -> total + word.length(), (t1, t2) -> t1 + t2);\n        System.out.println(res);\n\n        int res2 = stream.mapToInt(String::length).sum();\n        System.out.println(res2);\n    }\n\n    private static List<String> letters() {\n        List<String> list = new ArrayList<>();\n        list.add(\"Tommy\");\n        list.add(\"Focus\");\n        list.add(\"Tim\");\n        list.add(\"Jack\");\n        return list;\n    }\n}\n```\n\n###\t收集结果\n\n处理完流之后，收集结果\n\n```Java\npublic class Sample8 {\n\n    public static void main(String[] args) {\n        String[] words = new String[]{\"Tommy\", \"Focus\", \"Tim\", \"Jack\"};\n        Stream<String> stream = Arrays.stream(words);\n        HashSet<String> hashSet = stream.collect(HashSet::new, HashSet::add, HashSet::addAll);\n\n        List<String> list = Arrays.stream(words).collect(Collectors.toList());\n        Set<String> set = Arrays.stream(words).collect(Collectors.toSet());\n\n        TreeSet<String> treeSet = Arrays.stream(words).collect(Collectors.toCollection(TreeSet::new));\n\n        String strJoin = Arrays.stream(words).collect(Collectors.joining());\n\n        String result = Arrays.stream(words).collect(Collectors.joining(\",\"));\n\n        String result2 = Arrays.stream(words).map(Object::toString).collect(Collectors.joining(\",\"));\n\n\n        IntSummaryStatistics summary = Arrays.stream(words).collect(Collectors.summarizingInt(String::length));\n        double averagwLength = summary.getAverage();\n        double maxLength = summary.getMax();\n        double min = summary.getMin();\n    }\n}\n```\n\n###\t收集结果到 Map\n\n```Java\npublic class Sample9 {\n\n    public static void main(String[] args) {\n        User user1 = new User(1, \"Focus\");\n        User user2 = new User(2, \"Tommy\");\n        User user3 = new User(3, \"Jack\");\n\n        List<User> list = Arrays.asList(user1, user2, user3);\n\n        s1(list);\n        s2(list);\n        s3(list);\n    }\n\n    /**\n     * key重复会抛异常\n     **/\n    public static void s1(List<User> list) {\n        Map<Integer, String> idToName = list.stream().collect(Collectors.toMap(User::getId, User::getName));\n        Map<Integer, User> idToUser = list.stream().collect(Collectors.toMap(User::getId, Function.identity()));\n    }\n\n    public static void s2(List<User> list) {\n        User user = new User(1, \"Billy\");\n\n        List<User> userList = new ArrayList<>(list);\n        userList.add(user);\n\n        Map<Integer, Set<String>> idToName = userList.stream().collect(Collectors.toMap(\n                u -> u.getId(),\n                u -> Collections.singleton(u.getName()),\n                (a, b) -> {\n                    Set<String> r = new HashSet<String>(a);\n                    r.addAll(b);\n                    return r;\n                }));\n    }\n\n    public static void s3(List<User> list) {\n        Map<Integer, User> idToUser = list.stream().collect(\n                Collectors.toMap(\n                        User::getId,\n                        Function.identity(),\n                        (existingVal, newVal) -> {\n                            throw new IllegalStateException();\n                        },\n                        TreeMap::new\n                )\n        );\n    }\n}\n```\n\n###\t分组、分片\n\n对流处理结果分组、分片。\n\n```Java\npublic class User {\n\n    public User(Integer id, String name) {\n        this.id = id;\n        this.name = name;\n        this.email = name + \"@qiyi.com\";\n    }\n\n    public User(Integer id, String name, Integer sex) {\n        this(id, name);\n        this.sex = sex;\n    }\n\n    private Integer id;\n\n    private String name;\n\n    private String email;\n\n    private Integer sex;\n    \n    ....\n}\n```\n\n```Java\npublic class Sample10 {\n\n    public static void main(String[] args) {\n        User user1 = new User(1, \"Focus\", 1);\n        User user2 = new User(2, \"Tommy\", 1);\n        User user3 = new User(3, \"Jack\", 1);\n\n        User user4 = new User(4, \"Rose\", 2);\n        User user5 = new User(5, \"Jane\", 2);\n\n        List<User> list = Arrays.asList(user1, user2, user3, user4, user5);\n\n        /** 按性别分组**/\n        Map<Integer, List<User>> map = list.stream().collect(Collectors.groupingBy(User::getSex));\n\n        /** 按ID小于等于3分组**/\n        Map<Boolean, List<User>> map1 = list.stream().collect(Collectors.partitioningBy(e -> e.getId() <= 3));\n\n        /** 按性别分组 收集为set**/\n        Map<Integer, Set<User>> map2 = list.stream().collect(Collectors.groupingBy(User::getSex, Collectors.toSet()));\n    }\n}\n```\n\nJava8 还提供了其他收集器，用来对分组后元素进行 downstream 处理：\n\n*\tcounting 返回收集元素总个数\n*\tsumming (Int|Long|Double) 接受一个函数作为参数，将该函数应用到downstream元素中，求和\n* \tmaxBy、minBy 接受一个比较器，生成 downstream 元素中最大值和最小值\n*  \tmapping 方法将一个函数应用到 downstream 结果上，并且需要另一个收集器来处理结果\n*\t....\n\n###\t原始类型流\n\n将每个整数包装成响应对象很低效，Stream API 提供了 IntStream、LongStream 和 DoubleStream 等类型，专门用来直接存储原始类型值。如果要存 short、char、byte 和 boolean 类型，使用 IntStream；如果要存储 float 类型，使用 DoubleStream。设计者认为，不需要为其他5种原始类型都添加对应的专门类型。\n\n将原始类型流转换为一个对象流，可以使用 boxed 方法:\n\n```Java\n\tStream<Integer> integers = IntStream.range(0, 100).boxed();\n```\n\n原始类型流方法与对象流上调用类似，但有以下几点显著区别：\n\n*\ttoArray 返回原始类型数组。\n* \t产生 Optional 结果的方法返回一个 OptionalInt、OptionalLong 或者 OptionalDouble 类型，这些与 Optional 类似，但没有 get 方法，而是对应的 getAsInt、getAsLong 和 getAsDouble。\n*\t方法 sum、average、max 和 min 会返回总和、平均值、最大值和最小值。对象流中没有定义这些方法。\n* \tsummaryStatistics 方法产生一个 IntSummaryStatistics、LongSummaryStatistics 或者 DoubleSummaryStatistics 对象。  \n\n###\t并行流\n\n流使得并行计算变得容易。处理过程几乎全自动。但必须遵守一些约定。\n\n*\t创建并行流， Collection.parellelStream, parallel 方法。\n* \t确保传递给并行流操作的函数都是线程安全的。\n\n有序并不妨碍并行。例如，计算 stream.map(fun) 时，流可以被分片为 n 段，每一段都被并发处理，然后按顺序组合结果。\n\n执行一个流操作时，不会修改流底层的集合（即使修改是线程安全）。流不会收集它自己的数据----这些数据总是存在于另一个集合中。如果你想修改原有集合，那么就无法定义流操作的输出。JDK 文档称这种需求为“不干扰”。\n\n```Java\n\t//正确\n\tList<String> wordList = ...;\n\tStream<String> words = wordList.stream();\n\twordList.add(\"END\");\n\tlong n = words.distinct().count();\n```\n\n```Java\n\t//错误\n\tStream<String> words = wordList.stream();\n\twords.forEach(s -> if (s.length() < 12) wordList.remove(s));\n```","source":"_posts/Java Web/Java8新特性 -- StreamAPI.md","raw":"---\ntitle: Java8 -- StreamAPI\ndate: 2016-12-19\ncategories: Java Web\ntags: \n- Java8\n---\n\n#\tJava8新特性 -- StreamAPI\n\nStream 是 Java 8 中处理集合的关键抽象概念，它可以指定你希望对集合进行的操作，但是将执行操作的时间交给具体实现来决定。\n\n*\t迭代器遍历策略特定，不能并发执行。\n*\t集合、数组、生成器、迭代器均和创建 Stream。\n* \t过滤器 filter 选择元素，map 改变元素。\n*  \t改变 Stream 的操作包括 limit、distinct 和 sorted。\n*\t从Stream中获得结果，使用 reduction 操作符，例如 count、max、min、findFirst 或 findAny。其中一些方法返回 Optional 值。\n* \tOptional 类型为了安全地替代使用 null 值，需要借助 ifPresent 和 orElse 方法。\n*  \tCollectors 类的 groupingBy 和 partitioningBy 方法允许你对 Stream 中内容分组。\n*\tJava 8 对原始类型 int、long 和 double 提供专门的 Stream。\n* \t并行 Stream，放弃排序约束。\n\n##\t从迭代器到 Stream 操作\n\n处理集合时，通常会迭代所有元素并对其中的每一个进行处理。\n\n```Java\npublic class Sample1 {\n\n    public static void main(String[] args) {\n        List<String> list = letters();\n        list.forEach(System.out::println);\n\n        countWord(list);\n        filterCountWord(list);\n        parallelFilterCountWord(list);\n\n    }\n\n    private static List<String> letters() {\n        List<String> list = new ArrayList<>();\n        list.add(\"Tommy\");\n        list.add(\"Focus\");\n        list.add(\"Tim\");\n        list.add(\"Jack\");\n        return list;\n    }\n\n    private static void countWord(List<String> list) {\n        int count = 0;\n        for (String str : list) {\n            if (str.length() > 4)\n                count++;\n        }\n        System.out.println(\"countWord: \" + count);\n    }\n\n    private static void filterCountWord(List<String> list) {\n        long count = list.stream().filter(w -> w.length() > 4).count();\n        System.out.println(\"filterCountWord: \" + count);\n    }\n\n    private static void parallelFilterCountWord(List<String> list) {\n        long count = list.parallelStream().filter(w -> w.length() > 4).count();\n        System.out.println(\"parallelFilterCountWord: \" + count);\n    }\n\n}\n```\n\n1.\tStream 不存储元素。元素可能被存储在底层的集合中，或根据需要产生出来。\n2. \tStream 操作符不改变源对象。它们返回一个持有结果的新 Stream。\n3. \tStream 操作符可能延迟执行。\n\n##\t创建 Stream\n\n###\tAPI\n\n```Java\n    /**\n     * Returns a sequential {@code Stream} containing a single element.\n     *\n     * @param t the single element\n     * @param <T> the type of stream elements\n     * @return a singleton sequential stream\n     */\n    public static<T> Stream<T> of(T t) {\n        return StreamSupport.stream(new Streams.StreamBuilderImpl<>(t), false);\n    }\n```\n\n```Java\n    /**\n     * Returns a sequential ordered stream whose elements are the specified values.\n     *\n     * @param <T> the type of stream elements\n     * @param values the elements of the new stream\n     * @return the new stream\n     */\n    @SafeVarargs\n    @SuppressWarnings(\"varargs\") // Creating a stream from an array is safe\n    public static<T> Stream<T> of(T... values) {\n        return Arrays.stream(values);\n    }\n```\n\ngenerate 和 iterate 是两个用来创建无限 Stream 的静态方法。\n\n```Java\npublic class Sample2 {\n\n    public static void main(String[] args) {\n        Stream<String> echos = Stream.generate(() -> \"Echo\");\n        Stream<Double> randoms = Stream.generate(Math::random);\n        Stream<BigInteger> integers = Stream.iterate(BigInteger.ZERO, n -> n.add(BigInteger.ONE));\n\n        Object[] powers = Stream.iterate(1.0, p -> p * 2).peek(e -> System.out.println(\"Fetching \" + e)).limit(20).toArray();\n\n        System.out.println(\"well done ...\");\n\n    }\n}\n\n```\n\n###\tfilter、map 和 flatMap\n\n流转换指从一个流中读取数据，并将转换后的数据写入另一个流。\n\n```Java\npublic class Sample3 {\n\n    public static void main(String[] args) {\n        List<String> list = letters();\n        Stream<String> lowerString = list.stream().map(String::toLowerCase);\n        lowerString.forEach(System.out::println);\n\n        Stream<Character> characterStream = list.stream().flatMap(Sample3::characterStream);\n        characterStream.forEach(System.out::println);\n    }\n\n    private static List<String> letters() {\n        List<String> list = new ArrayList<>();\n        list.add(\"Tommy\");\n        list.add(\"Focus\");\n        list.add(\"Tim\");\n        list.add(\"Jack\");\n        return list;\n    }\n\n    public static Stream<Character> characterStream(String s) {\n        List<Character> result = new ArrayList<>();\n        for (char c : s.toCharArray()) {\n            result.add(c);\n        }\n        return result.stream();\n    }\n}\n```\n\n1.\tmap 方法，会对每个元素应用一个函数，将返回值收集到一个新的流中。\n2. \tflatMap 方法，完成从 T 到 G\\<U> 的 f 函数和从 U 到 G\\<U> 的 g 方法，这是 monads 理论的一个关键概念。\n\n###\t提取子流和组合流\n\nStream.limit(n) 返回一个 n 个元素的新流（如果原始流的长度小于n，则返回原始的流）。\n\n```Java\npublic class Sample5 {\n\n    public static void main(String[] args) {\n        unique();\n\n        sort();\n\n    }\n\n    public static void unique(){\n        Stream<String> uniqueWords = Stream.of(\"zhuxh\", \"zhuxh\", \"zhuxh\", \"focus\").distinct();\n        uniqueWords.forEach(System.out::println);\n    }\n\n    public static void sort(){\n        List<String> list = letters();\n        Stream<String> stringStream = list.stream();\n\n        Stream<String> longestFirst = stringStream.sorted(Comparator.comparing(String::length).reversed());\n        longestFirst.forEach(System.out::println);\n\n    }\n\n    private static List<String> letters() {\n        List<String> list = new ArrayList<>();\n        list.add(\"Tommy\");\n        list.add(\"Focus\");\n        list.add(\"Tim\");\n        list.add(\"Jack\");\n        return list;\n    }\n}\n```\n\n###\t简单的聚合方法\n\n聚合方法都是*终止操作*，当一个流应用了终止操作后，不能再应用其他操作。\n\n聚合方法，count、max、min，返回一个 Optional<T> 值，可能封装返回值，也可能没有返回值。\n\n```Java\npublic class Sample6 {\n\n    public static void main(String[] args) {\n        Stream<String> stringStream = letters().stream();\n\n        Optional<String> largestString = stringStream.max(String::compareToIgnoreCase);\n\n        if(largestString.isPresent()){\n            System.out.println(largestString.get());\n        }\n    }\n\n    private static List<String> letters() {\n        List<String> list = new ArrayList<>();\n        list.add(\"Tommy\");\n        list.add(\"Focus\");\n        list.add(\"Tim\");\n        list.add(\"Jack\");\n        return list;\n    }\n\n}\n```\n\n类似的API还有 findFirst(), findAny()。\n\n还提供了 anyMatch(), allMatch 和 noneMatch()，这些方法总是会检查整个流，但仍可以通过并行执行来提高速度。\n\n###\tOptional 类型\n\njava.util.Optional\\<T\\>\n\nOptional\\<T\\> 对象是对一个 T 类型对象的封装，或者表示不是任何对象。它比一般指向 T 类型引用更安全，不会反悔null--前提是你正确使用。\n\n创建 Optional 对象\n\n```Java\n    public static <T> Optional<T> of(T value) {\n        return new Optional<>(value);\n    }\n    \n    public static <T> Optional<T> ofNullable(T value) {\n        return value == null ? empty() : of(value);\n    }\n    \n    public static<T> Optional<T> empty() {\n        @SuppressWarnings(\"unchecked\")\n        Optional<T> t = (Optional<T>) EMPTY;\n        return t;\n    }\n\n```\n\n获取值\n\n```Java\n   public T get() {\n        if (value == null) {\n            throw new NoSuchElementException(\"No value present\");\n        }\n        return value;\n    }\n```\n\nifPresent 方法另一种形式可以接受一个函数，如存在可选值，它会将该值传递给函数，否则不进行任何操作。\n\n```Java\n    public boolean isPresent() {\n        return value != null;\n    }\n    \n    public void ifPresent(Consumer<? super T> consumer) {\n        if (value != null)\n            consumer.accept(value);\n    }\n```\n\n####\tflatMap\n\n组合可选值函数\n\n```Java\npublic class MyMath {\n\n    public static Optional<Double> inverse(Double x) {\n        return x == 0 ? Optional.empty() : Optional.of(1 / x);\n    }\n\n    public static Optional<Double> squareRoot(Double x) {\n        return x < 0 ? Optional.empty() : Optional.of(Math.sqrt(x));\n    }\n}\n\n\n\n    public static void main(String[] args) {\n        Double x = 1d;\n\n        Optional<Double> result = MyMath.inverse(x).flatMap(MyMath::squareRoot);\n\n        Optional<Double> res2 = Optional.of(-4d).flatMap(MyMath::inverse).flatMap(MyMath::squareRoot);\n    }\n```\n\n###\t聚合\n\n元素求和\n\n```Java\npublic class Sample2 {\n\n    public static void main(String[] args) {\n        List<Integer> intList = new ArrayList<>();\n        for (int i = 0; i < 100; i++) {\n            intList.add(i);\n        }\n        Stream<Integer> stream = intList.stream();\n\n        Optional<Integer> sum = stream.reduce(Integer::sum);\n\n        System.out.println(sum.get());\n    }\n}\n```\n\n字符串长度求和\n\n```Java\npublic class Sample7 {\n\n    public static void main(String[] args) {\n        List<String> list = letters();\n        \n        Stream<String> stream = list.stream();\n        int res = stream.reduce(0, (total, word) -> total + word.length(), (t1, t2) -> t1 + t2);\n        System.out.println(res);\n\n        int res2 = stream.mapToInt(String::length).sum();\n        System.out.println(res2);\n    }\n\n    private static List<String> letters() {\n        List<String> list = new ArrayList<>();\n        list.add(\"Tommy\");\n        list.add(\"Focus\");\n        list.add(\"Tim\");\n        list.add(\"Jack\");\n        return list;\n    }\n}\n```\n\n###\t收集结果\n\n处理完流之后，收集结果\n\n```Java\npublic class Sample8 {\n\n    public static void main(String[] args) {\n        String[] words = new String[]{\"Tommy\", \"Focus\", \"Tim\", \"Jack\"};\n        Stream<String> stream = Arrays.stream(words);\n        HashSet<String> hashSet = stream.collect(HashSet::new, HashSet::add, HashSet::addAll);\n\n        List<String> list = Arrays.stream(words).collect(Collectors.toList());\n        Set<String> set = Arrays.stream(words).collect(Collectors.toSet());\n\n        TreeSet<String> treeSet = Arrays.stream(words).collect(Collectors.toCollection(TreeSet::new));\n\n        String strJoin = Arrays.stream(words).collect(Collectors.joining());\n\n        String result = Arrays.stream(words).collect(Collectors.joining(\",\"));\n\n        String result2 = Arrays.stream(words).map(Object::toString).collect(Collectors.joining(\",\"));\n\n\n        IntSummaryStatistics summary = Arrays.stream(words).collect(Collectors.summarizingInt(String::length));\n        double averagwLength = summary.getAverage();\n        double maxLength = summary.getMax();\n        double min = summary.getMin();\n    }\n}\n```\n\n###\t收集结果到 Map\n\n```Java\npublic class Sample9 {\n\n    public static void main(String[] args) {\n        User user1 = new User(1, \"Focus\");\n        User user2 = new User(2, \"Tommy\");\n        User user3 = new User(3, \"Jack\");\n\n        List<User> list = Arrays.asList(user1, user2, user3);\n\n        s1(list);\n        s2(list);\n        s3(list);\n    }\n\n    /**\n     * key重复会抛异常\n     **/\n    public static void s1(List<User> list) {\n        Map<Integer, String> idToName = list.stream().collect(Collectors.toMap(User::getId, User::getName));\n        Map<Integer, User> idToUser = list.stream().collect(Collectors.toMap(User::getId, Function.identity()));\n    }\n\n    public static void s2(List<User> list) {\n        User user = new User(1, \"Billy\");\n\n        List<User> userList = new ArrayList<>(list);\n        userList.add(user);\n\n        Map<Integer, Set<String>> idToName = userList.stream().collect(Collectors.toMap(\n                u -> u.getId(),\n                u -> Collections.singleton(u.getName()),\n                (a, b) -> {\n                    Set<String> r = new HashSet<String>(a);\n                    r.addAll(b);\n                    return r;\n                }));\n    }\n\n    public static void s3(List<User> list) {\n        Map<Integer, User> idToUser = list.stream().collect(\n                Collectors.toMap(\n                        User::getId,\n                        Function.identity(),\n                        (existingVal, newVal) -> {\n                            throw new IllegalStateException();\n                        },\n                        TreeMap::new\n                )\n        );\n    }\n}\n```\n\n###\t分组、分片\n\n对流处理结果分组、分片。\n\n```Java\npublic class User {\n\n    public User(Integer id, String name) {\n        this.id = id;\n        this.name = name;\n        this.email = name + \"@qiyi.com\";\n    }\n\n    public User(Integer id, String name, Integer sex) {\n        this(id, name);\n        this.sex = sex;\n    }\n\n    private Integer id;\n\n    private String name;\n\n    private String email;\n\n    private Integer sex;\n    \n    ....\n}\n```\n\n```Java\npublic class Sample10 {\n\n    public static void main(String[] args) {\n        User user1 = new User(1, \"Focus\", 1);\n        User user2 = new User(2, \"Tommy\", 1);\n        User user3 = new User(3, \"Jack\", 1);\n\n        User user4 = new User(4, \"Rose\", 2);\n        User user5 = new User(5, \"Jane\", 2);\n\n        List<User> list = Arrays.asList(user1, user2, user3, user4, user5);\n\n        /** 按性别分组**/\n        Map<Integer, List<User>> map = list.stream().collect(Collectors.groupingBy(User::getSex));\n\n        /** 按ID小于等于3分组**/\n        Map<Boolean, List<User>> map1 = list.stream().collect(Collectors.partitioningBy(e -> e.getId() <= 3));\n\n        /** 按性别分组 收集为set**/\n        Map<Integer, Set<User>> map2 = list.stream().collect(Collectors.groupingBy(User::getSex, Collectors.toSet()));\n    }\n}\n```\n\nJava8 还提供了其他收集器，用来对分组后元素进行 downstream 处理：\n\n*\tcounting 返回收集元素总个数\n*\tsumming (Int|Long|Double) 接受一个函数作为参数，将该函数应用到downstream元素中，求和\n* \tmaxBy、minBy 接受一个比较器，生成 downstream 元素中最大值和最小值\n*  \tmapping 方法将一个函数应用到 downstream 结果上，并且需要另一个收集器来处理结果\n*\t....\n\n###\t原始类型流\n\n将每个整数包装成响应对象很低效，Stream API 提供了 IntStream、LongStream 和 DoubleStream 等类型，专门用来直接存储原始类型值。如果要存 short、char、byte 和 boolean 类型，使用 IntStream；如果要存储 float 类型，使用 DoubleStream。设计者认为，不需要为其他5种原始类型都添加对应的专门类型。\n\n将原始类型流转换为一个对象流，可以使用 boxed 方法:\n\n```Java\n\tStream<Integer> integers = IntStream.range(0, 100).boxed();\n```\n\n原始类型流方法与对象流上调用类似，但有以下几点显著区别：\n\n*\ttoArray 返回原始类型数组。\n* \t产生 Optional 结果的方法返回一个 OptionalInt、OptionalLong 或者 OptionalDouble 类型，这些与 Optional 类似，但没有 get 方法，而是对应的 getAsInt、getAsLong 和 getAsDouble。\n*\t方法 sum、average、max 和 min 会返回总和、平均值、最大值和最小值。对象流中没有定义这些方法。\n* \tsummaryStatistics 方法产生一个 IntSummaryStatistics、LongSummaryStatistics 或者 DoubleSummaryStatistics 对象。  \n\n###\t并行流\n\n流使得并行计算变得容易。处理过程几乎全自动。但必须遵守一些约定。\n\n*\t创建并行流， Collection.parellelStream, parallel 方法。\n* \t确保传递给并行流操作的函数都是线程安全的。\n\n有序并不妨碍并行。例如，计算 stream.map(fun) 时，流可以被分片为 n 段，每一段都被并发处理，然后按顺序组合结果。\n\n执行一个流操作时，不会修改流底层的集合（即使修改是线程安全）。流不会收集它自己的数据----这些数据总是存在于另一个集合中。如果你想修改原有集合，那么就无法定义流操作的输出。JDK 文档称这种需求为“不干扰”。\n\n```Java\n\t//正确\n\tList<String> wordList = ...;\n\tStream<String> words = wordList.stream();\n\twordList.add(\"END\");\n\tlong n = words.distinct().count();\n```\n\n```Java\n\t//错误\n\tStream<String> words = wordList.stream();\n\twords.forEach(s -> if (s.length() < 12) wordList.remove(s));\n```","slug":"Java Web/Java8新特性 -- StreamAPI","published":1,"updated":"2019-05-17T05:57:58.552Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1j8f2jq00307h9mkih52f72","content":"<h1 id=\"Java8新特性-–-StreamAPI\"><a href=\"#Java8新特性-–-StreamAPI\" class=\"headerlink\" title=\"Java8新特性 – StreamAPI\"></a>Java8新特性 – StreamAPI</h1><p>Stream 是 Java 8 中处理集合的关键抽象概念，它可以指定你希望对集合进行的操作，但是将执行操作的时间交给具体实现来决定。</p>\n<ul>\n<li>迭代器遍历策略特定，不能并发执行。</li>\n<li>集合、数组、生成器、迭代器均和创建 Stream。</li>\n<li>过滤器 filter 选择元素，map 改变元素。</li>\n<li>改变 Stream 的操作包括 limit、distinct 和 sorted。</li>\n<li>从Stream中获得结果，使用 reduction 操作符，例如 count、max、min、findFirst 或 findAny。其中一些方法返回 Optional 值。</li>\n<li>Optional 类型为了安全地替代使用 null 值，需要借助 ifPresent 和 orElse 方法。</li>\n<li>Collectors 类的 groupingBy 和 partitioningBy 方法允许你对 Stream 中内容分组。</li>\n<li>Java 8 对原始类型 int、long 和 double 提供专门的 Stream。</li>\n<li>并行 Stream，放弃排序约束。</li>\n</ul>\n<h2 id=\"从迭代器到-Stream-操作\"><a href=\"#从迭代器到-Stream-操作\" class=\"headerlink\" title=\"从迭代器到 Stream 操作\"></a>从迭代器到 Stream 操作</h2><p>处理集合时，通常会迭代所有元素并对其中的每一个进行处理。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sample1</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        List&lt;String&gt; list = letters();</span><br><span class=\"line\">        list.forEach(System.out::println);</span><br><span class=\"line\"></span><br><span class=\"line\">        countWord(list);</span><br><span class=\"line\">        filterCountWord(list);</span><br><span class=\"line\">        parallelFilterCountWord(list);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> List&lt;String&gt; <span class=\"title\">letters</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        List&lt;String&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        list.add(<span class=\"string\">\"Tommy\"</span>);</span><br><span class=\"line\">        list.add(<span class=\"string\">\"Focus\"</span>);</span><br><span class=\"line\">        list.add(<span class=\"string\">\"Tim\"</span>);</span><br><span class=\"line\">        list.add(<span class=\"string\">\"Jack\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> list;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">countWord</span><span class=\"params\">(List&lt;String&gt; list)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (String str : list) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (str.length() &gt; <span class=\"number\">4</span>)</span><br><span class=\"line\">                count++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"countWord: \"</span> + count);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">filterCountWord</span><span class=\"params\">(List&lt;String&gt; list)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> count = list.stream().filter(w -&gt; w.length() &gt; <span class=\"number\">4</span>).count();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"filterCountWord: \"</span> + count);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">parallelFilterCountWord</span><span class=\"params\">(List&lt;String&gt; list)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> count = list.parallelStream().filter(w -&gt; w.length() &gt; <span class=\"number\">4</span>).count();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"parallelFilterCountWord: \"</span> + count);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>Stream 不存储元素。元素可能被存储在底层的集合中，或根据需要产生出来。</li>\n<li>Stream 操作符不改变源对象。它们返回一个持有结果的新 Stream。</li>\n<li>Stream 操作符可能延迟执行。</li>\n</ol>\n<h2 id=\"创建-Stream\"><a href=\"#创建-Stream\" class=\"headerlink\" title=\"创建 Stream\"></a>创建 Stream</h2><h3 id=\"API\"><a href=\"#API\" class=\"headerlink\" title=\"API\"></a>API</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Returns a sequential &#123;<span class=\"doctag\">@code</span> Stream&#125; containing a single element.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> t the single element</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> &lt;T&gt; the type of stream elements</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> a singleton sequential stream</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span>&lt;T&gt; Stream&lt;T&gt; <span class=\"title\">of</span><span class=\"params\">(T t)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> StreamSupport.stream(<span class=\"keyword\">new</span> Streams.StreamBuilderImpl&lt;&gt;(t), <span class=\"keyword\">false</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Returns a sequential ordered stream whose elements are the specified values.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> &lt;T&gt; the type of stream elements</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> values the elements of the new stream</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> the new stream</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@SafeVarargs</span></span><br><span class=\"line\"><span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"varargs\"</span>) <span class=\"comment\">// Creating a stream from an array is safe</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span>&lt;T&gt; Stream&lt;T&gt; <span class=\"title\">of</span><span class=\"params\">(T... values)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Arrays.stream(values);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>generate 和 iterate 是两个用来创建无限 Stream 的静态方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sample2</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Stream&lt;String&gt; echos = Stream.generate(() -&gt; <span class=\"string\">\"Echo\"</span>);</span><br><span class=\"line\">        Stream&lt;Double&gt; randoms = Stream.generate(Math::random);</span><br><span class=\"line\">        Stream&lt;BigInteger&gt; integers = Stream.iterate(BigInteger.ZERO, n -&gt; n.add(BigInteger.ONE));</span><br><span class=\"line\"></span><br><span class=\"line\">        Object[] powers = Stream.iterate(<span class=\"number\">1.0</span>, p -&gt; p * <span class=\"number\">2</span>).peek(e -&gt; System.out.println(<span class=\"string\">\"Fetching \"</span> + e)).limit(<span class=\"number\">20</span>).toArray();</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"well done ...\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"filter、map-和-flatMap\"><a href=\"#filter、map-和-flatMap\" class=\"headerlink\" title=\"filter、map 和 flatMap\"></a>filter、map 和 flatMap</h3><p>流转换指从一个流中读取数据，并将转换后的数据写入另一个流。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sample3</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        List&lt;String&gt; list = letters();</span><br><span class=\"line\">        Stream&lt;String&gt; lowerString = list.stream().map(String::toLowerCase);</span><br><span class=\"line\">        lowerString.forEach(System.out::println);</span><br><span class=\"line\"></span><br><span class=\"line\">        Stream&lt;Character&gt; characterStream = list.stream().flatMap(Sample3::characterStream);</span><br><span class=\"line\">        characterStream.forEach(System.out::println);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> List&lt;String&gt; <span class=\"title\">letters</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        List&lt;String&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        list.add(<span class=\"string\">\"Tommy\"</span>);</span><br><span class=\"line\">        list.add(<span class=\"string\">\"Focus\"</span>);</span><br><span class=\"line\">        list.add(<span class=\"string\">\"Tim\"</span>);</span><br><span class=\"line\">        list.add(<span class=\"string\">\"Jack\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> list;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Stream&lt;Character&gt; <span class=\"title\">characterStream</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">        List&lt;Character&gt; result = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">char</span> c : s.toCharArray()) &#123;</span><br><span class=\"line\">            result.add(c);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result.stream();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>map 方法，会对每个元素应用一个函数，将返回值收集到一个新的流中。</li>\n<li>flatMap 方法，完成从 T 到 G\\<u> 的 f 函数和从 U 到 G\\<u> 的 g 方法，这是 monads 理论的一个关键概念。</u></u></li>\n</ol>\n<h3 id=\"提取子流和组合流\"><a href=\"#提取子流和组合流\" class=\"headerlink\" title=\"提取子流和组合流\"></a>提取子流和组合流</h3><p>Stream.limit(n) 返回一个 n 个元素的新流（如果原始流的长度小于n，则返回原始的流）。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sample5</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        unique();</span><br><span class=\"line\"></span><br><span class=\"line\">        sort();</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">unique</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        Stream&lt;String&gt; uniqueWords = Stream.of(<span class=\"string\">\"zhuxh\"</span>, <span class=\"string\">\"zhuxh\"</span>, <span class=\"string\">\"zhuxh\"</span>, <span class=\"string\">\"focus\"</span>).distinct();</span><br><span class=\"line\">        uniqueWords.forEach(System.out::println);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">sort</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        List&lt;String&gt; list = letters();</span><br><span class=\"line\">        Stream&lt;String&gt; stringStream = list.stream();</span><br><span class=\"line\"></span><br><span class=\"line\">        Stream&lt;String&gt; longestFirst = stringStream.sorted(Comparator.comparing(String::length).reversed());</span><br><span class=\"line\">        longestFirst.forEach(System.out::println);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> List&lt;String&gt; <span class=\"title\">letters</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        List&lt;String&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        list.add(<span class=\"string\">\"Tommy\"</span>);</span><br><span class=\"line\">        list.add(<span class=\"string\">\"Focus\"</span>);</span><br><span class=\"line\">        list.add(<span class=\"string\">\"Tim\"</span>);</span><br><span class=\"line\">        list.add(<span class=\"string\">\"Jack\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> list;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"简单的聚合方法\"><a href=\"#简单的聚合方法\" class=\"headerlink\" title=\"简单的聚合方法\"></a>简单的聚合方法</h3><p>聚合方法都是<em>终止操作</em>，当一个流应用了终止操作后，不能再应用其他操作。</p>\n<p>聚合方法，count、max、min，返回一个 Optional<t> 值，可能封装返回值，也可能没有返回值。</t></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sample6</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Stream&lt;String&gt; stringStream = letters().stream();</span><br><span class=\"line\"></span><br><span class=\"line\">        Optional&lt;String&gt; largestString = stringStream.max(String::compareToIgnoreCase);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(largestString.isPresent())&#123;</span><br><span class=\"line\">            System.out.println(largestString.get());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> List&lt;String&gt; <span class=\"title\">letters</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        List&lt;String&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        list.add(<span class=\"string\">\"Tommy\"</span>);</span><br><span class=\"line\">        list.add(<span class=\"string\">\"Focus\"</span>);</span><br><span class=\"line\">        list.add(<span class=\"string\">\"Tim\"</span>);</span><br><span class=\"line\">        list.add(<span class=\"string\">\"Jack\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> list;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>类似的API还有 findFirst(), findAny()。</p>\n<p>还提供了 anyMatch(), allMatch 和 noneMatch()，这些方法总是会检查整个流，但仍可以通过并行执行来提高速度。</p>\n<h3 id=\"Optional-类型\"><a href=\"#Optional-类型\" class=\"headerlink\" title=\"Optional 类型\"></a>Optional 类型</h3><p>java.util.Optional\\<t\\></t\\></p>\n<p>Optional\\<t\\> 对象是对一个 T 类型对象的封装，或者表示不是任何对象。它比一般指向 T 类型引用更安全，不会反悔null–前提是你正确使用。</t\\></p>\n<p>创建 Optional 对象</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; <span class=\"function\">Optional&lt;T&gt; <span class=\"title\">of</span><span class=\"params\">(T value)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Optional&lt;&gt;(value);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; <span class=\"function\">Optional&lt;T&gt; <span class=\"title\">ofNullable</span><span class=\"params\">(T value)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> value == <span class=\"keyword\">null</span> ? empty() : of(value);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span>&lt;T&gt; Optional&lt;T&gt; <span class=\"title\">empty</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"unchecked\"</span>)</span><br><span class=\"line\">    Optional&lt;T&gt; t = (Optional&lt;T&gt;) EMPTY;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> t;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>获取值</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">get</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">if</span> (value == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">         <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NoSuchElementException(<span class=\"string\">\"No value present\"</span>);</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     <span class=\"keyword\">return</span> value;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>ifPresent 方法另一种形式可以接受一个函数，如存在可选值，它会将该值传递给函数，否则不进行任何操作。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isPresent</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> value != <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">ifPresent</span><span class=\"params\">(Consumer&lt;? <span class=\"keyword\">super</span> T&gt; consumer)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (value != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        consumer.accept(value);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"flatMap\"><a href=\"#flatMap\" class=\"headerlink\" title=\"flatMap\"></a>flatMap</h4><p>组合可选值函数</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyMath</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Optional&lt;Double&gt; <span class=\"title\">inverse</span><span class=\"params\">(Double x)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> x == <span class=\"number\">0</span> ? Optional.empty() : Optional.of(<span class=\"number\">1</span> / x);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Optional&lt;Double&gt; <span class=\"title\">squareRoot</span><span class=\"params\">(Double x)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> x &lt; <span class=\"number\">0</span> ? Optional.empty() : Optional.of(Math.sqrt(x));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Double x = <span class=\"number\">1</span>d;</span><br><span class=\"line\"></span><br><span class=\"line\">        Optional&lt;Double&gt; result = MyMath.inverse(x).flatMap(MyMath::squareRoot);</span><br><span class=\"line\"></span><br><span class=\"line\">        Optional&lt;Double&gt; res2 = Optional.of(-<span class=\"number\">4</span>d).flatMap(MyMath::inverse).flatMap(MyMath::squareRoot);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"聚合\"><a href=\"#聚合\" class=\"headerlink\" title=\"聚合\"></a>聚合</h3><p>元素求和</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sample2</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        List&lt;Integer&gt; intList = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">100</span>; i++) &#123;</span><br><span class=\"line\">            intList.add(i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Stream&lt;Integer&gt; stream = intList.stream();</span><br><span class=\"line\"></span><br><span class=\"line\">        Optional&lt;Integer&gt; sum = stream.reduce(Integer::sum);</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(sum.get());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>字符串长度求和</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sample7</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        List&lt;String&gt; list = letters();</span><br><span class=\"line\">        </span><br><span class=\"line\">        Stream&lt;String&gt; stream = list.stream();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> res = stream.reduce(<span class=\"number\">0</span>, (total, word) -&gt; total + word.length(), (t1, t2) -&gt; t1 + t2);</span><br><span class=\"line\">        System.out.println(res);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> res2 = stream.mapToInt(String::length).sum();</span><br><span class=\"line\">        System.out.println(res2);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> List&lt;String&gt; <span class=\"title\">letters</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        List&lt;String&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        list.add(<span class=\"string\">\"Tommy\"</span>);</span><br><span class=\"line\">        list.add(<span class=\"string\">\"Focus\"</span>);</span><br><span class=\"line\">        list.add(<span class=\"string\">\"Tim\"</span>);</span><br><span class=\"line\">        list.add(<span class=\"string\">\"Jack\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> list;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"收集结果\"><a href=\"#收集结果\" class=\"headerlink\" title=\"收集结果\"></a>收集结果</h3><p>处理完流之后，收集结果</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sample8</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        String[] words = <span class=\"keyword\">new</span> String[]&#123;<span class=\"string\">\"Tommy\"</span>, <span class=\"string\">\"Focus\"</span>, <span class=\"string\">\"Tim\"</span>, <span class=\"string\">\"Jack\"</span>&#125;;</span><br><span class=\"line\">        Stream&lt;String&gt; stream = Arrays.stream(words);</span><br><span class=\"line\">        HashSet&lt;String&gt; hashSet = stream.collect(HashSet::<span class=\"keyword\">new</span>, HashSet::add, HashSet::addAll);</span><br><span class=\"line\"></span><br><span class=\"line\">        List&lt;String&gt; list = Arrays.stream(words).collect(Collectors.toList());</span><br><span class=\"line\">        Set&lt;String&gt; set = Arrays.stream(words).collect(Collectors.toSet());</span><br><span class=\"line\"></span><br><span class=\"line\">        TreeSet&lt;String&gt; treeSet = Arrays.stream(words).collect(Collectors.toCollection(TreeSet::<span class=\"keyword\">new</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">        String strJoin = Arrays.stream(words).collect(Collectors.joining());</span><br><span class=\"line\"></span><br><span class=\"line\">        String result = Arrays.stream(words).collect(Collectors.joining(<span class=\"string\">\",\"</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">        String result2 = Arrays.stream(words).map(Object::toString).collect(Collectors.joining(<span class=\"string\">\",\"</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        IntSummaryStatistics summary = Arrays.stream(words).collect(Collectors.summarizingInt(String::length));</span><br><span class=\"line\">        <span class=\"keyword\">double</span> averagwLength = summary.getAverage();</span><br><span class=\"line\">        <span class=\"keyword\">double</span> maxLength = summary.getMax();</span><br><span class=\"line\">        <span class=\"keyword\">double</span> min = summary.getMin();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"收集结果到-Map\"><a href=\"#收集结果到-Map\" class=\"headerlink\" title=\"收集结果到 Map\"></a>收集结果到 Map</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sample9</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        User user1 = <span class=\"keyword\">new</span> User(<span class=\"number\">1</span>, <span class=\"string\">\"Focus\"</span>);</span><br><span class=\"line\">        User user2 = <span class=\"keyword\">new</span> User(<span class=\"number\">2</span>, <span class=\"string\">\"Tommy\"</span>);</span><br><span class=\"line\">        User user3 = <span class=\"keyword\">new</span> User(<span class=\"number\">3</span>, <span class=\"string\">\"Jack\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        List&lt;User&gt; list = Arrays.asList(user1, user2, user3);</span><br><span class=\"line\"></span><br><span class=\"line\">        s1(list);</span><br><span class=\"line\">        s2(list);</span><br><span class=\"line\">        s3(list);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * key重复会抛异常</span></span><br><span class=\"line\"><span class=\"comment\">     **/</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">s1</span><span class=\"params\">(List&lt;User&gt; list)</span> </span>&#123;</span><br><span class=\"line\">        Map&lt;Integer, String&gt; idToName = list.stream().collect(Collectors.toMap(User::getId, User::getName));</span><br><span class=\"line\">        Map&lt;Integer, User&gt; idToUser = list.stream().collect(Collectors.toMap(User::getId, Function.identity()));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">s2</span><span class=\"params\">(List&lt;User&gt; list)</span> </span>&#123;</span><br><span class=\"line\">        User user = <span class=\"keyword\">new</span> User(<span class=\"number\">1</span>, <span class=\"string\">\"Billy\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        List&lt;User&gt; userList = <span class=\"keyword\">new</span> ArrayList&lt;&gt;(list);</span><br><span class=\"line\">        userList.add(user);</span><br><span class=\"line\"></span><br><span class=\"line\">        Map&lt;Integer, Set&lt;String&gt;&gt; idToName = userList.stream().collect(Collectors.toMap(</span><br><span class=\"line\">                u -&gt; u.getId(),</span><br><span class=\"line\">                u -&gt; Collections.singleton(u.getName()),</span><br><span class=\"line\">                (a, b) -&gt; &#123;</span><br><span class=\"line\">                    Set&lt;String&gt; r = <span class=\"keyword\">new</span> HashSet&lt;String&gt;(a);</span><br><span class=\"line\">                    r.addAll(b);</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> r;</span><br><span class=\"line\">                &#125;));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">s3</span><span class=\"params\">(List&lt;User&gt; list)</span> </span>&#123;</span><br><span class=\"line\">        Map&lt;Integer, User&gt; idToUser = list.stream().collect(</span><br><span class=\"line\">                Collectors.toMap(</span><br><span class=\"line\">                        User::getId,</span><br><span class=\"line\">                        Function.identity(),</span><br><span class=\"line\">                        (existingVal, newVal) -&gt; &#123;</span><br><span class=\"line\">                            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException();</span><br><span class=\"line\">                        &#125;,</span><br><span class=\"line\">                        TreeMap::<span class=\"keyword\">new</span></span><br><span class=\"line\">                )</span><br><span class=\"line\">        );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"分组、分片\"><a href=\"#分组、分片\" class=\"headerlink\" title=\"分组、分片\"></a>分组、分片</h3><p>对流处理结果分组、分片。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">User</span><span class=\"params\">(Integer id, String name)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.id = id;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.email = name + <span class=\"string\">\"@qiyi.com\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">User</span><span class=\"params\">(Integer id, String name, Integer sex)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>(id, name);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.sex = sex;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Integer id;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String email;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Integer sex;</span><br><span class=\"line\">    </span><br><span class=\"line\">    ....</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sample10</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        User user1 = <span class=\"keyword\">new</span> User(<span class=\"number\">1</span>, <span class=\"string\">\"Focus\"</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">        User user2 = <span class=\"keyword\">new</span> User(<span class=\"number\">2</span>, <span class=\"string\">\"Tommy\"</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">        User user3 = <span class=\"keyword\">new</span> User(<span class=\"number\">3</span>, <span class=\"string\">\"Jack\"</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        User user4 = <span class=\"keyword\">new</span> User(<span class=\"number\">4</span>, <span class=\"string\">\"Rose\"</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">        User user5 = <span class=\"keyword\">new</span> User(<span class=\"number\">5</span>, <span class=\"string\">\"Jane\"</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        List&lt;User&gt; list = Arrays.asList(user1, user2, user3, user4, user5);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/** 按性别分组**/</span></span><br><span class=\"line\">        Map&lt;Integer, List&lt;User&gt;&gt; map = list.stream().collect(Collectors.groupingBy(User::getSex));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/** 按ID小于等于3分组**/</span></span><br><span class=\"line\">        Map&lt;Boolean, List&lt;User&gt;&gt; map1 = list.stream().collect(Collectors.partitioningBy(e -&gt; e.getId() &lt;= <span class=\"number\">3</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/** 按性别分组 收集为set**/</span></span><br><span class=\"line\">        Map&lt;Integer, Set&lt;User&gt;&gt; map2 = list.stream().collect(Collectors.groupingBy(User::getSex, Collectors.toSet()));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Java8 还提供了其他收集器，用来对分组后元素进行 downstream 处理：</p>\n<ul>\n<li>counting 返回收集元素总个数</li>\n<li>summing (Int|Long|Double) 接受一个函数作为参数，将该函数应用到downstream元素中，求和</li>\n<li>maxBy、minBy 接受一个比较器，生成 downstream 元素中最大值和最小值</li>\n<li>mapping 方法将一个函数应用到 downstream 结果上，并且需要另一个收集器来处理结果</li>\n<li>….</li>\n</ul>\n<h3 id=\"原始类型流\"><a href=\"#原始类型流\" class=\"headerlink\" title=\"原始类型流\"></a>原始类型流</h3><p>将每个整数包装成响应对象很低效，Stream API 提供了 IntStream、LongStream 和 DoubleStream 等类型，专门用来直接存储原始类型值。如果要存 short、char、byte 和 boolean 类型，使用 IntStream；如果要存储 float 类型，使用 DoubleStream。设计者认为，不需要为其他5种原始类型都添加对应的专门类型。</p>\n<p>将原始类型流转换为一个对象流，可以使用 boxed 方法:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Stream&lt;Integer&gt; integers = IntStream.range(<span class=\"number\">0</span>, <span class=\"number\">100</span>).boxed();</span><br></pre></td></tr></table></figure>\n<p>原始类型流方法与对象流上调用类似，但有以下几点显著区别：</p>\n<ul>\n<li>toArray 返回原始类型数组。</li>\n<li>产生 Optional 结果的方法返回一个 OptionalInt、OptionalLong 或者 OptionalDouble 类型，这些与 Optional 类似，但没有 get 方法，而是对应的 getAsInt、getAsLong 和 getAsDouble。</li>\n<li>方法 sum、average、max 和 min 会返回总和、平均值、最大值和最小值。对象流中没有定义这些方法。</li>\n<li>summaryStatistics 方法产生一个 IntSummaryStatistics、LongSummaryStatistics 或者 DoubleSummaryStatistics 对象。  </li>\n</ul>\n<h3 id=\"并行流\"><a href=\"#并行流\" class=\"headerlink\" title=\"并行流\"></a>并行流</h3><p>流使得并行计算变得容易。处理过程几乎全自动。但必须遵守一些约定。</p>\n<ul>\n<li>创建并行流， Collection.parellelStream, parallel 方法。</li>\n<li>确保传递给并行流操作的函数都是线程安全的。</li>\n</ul>\n<p>有序并不妨碍并行。例如，计算 stream.map(fun) 时，流可以被分片为 n 段，每一段都被并发处理，然后按顺序组合结果。</p>\n<p>执行一个流操作时，不会修改流底层的集合（即使修改是线程安全）。流不会收集它自己的数据—-这些数据总是存在于另一个集合中。如果你想修改原有集合，那么就无法定义流操作的输出。JDK 文档称这种需求为“不干扰”。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//正确</span></span><br><span class=\"line\">List&lt;String&gt; wordList = ...;</span><br><span class=\"line\">Stream&lt;String&gt; words = wordList.stream();</span><br><span class=\"line\">wordList.add(<span class=\"string\">\"END\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">long</span> n = words.distinct().count();</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//错误</span></span><br><span class=\"line\">Stream&lt;String&gt; words = wordList.stream();</span><br><span class=\"line\">words.forEach(s -&gt; <span class=\"keyword\">if</span> (s.length() &lt; <span class=\"number\">12</span>) wordList.remove(s));</span><br></pre></td></tr></table></figure>","excerpt":"","more":"<h1 id=\"Java8新特性-–-StreamAPI\"><a href=\"#Java8新特性-–-StreamAPI\" class=\"headerlink\" title=\"Java8新特性 – StreamAPI\"></a>Java8新特性 – StreamAPI</h1><p>Stream 是 Java 8 中处理集合的关键抽象概念，它可以指定你希望对集合进行的操作，但是将执行操作的时间交给具体实现来决定。</p>\n<ul>\n<li>迭代器遍历策略特定，不能并发执行。</li>\n<li>集合、数组、生成器、迭代器均和创建 Stream。</li>\n<li>过滤器 filter 选择元素，map 改变元素。</li>\n<li>改变 Stream 的操作包括 limit、distinct 和 sorted。</li>\n<li>从Stream中获得结果，使用 reduction 操作符，例如 count、max、min、findFirst 或 findAny。其中一些方法返回 Optional 值。</li>\n<li>Optional 类型为了安全地替代使用 null 值，需要借助 ifPresent 和 orElse 方法。</li>\n<li>Collectors 类的 groupingBy 和 partitioningBy 方法允许你对 Stream 中内容分组。</li>\n<li>Java 8 对原始类型 int、long 和 double 提供专门的 Stream。</li>\n<li>并行 Stream，放弃排序约束。</li>\n</ul>\n<h2 id=\"从迭代器到-Stream-操作\"><a href=\"#从迭代器到-Stream-操作\" class=\"headerlink\" title=\"从迭代器到 Stream 操作\"></a>从迭代器到 Stream 操作</h2><p>处理集合时，通常会迭代所有元素并对其中的每一个进行处理。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sample1</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        List&lt;String&gt; list = letters();</span><br><span class=\"line\">        list.forEach(System.out::println);</span><br><span class=\"line\"></span><br><span class=\"line\">        countWord(list);</span><br><span class=\"line\">        filterCountWord(list);</span><br><span class=\"line\">        parallelFilterCountWord(list);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> List&lt;String&gt; <span class=\"title\">letters</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        List&lt;String&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        list.add(<span class=\"string\">\"Tommy\"</span>);</span><br><span class=\"line\">        list.add(<span class=\"string\">\"Focus\"</span>);</span><br><span class=\"line\">        list.add(<span class=\"string\">\"Tim\"</span>);</span><br><span class=\"line\">        list.add(<span class=\"string\">\"Jack\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> list;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">countWord</span><span class=\"params\">(List&lt;String&gt; list)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (String str : list) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (str.length() &gt; <span class=\"number\">4</span>)</span><br><span class=\"line\">                count++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"countWord: \"</span> + count);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">filterCountWord</span><span class=\"params\">(List&lt;String&gt; list)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> count = list.stream().filter(w -&gt; w.length() &gt; <span class=\"number\">4</span>).count();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"filterCountWord: \"</span> + count);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">parallelFilterCountWord</span><span class=\"params\">(List&lt;String&gt; list)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> count = list.parallelStream().filter(w -&gt; w.length() &gt; <span class=\"number\">4</span>).count();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"parallelFilterCountWord: \"</span> + count);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>Stream 不存储元素。元素可能被存储在底层的集合中，或根据需要产生出来。</li>\n<li>Stream 操作符不改变源对象。它们返回一个持有结果的新 Stream。</li>\n<li>Stream 操作符可能延迟执行。</li>\n</ol>\n<h2 id=\"创建-Stream\"><a href=\"#创建-Stream\" class=\"headerlink\" title=\"创建 Stream\"></a>创建 Stream</h2><h3 id=\"API\"><a href=\"#API\" class=\"headerlink\" title=\"API\"></a>API</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Returns a sequential &#123;<span class=\"doctag\">@code</span> Stream&#125; containing a single element.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> t the single element</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> &lt;T&gt; the type of stream elements</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> a singleton sequential stream</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span>&lt;T&gt; Stream&lt;T&gt; <span class=\"title\">of</span><span class=\"params\">(T t)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> StreamSupport.stream(<span class=\"keyword\">new</span> Streams.StreamBuilderImpl&lt;&gt;(t), <span class=\"keyword\">false</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Returns a sequential ordered stream whose elements are the specified values.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> &lt;T&gt; the type of stream elements</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> values the elements of the new stream</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> the new stream</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@SafeVarargs</span></span><br><span class=\"line\"><span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"varargs\"</span>) <span class=\"comment\">// Creating a stream from an array is safe</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span>&lt;T&gt; Stream&lt;T&gt; <span class=\"title\">of</span><span class=\"params\">(T... values)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Arrays.stream(values);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>generate 和 iterate 是两个用来创建无限 Stream 的静态方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sample2</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Stream&lt;String&gt; echos = Stream.generate(() -&gt; <span class=\"string\">\"Echo\"</span>);</span><br><span class=\"line\">        Stream&lt;Double&gt; randoms = Stream.generate(Math::random);</span><br><span class=\"line\">        Stream&lt;BigInteger&gt; integers = Stream.iterate(BigInteger.ZERO, n -&gt; n.add(BigInteger.ONE));</span><br><span class=\"line\"></span><br><span class=\"line\">        Object[] powers = Stream.iterate(<span class=\"number\">1.0</span>, p -&gt; p * <span class=\"number\">2</span>).peek(e -&gt; System.out.println(<span class=\"string\">\"Fetching \"</span> + e)).limit(<span class=\"number\">20</span>).toArray();</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"well done ...\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"filter、map-和-flatMap\"><a href=\"#filter、map-和-flatMap\" class=\"headerlink\" title=\"filter、map 和 flatMap\"></a>filter、map 和 flatMap</h3><p>流转换指从一个流中读取数据，并将转换后的数据写入另一个流。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sample3</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        List&lt;String&gt; list = letters();</span><br><span class=\"line\">        Stream&lt;String&gt; lowerString = list.stream().map(String::toLowerCase);</span><br><span class=\"line\">        lowerString.forEach(System.out::println);</span><br><span class=\"line\"></span><br><span class=\"line\">        Stream&lt;Character&gt; characterStream = list.stream().flatMap(Sample3::characterStream);</span><br><span class=\"line\">        characterStream.forEach(System.out::println);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> List&lt;String&gt; <span class=\"title\">letters</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        List&lt;String&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        list.add(<span class=\"string\">\"Tommy\"</span>);</span><br><span class=\"line\">        list.add(<span class=\"string\">\"Focus\"</span>);</span><br><span class=\"line\">        list.add(<span class=\"string\">\"Tim\"</span>);</span><br><span class=\"line\">        list.add(<span class=\"string\">\"Jack\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> list;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Stream&lt;Character&gt; <span class=\"title\">characterStream</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">        List&lt;Character&gt; result = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">char</span> c : s.toCharArray()) &#123;</span><br><span class=\"line\">            result.add(c);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result.stream();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>map 方法，会对每个元素应用一个函数，将返回值收集到一个新的流中。</li>\n<li>flatMap 方法，完成从 T 到 G\\<U> 的 f 函数和从 U 到 G\\<U> 的 g 方法，这是 monads 理论的一个关键概念。</li>\n</ol>\n<h3 id=\"提取子流和组合流\"><a href=\"#提取子流和组合流\" class=\"headerlink\" title=\"提取子流和组合流\"></a>提取子流和组合流</h3><p>Stream.limit(n) 返回一个 n 个元素的新流（如果原始流的长度小于n，则返回原始的流）。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sample5</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        unique();</span><br><span class=\"line\"></span><br><span class=\"line\">        sort();</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">unique</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        Stream&lt;String&gt; uniqueWords = Stream.of(<span class=\"string\">\"zhuxh\"</span>, <span class=\"string\">\"zhuxh\"</span>, <span class=\"string\">\"zhuxh\"</span>, <span class=\"string\">\"focus\"</span>).distinct();</span><br><span class=\"line\">        uniqueWords.forEach(System.out::println);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">sort</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        List&lt;String&gt; list = letters();</span><br><span class=\"line\">        Stream&lt;String&gt; stringStream = list.stream();</span><br><span class=\"line\"></span><br><span class=\"line\">        Stream&lt;String&gt; longestFirst = stringStream.sorted(Comparator.comparing(String::length).reversed());</span><br><span class=\"line\">        longestFirst.forEach(System.out::println);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> List&lt;String&gt; <span class=\"title\">letters</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        List&lt;String&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        list.add(<span class=\"string\">\"Tommy\"</span>);</span><br><span class=\"line\">        list.add(<span class=\"string\">\"Focus\"</span>);</span><br><span class=\"line\">        list.add(<span class=\"string\">\"Tim\"</span>);</span><br><span class=\"line\">        list.add(<span class=\"string\">\"Jack\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> list;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"简单的聚合方法\"><a href=\"#简单的聚合方法\" class=\"headerlink\" title=\"简单的聚合方法\"></a>简单的聚合方法</h3><p>聚合方法都是<em>终止操作</em>，当一个流应用了终止操作后，不能再应用其他操作。</p>\n<p>聚合方法，count、max、min，返回一个 Optional<T> 值，可能封装返回值，也可能没有返回值。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sample6</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Stream&lt;String&gt; stringStream = letters().stream();</span><br><span class=\"line\"></span><br><span class=\"line\">        Optional&lt;String&gt; largestString = stringStream.max(String::compareToIgnoreCase);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(largestString.isPresent())&#123;</span><br><span class=\"line\">            System.out.println(largestString.get());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> List&lt;String&gt; <span class=\"title\">letters</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        List&lt;String&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        list.add(<span class=\"string\">\"Tommy\"</span>);</span><br><span class=\"line\">        list.add(<span class=\"string\">\"Focus\"</span>);</span><br><span class=\"line\">        list.add(<span class=\"string\">\"Tim\"</span>);</span><br><span class=\"line\">        list.add(<span class=\"string\">\"Jack\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> list;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>类似的API还有 findFirst(), findAny()。</p>\n<p>还提供了 anyMatch(), allMatch 和 noneMatch()，这些方法总是会检查整个流，但仍可以通过并行执行来提高速度。</p>\n<h3 id=\"Optional-类型\"><a href=\"#Optional-类型\" class=\"headerlink\" title=\"Optional 类型\"></a>Optional 类型</h3><p>java.util.Optional\\<T\\></p>\n<p>Optional\\<T\\> 对象是对一个 T 类型对象的封装，或者表示不是任何对象。它比一般指向 T 类型引用更安全，不会反悔null–前提是你正确使用。</p>\n<p>创建 Optional 对象</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; <span class=\"function\">Optional&lt;T&gt; <span class=\"title\">of</span><span class=\"params\">(T value)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Optional&lt;&gt;(value);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; <span class=\"function\">Optional&lt;T&gt; <span class=\"title\">ofNullable</span><span class=\"params\">(T value)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> value == <span class=\"keyword\">null</span> ? empty() : of(value);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span>&lt;T&gt; Optional&lt;T&gt; <span class=\"title\">empty</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"unchecked\"</span>)</span><br><span class=\"line\">    Optional&lt;T&gt; t = (Optional&lt;T&gt;) EMPTY;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> t;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>获取值</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">get</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">if</span> (value == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">         <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NoSuchElementException(<span class=\"string\">\"No value present\"</span>);</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     <span class=\"keyword\">return</span> value;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>ifPresent 方法另一种形式可以接受一个函数，如存在可选值，它会将该值传递给函数，否则不进行任何操作。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isPresent</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> value != <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">ifPresent</span><span class=\"params\">(Consumer&lt;? <span class=\"keyword\">super</span> T&gt; consumer)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (value != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        consumer.accept(value);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"flatMap\"><a href=\"#flatMap\" class=\"headerlink\" title=\"flatMap\"></a>flatMap</h4><p>组合可选值函数</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyMath</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Optional&lt;Double&gt; <span class=\"title\">inverse</span><span class=\"params\">(Double x)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> x == <span class=\"number\">0</span> ? Optional.empty() : Optional.of(<span class=\"number\">1</span> / x);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Optional&lt;Double&gt; <span class=\"title\">squareRoot</span><span class=\"params\">(Double x)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> x &lt; <span class=\"number\">0</span> ? Optional.empty() : Optional.of(Math.sqrt(x));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Double x = <span class=\"number\">1</span>d;</span><br><span class=\"line\"></span><br><span class=\"line\">        Optional&lt;Double&gt; result = MyMath.inverse(x).flatMap(MyMath::squareRoot);</span><br><span class=\"line\"></span><br><span class=\"line\">        Optional&lt;Double&gt; res2 = Optional.of(-<span class=\"number\">4</span>d).flatMap(MyMath::inverse).flatMap(MyMath::squareRoot);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"聚合\"><a href=\"#聚合\" class=\"headerlink\" title=\"聚合\"></a>聚合</h3><p>元素求和</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sample2</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        List&lt;Integer&gt; intList = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">100</span>; i++) &#123;</span><br><span class=\"line\">            intList.add(i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Stream&lt;Integer&gt; stream = intList.stream();</span><br><span class=\"line\"></span><br><span class=\"line\">        Optional&lt;Integer&gt; sum = stream.reduce(Integer::sum);</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(sum.get());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>字符串长度求和</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sample7</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        List&lt;String&gt; list = letters();</span><br><span class=\"line\">        </span><br><span class=\"line\">        Stream&lt;String&gt; stream = list.stream();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> res = stream.reduce(<span class=\"number\">0</span>, (total, word) -&gt; total + word.length(), (t1, t2) -&gt; t1 + t2);</span><br><span class=\"line\">        System.out.println(res);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> res2 = stream.mapToInt(String::length).sum();</span><br><span class=\"line\">        System.out.println(res2);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> List&lt;String&gt; <span class=\"title\">letters</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        List&lt;String&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        list.add(<span class=\"string\">\"Tommy\"</span>);</span><br><span class=\"line\">        list.add(<span class=\"string\">\"Focus\"</span>);</span><br><span class=\"line\">        list.add(<span class=\"string\">\"Tim\"</span>);</span><br><span class=\"line\">        list.add(<span class=\"string\">\"Jack\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> list;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"收集结果\"><a href=\"#收集结果\" class=\"headerlink\" title=\"收集结果\"></a>收集结果</h3><p>处理完流之后，收集结果</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sample8</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        String[] words = <span class=\"keyword\">new</span> String[]&#123;<span class=\"string\">\"Tommy\"</span>, <span class=\"string\">\"Focus\"</span>, <span class=\"string\">\"Tim\"</span>, <span class=\"string\">\"Jack\"</span>&#125;;</span><br><span class=\"line\">        Stream&lt;String&gt; stream = Arrays.stream(words);</span><br><span class=\"line\">        HashSet&lt;String&gt; hashSet = stream.collect(HashSet::<span class=\"keyword\">new</span>, HashSet::add, HashSet::addAll);</span><br><span class=\"line\"></span><br><span class=\"line\">        List&lt;String&gt; list = Arrays.stream(words).collect(Collectors.toList());</span><br><span class=\"line\">        Set&lt;String&gt; set = Arrays.stream(words).collect(Collectors.toSet());</span><br><span class=\"line\"></span><br><span class=\"line\">        TreeSet&lt;String&gt; treeSet = Arrays.stream(words).collect(Collectors.toCollection(TreeSet::<span class=\"keyword\">new</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">        String strJoin = Arrays.stream(words).collect(Collectors.joining());</span><br><span class=\"line\"></span><br><span class=\"line\">        String result = Arrays.stream(words).collect(Collectors.joining(<span class=\"string\">\",\"</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">        String result2 = Arrays.stream(words).map(Object::toString).collect(Collectors.joining(<span class=\"string\">\",\"</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        IntSummaryStatistics summary = Arrays.stream(words).collect(Collectors.summarizingInt(String::length));</span><br><span class=\"line\">        <span class=\"keyword\">double</span> averagwLength = summary.getAverage();</span><br><span class=\"line\">        <span class=\"keyword\">double</span> maxLength = summary.getMax();</span><br><span class=\"line\">        <span class=\"keyword\">double</span> min = summary.getMin();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"收集结果到-Map\"><a href=\"#收集结果到-Map\" class=\"headerlink\" title=\"收集结果到 Map\"></a>收集结果到 Map</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sample9</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        User user1 = <span class=\"keyword\">new</span> User(<span class=\"number\">1</span>, <span class=\"string\">\"Focus\"</span>);</span><br><span class=\"line\">        User user2 = <span class=\"keyword\">new</span> User(<span class=\"number\">2</span>, <span class=\"string\">\"Tommy\"</span>);</span><br><span class=\"line\">        User user3 = <span class=\"keyword\">new</span> User(<span class=\"number\">3</span>, <span class=\"string\">\"Jack\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        List&lt;User&gt; list = Arrays.asList(user1, user2, user3);</span><br><span class=\"line\"></span><br><span class=\"line\">        s1(list);</span><br><span class=\"line\">        s2(list);</span><br><span class=\"line\">        s3(list);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * key重复会抛异常</span></span><br><span class=\"line\"><span class=\"comment\">     **/</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">s1</span><span class=\"params\">(List&lt;User&gt; list)</span> </span>&#123;</span><br><span class=\"line\">        Map&lt;Integer, String&gt; idToName = list.stream().collect(Collectors.toMap(User::getId, User::getName));</span><br><span class=\"line\">        Map&lt;Integer, User&gt; idToUser = list.stream().collect(Collectors.toMap(User::getId, Function.identity()));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">s2</span><span class=\"params\">(List&lt;User&gt; list)</span> </span>&#123;</span><br><span class=\"line\">        User user = <span class=\"keyword\">new</span> User(<span class=\"number\">1</span>, <span class=\"string\">\"Billy\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        List&lt;User&gt; userList = <span class=\"keyword\">new</span> ArrayList&lt;&gt;(list);</span><br><span class=\"line\">        userList.add(user);</span><br><span class=\"line\"></span><br><span class=\"line\">        Map&lt;Integer, Set&lt;String&gt;&gt; idToName = userList.stream().collect(Collectors.toMap(</span><br><span class=\"line\">                u -&gt; u.getId(),</span><br><span class=\"line\">                u -&gt; Collections.singleton(u.getName()),</span><br><span class=\"line\">                (a, b) -&gt; &#123;</span><br><span class=\"line\">                    Set&lt;String&gt; r = <span class=\"keyword\">new</span> HashSet&lt;String&gt;(a);</span><br><span class=\"line\">                    r.addAll(b);</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> r;</span><br><span class=\"line\">                &#125;));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">s3</span><span class=\"params\">(List&lt;User&gt; list)</span> </span>&#123;</span><br><span class=\"line\">        Map&lt;Integer, User&gt; idToUser = list.stream().collect(</span><br><span class=\"line\">                Collectors.toMap(</span><br><span class=\"line\">                        User::getId,</span><br><span class=\"line\">                        Function.identity(),</span><br><span class=\"line\">                        (existingVal, newVal) -&gt; &#123;</span><br><span class=\"line\">                            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException();</span><br><span class=\"line\">                        &#125;,</span><br><span class=\"line\">                        TreeMap::<span class=\"keyword\">new</span></span><br><span class=\"line\">                )</span><br><span class=\"line\">        );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"分组、分片\"><a href=\"#分组、分片\" class=\"headerlink\" title=\"分组、分片\"></a>分组、分片</h3><p>对流处理结果分组、分片。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">User</span><span class=\"params\">(Integer id, String name)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.id = id;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.email = name + <span class=\"string\">\"@qiyi.com\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">User</span><span class=\"params\">(Integer id, String name, Integer sex)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>(id, name);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.sex = sex;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Integer id;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String email;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Integer sex;</span><br><span class=\"line\">    </span><br><span class=\"line\">    ....</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sample10</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        User user1 = <span class=\"keyword\">new</span> User(<span class=\"number\">1</span>, <span class=\"string\">\"Focus\"</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">        User user2 = <span class=\"keyword\">new</span> User(<span class=\"number\">2</span>, <span class=\"string\">\"Tommy\"</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">        User user3 = <span class=\"keyword\">new</span> User(<span class=\"number\">3</span>, <span class=\"string\">\"Jack\"</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        User user4 = <span class=\"keyword\">new</span> User(<span class=\"number\">4</span>, <span class=\"string\">\"Rose\"</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">        User user5 = <span class=\"keyword\">new</span> User(<span class=\"number\">5</span>, <span class=\"string\">\"Jane\"</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        List&lt;User&gt; list = Arrays.asList(user1, user2, user3, user4, user5);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/** 按性别分组**/</span></span><br><span class=\"line\">        Map&lt;Integer, List&lt;User&gt;&gt; map = list.stream().collect(Collectors.groupingBy(User::getSex));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/** 按ID小于等于3分组**/</span></span><br><span class=\"line\">        Map&lt;Boolean, List&lt;User&gt;&gt; map1 = list.stream().collect(Collectors.partitioningBy(e -&gt; e.getId() &lt;= <span class=\"number\">3</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/** 按性别分组 收集为set**/</span></span><br><span class=\"line\">        Map&lt;Integer, Set&lt;User&gt;&gt; map2 = list.stream().collect(Collectors.groupingBy(User::getSex, Collectors.toSet()));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Java8 还提供了其他收集器，用来对分组后元素进行 downstream 处理：</p>\n<ul>\n<li>counting 返回收集元素总个数</li>\n<li>summing (Int|Long|Double) 接受一个函数作为参数，将该函数应用到downstream元素中，求和</li>\n<li>maxBy、minBy 接受一个比较器，生成 downstream 元素中最大值和最小值</li>\n<li>mapping 方法将一个函数应用到 downstream 结果上，并且需要另一个收集器来处理结果</li>\n<li>….</li>\n</ul>\n<h3 id=\"原始类型流\"><a href=\"#原始类型流\" class=\"headerlink\" title=\"原始类型流\"></a>原始类型流</h3><p>将每个整数包装成响应对象很低效，Stream API 提供了 IntStream、LongStream 和 DoubleStream 等类型，专门用来直接存储原始类型值。如果要存 short、char、byte 和 boolean 类型，使用 IntStream；如果要存储 float 类型，使用 DoubleStream。设计者认为，不需要为其他5种原始类型都添加对应的专门类型。</p>\n<p>将原始类型流转换为一个对象流，可以使用 boxed 方法:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Stream&lt;Integer&gt; integers = IntStream.range(<span class=\"number\">0</span>, <span class=\"number\">100</span>).boxed();</span><br></pre></td></tr></table></figure>\n<p>原始类型流方法与对象流上调用类似，但有以下几点显著区别：</p>\n<ul>\n<li>toArray 返回原始类型数组。</li>\n<li>产生 Optional 结果的方法返回一个 OptionalInt、OptionalLong 或者 OptionalDouble 类型，这些与 Optional 类似，但没有 get 方法，而是对应的 getAsInt、getAsLong 和 getAsDouble。</li>\n<li>方法 sum、average、max 和 min 会返回总和、平均值、最大值和最小值。对象流中没有定义这些方法。</li>\n<li>summaryStatistics 方法产生一个 IntSummaryStatistics、LongSummaryStatistics 或者 DoubleSummaryStatistics 对象。  </li>\n</ul>\n<h3 id=\"并行流\"><a href=\"#并行流\" class=\"headerlink\" title=\"并行流\"></a>并行流</h3><p>流使得并行计算变得容易。处理过程几乎全自动。但必须遵守一些约定。</p>\n<ul>\n<li>创建并行流， Collection.parellelStream, parallel 方法。</li>\n<li>确保传递给并行流操作的函数都是线程安全的。</li>\n</ul>\n<p>有序并不妨碍并行。例如，计算 stream.map(fun) 时，流可以被分片为 n 段，每一段都被并发处理，然后按顺序组合结果。</p>\n<p>执行一个流操作时，不会修改流底层的集合（即使修改是线程安全）。流不会收集它自己的数据—-这些数据总是存在于另一个集合中。如果你想修改原有集合，那么就无法定义流操作的输出。JDK 文档称这种需求为“不干扰”。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//正确</span></span><br><span class=\"line\">List&lt;String&gt; wordList = ...;</span><br><span class=\"line\">Stream&lt;String&gt; words = wordList.stream();</span><br><span class=\"line\">wordList.add(<span class=\"string\">\"END\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">long</span> n = words.distinct().count();</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//错误</span></span><br><span class=\"line\">Stream&lt;String&gt; words = wordList.stream();</span><br><span class=\"line\">words.forEach(s -&gt; <span class=\"keyword\">if</span> (s.length() &lt; <span class=\"number\">12</span>) wordList.remove(s));</span><br></pre></td></tr></table></figure>"}],"PostAsset":[],"PostCategory":[{"post_id":"ck1j8f2fq00017h9m3z6m1x2m","category_id":"ck1j8f2g700057h9meigri77v","_id":"ck1j8f2gy000e7h9mmkd7a7d2"},{"post_id":"ck1j8f2fw00027h9mmmd67ynb","category_id":"ck1j8f2ga00077h9mfyeacnmm","_id":"ck1j8f2h3000h7h9mm1tn71cv"},{"post_id":"ck1j8f2fy00037h9m502g6aea","category_id":"ck1j8f2gb00097h9mlasjz8dt","_id":"ck1j8f2h5000k7h9m1krrximw"},{"post_id":"ck1j8f2h3000i7h9mdzndq87f","category_id":"ck1j8f2ga00077h9mfyeacnmm","_id":"ck1j8f2io001g7h9m14n61v6g"},{"post_id":"ck1j8f2h5000l7h9mi55tg8s5","category_id":"ck1j8f2ga00077h9mfyeacnmm","_id":"ck1j8f2ip001j7h9mtao6evhm"},{"post_id":"ck1j8f2h6000n7h9mkrwrrim0","category_id":"ck1j8f2ga00077h9mfyeacnmm","_id":"ck1j8f2iq001m7h9m5zugw57n"},{"post_id":"ck1j8f2h7000p7h9mmr7s1412","category_id":"ck1j8f2ga00077h9mfyeacnmm","_id":"ck1j8f2is001r7h9m5k945fft"},{"post_id":"ck1j8f2i400187h9mrthcz6i7","category_id":"ck1j8f2gb00097h9mlasjz8dt","_id":"ck1j8f2is001t7h9mq1ygmyxh"},{"post_id":"ck1j8f2i500197h9me5krusu9","category_id":"ck1j8f2gb00097h9mlasjz8dt","_id":"ck1j8f2iu001x7h9mljlrfbcg"},{"post_id":"ck1j8f2i6001a7h9mc6qs2jhr","category_id":"ck1j8f2gb00097h9mlasjz8dt","_id":"ck1j8f2iv001y7h9mjizhjtiu"},{"post_id":"ck1j8f2i7001b7h9m1m8497b4","category_id":"ck1j8f2gb00097h9mlasjz8dt","_id":"ck1j8f2iv00217h9m12ul55y8"},{"post_id":"ck1j8f2gz000f7h9miype1jx3","category_id":"ck1j8f2io001d7h9mjvt8860y","_id":"ck1j8f2jr00347h9mkf1bb7nb"},{"post_id":"ck1j8f2h8000q7h9mm8y8dmas","category_id":"ck1j8f2iq001n7h9m24wdhi3p","_id":"ck1j8f2js00367h9mn89madb4"},{"post_id":"ck1j8f2hb000r7h9m8yrm344n","category_id":"ck1j8f2it001u7h9mqpt2wc9a","_id":"ck1j8f2js00387h9m53wpv9ia"},{"post_id":"ck1j8f2hc000s7h9mzs437lzf","category_id":"ck1j8f2it001u7h9mqpt2wc9a","_id":"ck1j8f2jt003b7h9mgivy003o"},{"post_id":"ck1j8f2hd000t7h9mcr3e8tzd","category_id":"ck1j8f2it001u7h9mqpt2wc9a","_id":"ck1j8f2jt003d7h9mewyn49v2"},{"post_id":"ck1j8f2he000u7h9mu2d9rsps","category_id":"ck1j8f2it001u7h9mqpt2wc9a","_id":"ck1j8f2ju003g7h9mtumgrxg1"},{"post_id":"ck1j8f2hf000v7h9mma86hvr2","category_id":"ck1j8f2it001u7h9mqpt2wc9a","_id":"ck1j8f2ju003i7h9md8r0pnu0"},{"post_id":"ck1j8f2hh000w7h9m2yqq4sxr","category_id":"ck1j8f2it001u7h9mqpt2wc9a","_id":"ck1j8f2ju003l7h9m2bkj0vjk"},{"post_id":"ck1j8f2ho000x7h9mmyd7ovna","category_id":"ck1j8f2it001u7h9mqpt2wc9a","_id":"ck1j8f2jv003n7h9mlz6byi88"},{"post_id":"ck1j8f2hq000y7h9mxo9qzqwf","category_id":"ck1j8f2it001u7h9mqpt2wc9a","_id":"ck1j8f2jv003q7h9m32r047xy"},{"post_id":"ck1j8f2hr000z7h9msnbr6qi3","category_id":"ck1j8f2it001u7h9mqpt2wc9a","_id":"ck1j8f2jw003s7h9m1ivu4arq"},{"post_id":"ck1j8f2hs00107h9m1jlxpdmz","category_id":"ck1j8f2it001u7h9mqpt2wc9a","_id":"ck1j8f2jx003u7h9mv6ju6vy2"},{"post_id":"ck1j8f2hu00117h9mnno1sinq","category_id":"ck1j8f2it001u7h9mqpt2wc9a","_id":"ck1j8f2jy003w7h9mxh3ev93g"},{"post_id":"ck1j8f2hv00127h9mxpupf43c","category_id":"ck1j8f2it001u7h9mqpt2wc9a","_id":"ck1j8f2jy003y7h9m9pee7i0f"},{"post_id":"ck1j8f2hw00137h9m4neqz99l","category_id":"ck1j8f2it001u7h9mqpt2wc9a","_id":"ck1j8f2jy00407h9mejycgekc"},{"post_id":"ck1j8f2hz00147h9muacpuqhs","category_id":"ck1j8f2it001u7h9mqpt2wc9a","_id":"ck1j8f2jz00427h9moljkkmy6"},{"post_id":"ck1j8f2i100157h9macdfsgye","category_id":"ck1j8f2it001u7h9mqpt2wc9a","_id":"ck1j8f2jz00447h9m2sdk1djb"},{"post_id":"ck1j8f2i200167h9mvk262j36","category_id":"ck1j8f2jb002s7h9mwk3dant9","_id":"ck1j8f2jz00467h9mdrrkopfz"},{"post_id":"ck1j8f2i300177h9mn12aa2u0","category_id":"ck1j8f2it001u7h9mqpt2wc9a","_id":"ck1j8f2jz00487h9m0z1x6xqp"},{"post_id":"ck1j8f2in001c7h9mcovaxj0p","category_id":"ck1j8f2ga00077h9mfyeacnmm","_id":"ck1j8f2jz004a7h9m8n5yy5kp"},{"post_id":"ck1j8f2ip001h7h9mta8ngz4i","category_id":"ck1j8f2ga00077h9mfyeacnmm","_id":"ck1j8f2k0004c7h9mhiuskt3l"},{"post_id":"ck1j8f2iq001k7h9mds4tfk67","category_id":"ck1j8f2ga00077h9mfyeacnmm","_id":"ck1j8f2k0004e7h9mztc2lbvj"},{"post_id":"ck1j8f2is001s7h9mqrcd1xvi","category_id":"ck1j8f2jb002s7h9mwk3dant9","_id":"ck1j8f2k0004g7h9ma9ye7gvl"},{"post_id":"ck1j8f2iu001w7h9mvyxq8kgs","category_id":"ck1j8f2gb00097h9mlasjz8dt","_id":"ck1j8f2k0004i7h9m39daqiox"},{"post_id":"ck1j8f2ir001p7h9mw3pvjkvg","category_id":"ck1j8f2jr00337h9m19frd0ya","_id":"ck1j8f2k3004n7h9m34ewyigj"},{"post_id":"ck1j8f2jq00307h9mkih52f72","category_id":"ck1j8f2ga00077h9mfyeacnmm","_id":"ck1j8f2k3004p7h9m3bbqp02z"}],"PostTag":[{"post_id":"ck1j8f2fq00017h9m3z6m1x2m","tag_id":"ck1j8f2g900067h9m4z20a1hq","_id":"ck1j8f2gy000d7h9m9q7vpwn8"},{"post_id":"ck1j8f2fq00017h9m3z6m1x2m","tag_id":"ck1j8f2gb00087h9mizyvmkpt","_id":"ck1j8f2h3000g7h9m73opbz98"},{"post_id":"ck1j8f2fw00027h9mmmd67ynb","tag_id":"ck1j8f2g900067h9m4z20a1hq","_id":"ck1j8f2h5000j7h9mup1sma51"},{"post_id":"ck1j8f2fw00027h9mmmd67ynb","tag_id":"ck1j8f2gc000b7h9m3yz345sp","_id":"ck1j8f2h6000m7h9m25wa7ypi"},{"post_id":"ck1j8f2fy00037h9m502g6aea","tag_id":"ck1j8f2g900067h9m4z20a1hq","_id":"ck1j8f2h7000o7h9m39rkws3l"},{"post_id":"ck1j8f2i400187h9mrthcz6i7","tag_id":"ck1j8f2g900067h9m4z20a1hq","_id":"ck1j8f2io001f7h9mls79abj0"},{"post_id":"ck1j8f2i500197h9me5krusu9","tag_id":"ck1j8f2g900067h9m4z20a1hq","_id":"ck1j8f2ip001i7h9m8zh5hjs4"},{"post_id":"ck1j8f2i6001a7h9mc6qs2jhr","tag_id":"ck1j8f2g900067h9m4z20a1hq","_id":"ck1j8f2iq001l7h9mlo75drdd"},{"post_id":"ck1j8f2i7001b7h9m1m8497b4","tag_id":"ck1j8f2g900067h9m4z20a1hq","_id":"ck1j8f2ir001q7h9m85kr0ww1"},{"post_id":"ck1j8f2gz000f7h9miype1jx3","tag_id":"ck1j8f2io001e7h9mtwpjvya3","_id":"ck1j8f2jr00317h9mbq1206lq"},{"post_id":"ck1j8f2h3000i7h9mdzndq87f","tag_id":"ck1j8f2iq001o7h9mteo4ah5z","_id":"ck1j8f2jr00357h9mp4wat9uh"},{"post_id":"ck1j8f2h5000l7h9mi55tg8s5","tag_id":"ck1j8f2it001v7h9me2ypuotg","_id":"ck1j8f2js00377h9m5wvimk5k"},{"post_id":"ck1j8f2h6000n7h9mkrwrrim0","tag_id":"ck1j8f2g900067h9m4z20a1hq","_id":"ck1j8f2jt003a7h9m9cw3c9pc"},{"post_id":"ck1j8f2h6000n7h9mkrwrrim0","tag_id":"ck1j8f2iv00207h9m2z5rtwi6","_id":"ck1j8f2jt003c7h9mjehwchs2"},{"post_id":"ck1j8f2h7000p7h9mmr7s1412","tag_id":"ck1j8f2g900067h9m4z20a1hq","_id":"ck1j8f2ju003f7h9mskgg5l67"},{"post_id":"ck1j8f2h7000p7h9mmr7s1412","tag_id":"ck1j8f2iy00237h9mlhzdqzb5","_id":"ck1j8f2ju003h7h9m5r033xo2"},{"post_id":"ck1j8f2h8000q7h9mm8y8dmas","tag_id":"ck1j8f2iz00257h9mg1s52ij0","_id":"ck1j8f2ju003k7h9mz824ugcd"},{"post_id":"ck1j8f2hb000r7h9m8yrm344n","tag_id":"ck1j8f2j000277h9mjyc9t4ee","_id":"ck1j8f2jv003m7h9msqjon6vh"},{"post_id":"ck1j8f2hc000s7h9mzs437lzf","tag_id":"ck1j8f2j000277h9mjyc9t4ee","_id":"ck1j8f2jv003o7h9mrrg36jcf"},{"post_id":"ck1j8f2hd000t7h9mcr3e8tzd","tag_id":"ck1j8f2j000277h9mjyc9t4ee","_id":"ck1j8f2jw003r7h9mnomkovdj"},{"post_id":"ck1j8f2he000u7h9mu2d9rsps","tag_id":"ck1j8f2j000277h9mjyc9t4ee","_id":"ck1j8f2jx003t7h9m4tgqxitg"},{"post_id":"ck1j8f2hf000v7h9mma86hvr2","tag_id":"ck1j8f2j000277h9mjyc9t4ee","_id":"ck1j8f2jy003v7h9mw0cvkezu"},{"post_id":"ck1j8f2hh000w7h9m2yqq4sxr","tag_id":"ck1j8f2j000277h9mjyc9t4ee","_id":"ck1j8f2jy003x7h9mwe6ow5lq"},{"post_id":"ck1j8f2ho000x7h9mmyd7ovna","tag_id":"ck1j8f2j000277h9mjyc9t4ee","_id":"ck1j8f2jy003z7h9mjs9zftop"},{"post_id":"ck1j8f2hq000y7h9mxo9qzqwf","tag_id":"ck1j8f2j000277h9mjyc9t4ee","_id":"ck1j8f2jz00417h9mh3fxpahw"},{"post_id":"ck1j8f2hr000z7h9msnbr6qi3","tag_id":"ck1j8f2j000277h9mjyc9t4ee","_id":"ck1j8f2jz00437h9m5xbjy5kf"},{"post_id":"ck1j8f2hs00107h9m1jlxpdmz","tag_id":"ck1j8f2j000277h9mjyc9t4ee","_id":"ck1j8f2jz00457h9mz27w94iw"},{"post_id":"ck1j8f2hu00117h9mnno1sinq","tag_id":"ck1j8f2j000277h9mjyc9t4ee","_id":"ck1j8f2jz00477h9mvpw6kp9w"},{"post_id":"ck1j8f2hv00127h9mxpupf43c","tag_id":"ck1j8f2j000277h9mjyc9t4ee","_id":"ck1j8f2jz00497h9mk67z9ys8"},{"post_id":"ck1j8f2hw00137h9m4neqz99l","tag_id":"ck1j8f2j000277h9mjyc9t4ee","_id":"ck1j8f2k0004b7h9m9wa96wbo"},{"post_id":"ck1j8f2hz00147h9muacpuqhs","tag_id":"ck1j8f2j000277h9mjyc9t4ee","_id":"ck1j8f2k0004d7h9muknri3tb"},{"post_id":"ck1j8f2i100157h9macdfsgye","tag_id":"ck1j8f2j000277h9mjyc9t4ee","_id":"ck1j8f2k0004f7h9mja611jo9"},{"post_id":"ck1j8f2i200167h9mvk262j36","tag_id":"ck1j8f2iy00237h9mlhzdqzb5","_id":"ck1j8f2k0004h7h9m97jx41sg"},{"post_id":"ck1j8f2i300177h9mn12aa2u0","tag_id":"ck1j8f2j000277h9mjyc9t4ee","_id":"ck1j8f2k0004j7h9mes7nnev8"},{"post_id":"ck1j8f2is001s7h9mqrcd1xvi","tag_id":"ck1j8f2iy00237h9mlhzdqzb5","_id":"ck1j8f2k0004k7h9mkgiyqe6m"},{"post_id":"ck1j8f2iu001w7h9mvyxq8kgs","tag_id":"ck1j8f2g900067h9m4z20a1hq","_id":"ck1j8f2k0004l7h9mfritu3z9"},{"post_id":"ck1j8f2in001c7h9mcovaxj0p","tag_id":"ck1j8f2jr00327h9mbd1asgnu","_id":"ck1j8f2k3004m7h9mkipb3rwe"},{"post_id":"ck1j8f2ip001h7h9mta8ngz4i","tag_id":"ck1j8f2g900067h9m4z20a1hq","_id":"ck1j8f2k3004o7h9m5czgzlxw"},{"post_id":"ck1j8f2ip001h7h9mta8ngz4i","tag_id":"ck1j8f2js00397h9mddublj70","_id":"ck1j8f2k3004q7h9mdz7fti9y"},{"post_id":"ck1j8f2iq001k7h9mds4tfk67","tag_id":"ck1j8f2g900067h9m4z20a1hq","_id":"ck1j8f2k3004r7h9mgfw0vaed"},{"post_id":"ck1j8f2iq001k7h9mds4tfk67","tag_id":"ck1j8f2jt003e7h9mctc14s2l","_id":"ck1j8f2k4004s7h9m5pzg37xp"},{"post_id":"ck1j8f2ir001p7h9mw3pvjkvg","tag_id":"ck1j8f2ju003j7h9m7pfp8mha","_id":"ck1j8f2k4004t7h9m6jncky4y"},{"post_id":"ck1j8f2ir001p7h9mw3pvjkvg","tag_id":"ck1j8f2jv003p7h9mxqznn5wn","_id":"ck1j8f2k4004u7h9m7b6vrn3t"},{"post_id":"ck1j8f2jq00307h9mkih52f72","tag_id":"ck1j8f2it001v7h9me2ypuotg","_id":"ck1j8f2k4004v7h9mger1hmas"}],"Tag":[{"name":"Java","_id":"ck1j8f2g900067h9m4z20a1hq"},{"name":"Elasticsearch","_id":"ck1j8f2gb00087h9mizyvmkpt"},{"name":"Servlet","_id":"ck1j8f2gc000b7h9m3yz345sp"},{"name":"HBase","_id":"ck1j8f2io001e7h9mtwpjvya3"},{"name":"DNS","_id":"ck1j8f2iq001o7h9mteo4ah5z"},{"name":"Java8","_id":"ck1j8f2it001v7h9me2ypuotg"},{"name":"NIO","_id":"ck1j8f2iv00207h9m2z5rtwi6"},{"name":"JVM","_id":"ck1j8f2iy00237h9mlhzdqzb5"},{"name":"Scala","_id":"ck1j8f2iz00257h9mg1s52ij0"},{"name":"Redis","_id":"ck1j8f2j000277h9mjyc9t4ee"},{"name":"Java7","_id":"ck1j8f2jr00327h9mbd1asgnu"},{"name":"Tomcat","_id":"ck1j8f2js00397h9mddublj70"},{"name":"IO","_id":"ck1j8f2jt003e7h9mctc14s2l"},{"name":"Hystrix","_id":"ck1j8f2ju003j7h9m7pfp8mha"},{"name":"SpringCloud","_id":"ck1j8f2jv003p7h9mxqznn5wn"}]}}